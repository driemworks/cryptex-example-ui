{"ast":null,"code":"import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './bip39-en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n  return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);\n}\nexport function mnemonicToSeedSync(mnemonic, password) {\n  return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;\n}\nexport function mnemonicToEntropy(mnemonic) {\n  const words = normalize(mnemonic).split(' ');\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  // convert word indices to 11 bit binary strings\n  const bits = words.map(word => {\n    const index = DEFAULT_WORDLIST.indexOf(word);\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n    return index.toString(2).padStart(11, '0');\n  }).join('');\n  // split the binary string into ENT/CS\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n  // calculate the checksum and compare\n  const matched = entropyBits.match(/(.{1,8})/g);\n  const entropyBytes = matched && matched.map(binaryToByte);\n  if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const entropy = u8aToU8a(entropyBytes);\n  if (deriveChecksumBits(entropy) !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n  return entropy;\n}\nexport function entropyToMnemonic(entropy) {\n  // 128 <= ENT <= 256\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);\n  const mapped = matched && matched.map(binary => DEFAULT_WORDLIST[binaryToByte(binary)]);\n  if (!mapped || mapped.length < 12) {\n    throw new Error('Unable to map entropy to mnemonic');\n  }\n  return mapped.join(' ');\n}\nexport function generateMnemonic(numWords) {\n  return entropyToMnemonic(randomAsU8a(numWords / 3 * 4));\n}\nexport function validateMnemonic(mnemonic) {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["stringToU8a","u8aToU8a","pbkdf2Encode","randomAsU8a","sha256AsU8a","DEFAULT_WORDLIST","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","normalize","str","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","padStart","join","deriveChecksumBits","entropyBuffer","Array","from","slice","length","mnemonicToSeedSync","mnemonic","password","mnemonicToEntropy","words","split","Error","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","matched","match","entropyBytes","entropy","entropyToMnemonic","mapped","binary","generateMnemonic","numWords","validateMnemonic"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/util-crypto/mnemonic/bip39.js"],"sourcesContent":["import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './bip39-en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => x.toString(2).padStart(8, '0')).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, (entropyBuffer.length * 8) / 32);\n}\nexport function mnemonicToSeedSync(mnemonic, password) {\n    return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;\n}\nexport function mnemonicToEntropy(mnemonic) {\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map((word) => {\n        const index = DEFAULT_WORDLIST.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return index.toString(2).padStart(11, '0');\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const matched = entropyBits.match(/(.{1,8})/g);\n    const entropyBytes = matched && matched.map(binaryToByte);\n    if (!entropyBytes || (entropyBytes.length % 4 !== 0) || (entropyBytes.length < 16) || (entropyBytes.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = u8aToU8a(entropyBytes);\n    if (deriveChecksumBits(entropy) !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy;\n}\nexport function entropyToMnemonic(entropy) {\n    // 128 <= ENT <= 256\n    if ((entropy.length % 4 !== 0) || (entropy.length < 16) || (entropy.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);\n    const mapped = matched && matched.map((binary) => DEFAULT_WORDLIST[binaryToByte(binary)]);\n    if (!mapped || (mapped.length < 12)) {\n        throw new Error('Unable to map entropy to mnemonic');\n    }\n    return mapped.join(' ');\n}\nexport function generateMnemonic(numWords) {\n    return entropyToMnemonic(randomAsU8a((numWords / 3) * 4));\n}\nexport function validateMnemonic(mnemonic) {\n    try {\n        mnemonicToEntropy(mnemonic);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}