{"ast":null,"code":"var _GenericSignerPayload_extraTypes;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Option, Struct } from '@polkadot/types-codec';\nimport { objectProperty, objectSpread, u8aToHex } from '@polkadot/util';\nconst knownTypes = {\n  address: 'Address',\n  blockHash: 'Hash',\n  blockNumber: 'BlockNumber',\n  era: 'ExtrinsicEra',\n  genesisHash: 'Hash',\n  method: 'Call',\n  nonce: 'Compact<Index>',\n  runtimeVersion: 'RuntimeVersion',\n  signedExtensions: 'Vec<Text>',\n  tip: 'Compact<Balance>',\n  version: 'u8'\n};\n/**\n * @name GenericSignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\nexport class GenericSignerPayload extends Struct {\n  constructor(registry, value) {\n    const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());\n    super(registry, objectSpread({}, extensionTypes, knownTypes), value);\n    _GenericSignerPayload_extraTypes.set(this, void 0);\n    __classPrivateFieldSet(this, _GenericSignerPayload_extraTypes, {}, \"f\");\n    const getter = key => this.get(key);\n    // add all extras that are not in the base types\n    for (const [key, type] of Object.entries(extensionTypes)) {\n      if (!knownTypes[key]) {\n        __classPrivateFieldGet(this, _GenericSignerPayload_extraTypes, \"f\")[key] = type;\n      }\n      objectProperty(this, key, getter);\n    }\n  }\n  get address() {\n    return this.getT('address');\n  }\n  get blockHash() {\n    return this.getT('blockHash');\n  }\n  get blockNumber() {\n    return this.getT('blockNumber');\n  }\n  get era() {\n    return this.getT('era');\n  }\n  get genesisHash() {\n    return this.getT('genesisHash');\n  }\n  get method() {\n    return this.getT('method');\n  }\n  get nonce() {\n    return this.getT('nonce');\n  }\n  get runtimeVersion() {\n    return this.getT('runtimeVersion');\n  }\n  get signedExtensions() {\n    return this.getT('signedExtensions');\n  }\n  get tip() {\n    return this.getT('tip');\n  }\n  get version() {\n    return this.getT('version');\n  }\n  /**\n   * @description Creates an representation of the structure as an ISignerPayload JSON\n   */\n  toPayload() {\n    const result = {};\n    const keys = Object.keys(__classPrivateFieldGet(this, _GenericSignerPayload_extraTypes, \"f\"));\n    // add any explicit overrides we may have\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = this.get(key);\n      const isOption = value instanceof Option;\n      // Don't include Option.isNone\n      if (!isOption || value.isSome) {\n        result[key] = value.toHex();\n      }\n    }\n    return objectSpread(result, {\n      // the known defaults as managed explicitly and has different\n      // formatting in cases, e.g. we mostly expose a hex format here\n      address: this.address.toString(),\n      blockHash: this.blockHash.toHex(),\n      blockNumber: this.blockNumber.toHex(),\n      era: this.era.toHex(),\n      genesisHash: this.genesisHash.toHex(),\n      method: this.method.toHex(),\n      nonce: this.nonce.toHex(),\n      signedExtensions: this.signedExtensions.map(e => e.toString()),\n      specVersion: this.runtimeVersion.specVersion.toHex(),\n      tip: this.tip.toHex(),\n      transactionVersion: this.runtimeVersion.transactionVersion.toHex(),\n      version: this.version.toNumber()\n    });\n  }\n  /**\n   * @description Creates a representation of the payload in raw Exrinsic form\n   */\n  toRaw() {\n    const payload = this.toPayload();\n    const data = u8aToHex(this.registry.createTypeUnsafe('ExtrinsicPayload', [payload, {\n      version: payload.version\n    }])\n    // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n    .toU8a({\n      method: true\n    }));\n    return {\n      address: payload.address,\n      data,\n      type: 'payload'\n    };\n  }\n}\n_GenericSignerPayload_extraTypes = new WeakMap();","map":{"version":3,"names":["_GenericSignerPayload_extraTypes","__classPrivateFieldGet","__classPrivateFieldSet","Option","Struct","objectProperty","objectSpread","u8aToHex","knownTypes","address","blockHash","blockNumber","era","genesisHash","method","nonce","runtimeVersion","signedExtensions","tip","version","GenericSignerPayload","constructor","registry","value","extensionTypes","getSignedExtensionTypes","getSignedExtensionExtra","set","getter","key","get","type","Object","entries","getT","toPayload","result","keys","i","length","isOption","isSome","toHex","toString","map","e","specVersion","transactionVersion","toNumber","toRaw","payload","data","createTypeUnsafe","toU8a","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/extrinsic/SignerPayload.js"],"sourcesContent":["var _GenericSignerPayload_extraTypes;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Option, Struct } from '@polkadot/types-codec';\nimport { objectProperty, objectSpread, u8aToHex } from '@polkadot/util';\nconst knownTypes = {\n    address: 'Address',\n    blockHash: 'Hash',\n    blockNumber: 'BlockNumber',\n    era: 'ExtrinsicEra',\n    genesisHash: 'Hash',\n    method: 'Call',\n    nonce: 'Compact<Index>',\n    runtimeVersion: 'RuntimeVersion',\n    signedExtensions: 'Vec<Text>',\n    tip: 'Compact<Balance>',\n    version: 'u8'\n};\n/**\n * @name GenericSignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\nexport class GenericSignerPayload extends Struct {\n    constructor(registry, value) {\n        const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());\n        super(registry, objectSpread({}, extensionTypes, knownTypes), value);\n        _GenericSignerPayload_extraTypes.set(this, void 0);\n        __classPrivateFieldSet(this, _GenericSignerPayload_extraTypes, {}, \"f\");\n        const getter = (key) => this.get(key);\n        // add all extras that are not in the base types\n        for (const [key, type] of Object.entries(extensionTypes)) {\n            if (!knownTypes[key]) {\n                __classPrivateFieldGet(this, _GenericSignerPayload_extraTypes, \"f\")[key] = type;\n            }\n            objectProperty(this, key, getter);\n        }\n    }\n    get address() {\n        return this.getT('address');\n    }\n    get blockHash() {\n        return this.getT('blockHash');\n    }\n    get blockNumber() {\n        return this.getT('blockNumber');\n    }\n    get era() {\n        return this.getT('era');\n    }\n    get genesisHash() {\n        return this.getT('genesisHash');\n    }\n    get method() {\n        return this.getT('method');\n    }\n    get nonce() {\n        return this.getT('nonce');\n    }\n    get runtimeVersion() {\n        return this.getT('runtimeVersion');\n    }\n    get signedExtensions() {\n        return this.getT('signedExtensions');\n    }\n    get tip() {\n        return this.getT('tip');\n    }\n    get version() {\n        return this.getT('version');\n    }\n    /**\n     * @description Creates an representation of the structure as an ISignerPayload JSON\n     */\n    toPayload() {\n        const result = {};\n        const keys = Object.keys(__classPrivateFieldGet(this, _GenericSignerPayload_extraTypes, \"f\"));\n        // add any explicit overrides we may have\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const value = this.get(key);\n            const isOption = value instanceof Option;\n            // Don't include Option.isNone\n            if (!isOption || value.isSome) {\n                result[key] = value.toHex();\n            }\n        }\n        return objectSpread(result, {\n            // the known defaults as managed explicitly and has different\n            // formatting in cases, e.g. we mostly expose a hex format here\n            address: this.address.toString(),\n            blockHash: this.blockHash.toHex(),\n            blockNumber: this.blockNumber.toHex(),\n            era: this.era.toHex(),\n            genesisHash: this.genesisHash.toHex(),\n            method: this.method.toHex(),\n            nonce: this.nonce.toHex(),\n            signedExtensions: this.signedExtensions.map((e) => e.toString()),\n            specVersion: this.runtimeVersion.specVersion.toHex(),\n            tip: this.tip.toHex(),\n            transactionVersion: this.runtimeVersion.transactionVersion.toHex(),\n            version: this.version.toNumber()\n        });\n    }\n    /**\n     * @description Creates a representation of the payload in raw Exrinsic form\n     */\n    toRaw() {\n        const payload = this.toPayload();\n        const data = u8aToHex(this.registry\n            .createTypeUnsafe('ExtrinsicPayload', [payload, { version: payload.version }])\n            // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n            .toU8a({ method: true }));\n        return {\n            address: payload.address,\n            data,\n            type: 'payload'\n        };\n    }\n}\n_GenericSignerPayload_extraTypes = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}