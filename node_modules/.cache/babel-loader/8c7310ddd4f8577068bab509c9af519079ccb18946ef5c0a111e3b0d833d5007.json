{"ast":null,"code":"import { createFunction } from './createFunction.js';\nfunction findSiPrimitive(registry, _prim) {\n  const prim = _prim.toLowerCase();\n  return registry.lookup.types.find(t => t.type.def.isPrimitive && t.type.def.asPrimitive.toString().toLowerCase() === prim || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);\n}\nfunction findSiType(registry, orig) {\n  let portable = findSiPrimitive(registry, orig);\n  if (!portable && orig === 'Bytes') {\n    const u8 = findSiPrimitive(registry, 'u8');\n    if (u8) {\n      portable = registry.lookup.types.find(t => t.type.def.isSequence && t.type.def.asSequence.type.eq(u8.id) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(orig));\n    }\n  }\n  if (!portable) {\n    console.warn(`Unable to map ${orig} to a lookup index`);\n  }\n  return portable;\n}\n/** @internal */\nexport function createRuntimeFunction(_ref, key, _ref2) {\n  let {\n    method,\n    prefix,\n    section\n  } = _ref;\n  let {\n    docs,\n    type\n  } = _ref2;\n  return registry => createFunction(registry, {\n    meta: registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n      docs: registry.createTypeUnsafe('Vec<Text>', [[docs]]),\n      modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', ['Required']),\n      name: registry.createTypeUnsafe('Text', [method]),\n      toJSON: () => key,\n      type: registry.createTypeUnsafe('StorageEntryTypeLatest', [{\n        Plain: findSiType(registry, type)?.id || 0\n      }])\n    }]),\n    method,\n    prefix,\n    section\n  }, {\n    key,\n    skipHashing: true\n  });\n}","map":{"version":3,"names":["createFunction","findSiPrimitive","registry","_prim","prim","toLowerCase","lookup","types","find","t","type","def","isPrimitive","asPrimitive","toString","isHistoricMetaCompat","asHistoricMetaCompat","findSiType","orig","portable","u8","isSequence","asSequence","eq","id","console","warn","createRuntimeFunction","_ref","key","_ref2","method","prefix","section","docs","meta","createTypeUnsafe","modifier","name","toJSON","Plain","skipHashing"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/metadata/decorate/storage/util.js"],"sourcesContent":["import { createFunction } from './createFunction.js';\nfunction findSiPrimitive(registry, _prim) {\n    const prim = _prim.toLowerCase();\n    return registry.lookup.types.find((t) => (t.type.def.isPrimitive &&\n        t.type.def.asPrimitive.toString().toLowerCase() === prim) || (t.type.def.isHistoricMetaCompat &&\n        t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim));\n}\nfunction findSiType(registry, orig) {\n    let portable = findSiPrimitive(registry, orig);\n    if (!portable && orig === 'Bytes') {\n        const u8 = findSiPrimitive(registry, 'u8');\n        if (u8) {\n            portable = registry.lookup.types.find((t) => (t.type.def.isSequence &&\n                t.type.def.asSequence.type.eq(u8.id)) || (t.type.def.isHistoricMetaCompat &&\n                t.type.def.asHistoricMetaCompat.eq(orig)));\n        }\n    }\n    if (!portable) {\n        console.warn(`Unable to map ${orig} to a lookup index`);\n    }\n    return portable;\n}\n/** @internal */\nexport function createRuntimeFunction({ method, prefix, section }, key, { docs, type }) {\n    return (registry) => createFunction(registry, {\n        meta: registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n                docs: registry.createTypeUnsafe('Vec<Text>', [[docs]]),\n                modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', ['Required']),\n                name: registry.createTypeUnsafe('Text', [method]),\n                toJSON: () => key,\n                type: registry.createTypeUnsafe('StorageEntryTypeLatest', [{ Plain: findSiType(registry, type)?.id || 0 }])\n            }]),\n        method,\n        prefix,\n        section\n    }, { key, skipHashing: true });\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,qBAAqB;AACpD,SAASC,eAAeA,CAACC,QAAQ,EAAEC,KAAK,EAAE;EACtC,MAAMC,IAAI,GAAGD,KAAK,CAACE,WAAW,EAAE;EAChC,OAAOH,QAAQ,CAACI,MAAM,CAACC,KAAK,CAACC,IAAI,CAAEC,CAAC,IAAMA,CAAC,CAACC,IAAI,CAACC,GAAG,CAACC,WAAW,IAC5DH,CAAC,CAACC,IAAI,CAACC,GAAG,CAACE,WAAW,CAACC,QAAQ,EAAE,CAACT,WAAW,EAAE,KAAKD,IAAI,IAAMK,CAAC,CAACC,IAAI,CAACC,GAAG,CAACI,oBAAoB,IAC7FN,CAAC,CAACC,IAAI,CAACC,GAAG,CAACK,oBAAoB,CAACF,QAAQ,EAAE,CAACT,WAAW,EAAE,KAAKD,IAAK,CAAC;AAC3E;AACA,SAASa,UAAUA,CAACf,QAAQ,EAAEgB,IAAI,EAAE;EAChC,IAAIC,QAAQ,GAAGlB,eAAe,CAACC,QAAQ,EAAEgB,IAAI,CAAC;EAC9C,IAAI,CAACC,QAAQ,IAAID,IAAI,KAAK,OAAO,EAAE;IAC/B,MAAME,EAAE,GAAGnB,eAAe,CAACC,QAAQ,EAAE,IAAI,CAAC;IAC1C,IAAIkB,EAAE,EAAE;MACJD,QAAQ,GAAGjB,QAAQ,CAACI,MAAM,CAACC,KAAK,CAACC,IAAI,CAAEC,CAAC,IAAMA,CAAC,CAACC,IAAI,CAACC,GAAG,CAACU,UAAU,IAC/DZ,CAAC,CAACC,IAAI,CAACC,GAAG,CAACW,UAAU,CAACZ,IAAI,CAACa,EAAE,CAACH,EAAE,CAACI,EAAE,CAAC,IAAMf,CAAC,CAACC,IAAI,CAACC,GAAG,CAACI,oBAAoB,IACzEN,CAAC,CAACC,IAAI,CAACC,GAAG,CAACK,oBAAoB,CAACO,EAAE,CAACL,IAAI,CAAE,CAAC;IAClD;EACJ;EACA,IAAI,CAACC,QAAQ,EAAE;IACXM,OAAO,CAACC,IAAI,CAAE,iBAAgBR,IAAK,oBAAmB,CAAC;EAC3D;EACA,OAAOC,QAAQ;AACnB;AACA;AACA,OAAO,SAASQ,qBAAqBA,CAAAC,IAAA,EAA8BC,GAAG,EAAAC,KAAA,EAAkB;EAAA,IAAlD;IAAEC,MAAM;IAAEC,MAAM;IAAEC;EAAQ,CAAC,GAAAL,IAAA;EAAA,IAAO;IAAEM,IAAI;IAAExB;EAAK,CAAC,GAAAoB,KAAA;EAClF,OAAQ5B,QAAQ,IAAKF,cAAc,CAACE,QAAQ,EAAE;IAC1CiC,IAAI,EAAEjC,QAAQ,CAACkC,gBAAgB,CAAC,4BAA4B,EAAE,CAAC;MACvDF,IAAI,EAAEhC,QAAQ,CAACkC,gBAAgB,CAAC,WAAW,EAAE,CAAC,CAACF,IAAI,CAAC,CAAC,CAAC;MACtDG,QAAQ,EAAEnC,QAAQ,CAACkC,gBAAgB,CAAC,4BAA4B,EAAE,CAAC,UAAU,CAAC,CAAC;MAC/EE,IAAI,EAAEpC,QAAQ,CAACkC,gBAAgB,CAAC,MAAM,EAAE,CAACL,MAAM,CAAC,CAAC;MACjDQ,MAAM,EAAEA,CAAA,KAAMV,GAAG;MACjBnB,IAAI,EAAER,QAAQ,CAACkC,gBAAgB,CAAC,wBAAwB,EAAE,CAAC;QAAEI,KAAK,EAAEvB,UAAU,CAACf,QAAQ,EAAEQ,IAAI,CAAC,EAAEc,EAAE,IAAI;MAAE,CAAC,CAAC;IAC9G,CAAC,CAAC,CAAC;IACPO,MAAM;IACNC,MAAM;IACNC;EACJ,CAAC,EAAE;IAAEJ,GAAG;IAAEY,WAAW,EAAE;EAAK,CAAC,CAAC;AAClC"},"metadata":{},"sourceType":"module","externalDependencies":[]}