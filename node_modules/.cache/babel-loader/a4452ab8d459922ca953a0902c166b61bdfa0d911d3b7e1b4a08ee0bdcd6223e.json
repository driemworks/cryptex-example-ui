{"ast":null,"code":"import { lazyMethods, logger, objectClear } from '@polkadot/util';\nconst l = logger('api/augment');\nfunction logLength(type, values) {\n  let and = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return values.length ? ` ${values.length} ${type}${and.length ? ' and' : ''}` : '';\n}\nfunction logValues(type, values) {\n  return values.length ? `\\n\\t${type.padStart(7)}: ${values.sort().join(', ')}` : '';\n}\nfunction warn(prefix, type, _ref) {\n  let [added, removed] = _ref;\n  if (added.length || removed.length) {\n    l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);\n  }\n}\nfunction findSectionExcludes(a, b) {\n  return a.filter(s => !b.includes(s));\n}\nfunction findSectionIncludes(a, b) {\n  return a.filter(s => b.includes(s));\n}\nfunction extractSections(src, dst) {\n  const srcSections = Object.keys(src);\n  const dstSections = Object.keys(dst);\n  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];\n}\nfunction findMethodExcludes(src, dst) {\n  const srcSections = Object.keys(src);\n  const dstSections = findSectionIncludes(Object.keys(dst), srcSections);\n  const excludes = [];\n  for (let s = 0; s < dstSections.length; s++) {\n    const section = dstSections[s];\n    const srcMethods = Object.keys(src[section]);\n    const dstMethods = Object.keys(dst[section]);\n    for (let d = 0; d < dstMethods.length; d++) {\n      const method = dstMethods[d];\n      if (!srcMethods.includes(method)) {\n        excludes.push(`${section}.${method}`);\n      }\n    }\n  }\n  return excludes;\n}\nfunction extractMethods(src, dst) {\n  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];\n}\n/**\n * @description Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing items into the result object.\n * @internal\n */\nexport function augmentObject(prefix, src, dst) {\n  let fromEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  fromEmpty && objectClear(dst);\n  // NOTE: This part is slightly problematic since it will get the\n  // values for at least all the sections and the names of the methods\n  // (Since methods won't be decorated before lazy, this _may_ be ok)\n  if (prefix && Object.keys(dst).length) {\n    warn(prefix, 'modules', extractSections(src, dst));\n    warn(prefix, 'calls', extractMethods(src, dst));\n  }\n  const sections = Object.keys(src);\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i];\n    const methods = src[section];\n    // We don't set here with a lazy interface, we decorate based\n    // on the top-level structure (this bypasses adding lazy onto lazy)\n    if (!dst[section]) {\n      dst[section] = {};\n    }\n    lazyMethods(dst[section], Object.keys(methods), m => methods[m]);\n  }\n  return dst;\n}","map":{"version":3,"names":["lazyMethods","logger","objectClear","l","logLength","type","values","and","arguments","length","undefined","logValues","padStart","sort","join","warn","prefix","_ref","added","removed","findSectionExcludes","a","b","filter","s","includes","findSectionIncludes","extractSections","src","dst","srcSections","Object","keys","dstSections","findMethodExcludes","excludes","section","srcMethods","dstMethods","d","method","push","extractMethods","augmentObject","fromEmpty","sections","i","methods","m"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api/util/augmentObject.js"],"sourcesContent":["import { lazyMethods, logger, objectClear } from '@polkadot/util';\nconst l = logger('api/augment');\nfunction logLength(type, values, and = []) {\n    return values.length\n        ? ` ${values.length} ${type}${and.length ? ' and' : ''}`\n        : '';\n}\nfunction logValues(type, values) {\n    return values.length\n        ? `\\n\\t${type.padStart(7)}: ${values.sort().join(', ')}`\n        : '';\n}\nfunction warn(prefix, type, [added, removed]) {\n    if (added.length || removed.length) {\n        l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);\n    }\n}\nfunction findSectionExcludes(a, b) {\n    return a.filter((s) => !b.includes(s));\n}\nfunction findSectionIncludes(a, b) {\n    return a.filter((s) => b.includes(s));\n}\nfunction extractSections(src, dst) {\n    const srcSections = Object.keys(src);\n    const dstSections = Object.keys(dst);\n    return [\n        findSectionExcludes(srcSections, dstSections),\n        findSectionExcludes(dstSections, srcSections)\n    ];\n}\nfunction findMethodExcludes(src, dst) {\n    const srcSections = Object.keys(src);\n    const dstSections = findSectionIncludes(Object.keys(dst), srcSections);\n    const excludes = [];\n    for (let s = 0; s < dstSections.length; s++) {\n        const section = dstSections[s];\n        const srcMethods = Object.keys(src[section]);\n        const dstMethods = Object.keys(dst[section]);\n        for (let d = 0; d < dstMethods.length; d++) {\n            const method = dstMethods[d];\n            if (!srcMethods.includes(method)) {\n                excludes.push(`${section}.${method}`);\n            }\n        }\n    }\n    return excludes;\n}\nfunction extractMethods(src, dst) {\n    return [\n        findMethodExcludes(dst, src),\n        findMethodExcludes(src, dst)\n    ];\n}\n/**\n * @description Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing items into the result object.\n * @internal\n */\nexport function augmentObject(prefix, src, dst, fromEmpty = false) {\n    fromEmpty && objectClear(dst);\n    // NOTE: This part is slightly problematic since it will get the\n    // values for at least all the sections and the names of the methods\n    // (Since methods won't be decorated before lazy, this _may_ be ok)\n    if (prefix && Object.keys(dst).length) {\n        warn(prefix, 'modules', extractSections(src, dst));\n        warn(prefix, 'calls', extractMethods(src, dst));\n    }\n    const sections = Object.keys(src);\n    for (let i = 0; i < sections.length; i++) {\n        const section = sections[i];\n        const methods = src[section];\n        // We don't set here with a lazy interface, we decorate based\n        // on the top-level structure (this bypasses adding lazy onto lazy)\n        if (!dst[section]) {\n            dst[section] = {};\n        }\n        lazyMethods(dst[section], Object.keys(methods), (m) => methods[m]);\n    }\n    return dst;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}