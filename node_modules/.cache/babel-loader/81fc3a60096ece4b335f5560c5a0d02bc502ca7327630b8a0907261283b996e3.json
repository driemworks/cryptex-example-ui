{"ast":null,"code":"import { sanitize } from '@polkadot/types-codec';\nimport { isNumber, isString, objectSpread } from '@polkadot/util';\nimport { TypeDefInfo } from '../types/index.js';\nimport { typeSplit } from './typeSplit.js';\nconst KNOWN_INTERNALS = ['_alias', '_fallback'];\nfunction getTypeString(typeOrObj) {\n  return isString(typeOrObj) ? typeOrObj.toString() : JSON.stringify(typeOrObj);\n}\nfunction isRustEnum(details) {\n  const values = Object.values(details);\n  if (values.some(v => isNumber(v))) {\n    if (!values.every(v => isNumber(v) && v >= 0 && v <= 255)) {\n      throw new Error('Invalid number-indexed enum definition');\n    }\n    return false;\n  }\n  return true;\n}\nfunction _decodeEnum(value, details, count, fallbackType) {\n  value.info = TypeDefInfo.Enum;\n  value.fallbackType = fallbackType;\n  // not as pretty, but remain compatible with oo7 for both struct and Array types\n  if (Array.isArray(details)) {\n    value.sub = details.map((name, index) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  } else if (isRustEnum(details)) {\n    value.sub = Object.entries(details).map((_ref, index) => {\n      let [name, typeOrObj] = _ref;\n      return objectSpread({}, getTypeDef(getTypeString(typeOrObj || 'Null'), {\n        name\n      }, count), {\n        index\n      });\n    });\n  } else {\n    value.sub = Object.entries(details).map(_ref2 => {\n      let [name, index] = _ref2;\n      return {\n        index,\n        info: TypeDefInfo.Plain,\n        name,\n        type: 'Null'\n      };\n    });\n  }\n  return value;\n}\nfunction _decodeSet(value, details, fallbackType) {\n  value.info = TypeDefInfo.Set;\n  value.fallbackType = fallbackType;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(_ref3 => {\n    let [name] = _ref3;\n    return !name.startsWith('_');\n  }).map(_ref4 => {\n    let [name, index] = _ref4;\n    return {\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    };\n  });\n  return value;\n}\nfunction _decodeStruct(value, type, _, count) {\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n  if (keys.includes('_enum')) {\n    return _decodeEnum(value, parsed._enum, count, parsed._fallback);\n  } else if (keys.includes('_set')) {\n    return _decodeSet(value, parsed._set, parsed._fallback);\n  }\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.fallbackType = parsed._fallback;\n  value.sub = keys.filter(name => !KNOWN_INTERNALS.includes(name)).map(name => getTypeDef(getTypeString(parsed[name]), {\n    name\n  }, count));\n  return value;\n}\nfunction _decodeFixedVec(value, type, _, count) {\n  const max = type.length - 1;\n  let index = -1;\n  let inner = 0;\n  for (let i = 1; i < max && index === -1; i++) {\n    switch (type[i]) {\n      case ';':\n        {\n          if (inner === 0) {\n            index = i;\n          }\n          break;\n        }\n      case '[':\n      case '(':\n      case '<':\n        inner++;\n        break;\n      case ']':\n      case ')':\n      case '>':\n        inner--;\n        break;\n    }\n  }\n  if (index === -1) {\n    throw new Error(`${type}: Unable to extract location of ';'`);\n  }\n  const vecType = type.substring(1, index);\n  const [strLength, displayName] = type.substring(index + 1, max).split(';');\n  const length = parseInt(strLength.trim(), 10);\n  if (length > 2048) {\n    throw new Error(`${type}: Only support for [Type; <length>], where length <= 2048`);\n  }\n  value.displayName = displayName;\n  value.length = length;\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n}\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n}\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substring(clazz.length + 1, type.length - 1).split(',');\n  const length = parseInt(strLength.trim(), 10);\n  if (length > 8192 || length % 8) {\n    throw new Error(`${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  }\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n}\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substring(NAME_LENGTH + 1, type.length - 1);\n  return value;\n}\nfunction hasWrapper(type, _ref5) {\n  let [start, end] = _ref5;\n  return type.substring(0, start.length) === start && type.slice(-1 * end.length) === end;\n}\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple],\n// the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Opaque<', '>', TypeDefInfo.WrapperOpaque], ['Option<', '>', TypeDefInfo.Option], ['Range<', '>', TypeDefInfo.Range], ['RangeInclusive<', '>', TypeDefInfo.RangeInclusive], ['Vec<', '>', TypeDefInfo.Vec], ['WrapperKeepOpaque<', '>', TypeDefInfo.WrapperKeepOpaque], ['WrapperOpaque<', '>', TypeDefInfo.WrapperOpaque]];\nfunction extractSubType(type, _ref6) {\n  let [start, end] = _ref6;\n  return type.substring(start.length, type.length - end.length);\n}\nexport function getTypeDef(_type) {\n  let {\n    displayName,\n    name\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  if (++count > 64) {\n    throw new Error('getTypeDef: Maximum nested limit reached');\n  }\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n  return value;\n}","map":{"version":3,"names":["sanitize","isNumber","isString","objectSpread","TypeDefInfo","typeSplit","KNOWN_INTERNALS","getTypeString","typeOrObj","toString","JSON","stringify","isRustEnum","details","values","Object","some","v","every","Error","_decodeEnum","value","count","fallbackType","info","Enum","Array","isArray","sub","map","name","index","Plain","type","entries","_ref","getTypeDef","_ref2","_decodeSet","Set","length","_bitLength","filter","_ref3","startsWith","_ref4","_decodeStruct","_","parsed","parse","keys","includes","_enum","_fallback","_set","alias","_alias","Map","undefined","_decodeFixedVec","max","inner","i","vecType","substring","strLength","displayName","split","parseInt","trim","_decodeTuple","subType","_decodeAnyInt","clazz","_decodeInt","_decodeUInt","_decodeDoNotConstruct","NAME_LENGTH","hasWrapper","_ref5","start","end","slice","nestedExtraction","VecFixed","Struct","Tuple","BTreeMap","HashMap","Int","Result","UInt","DoNotConstruct","wrappedExtraction","BTreeSet","Compact","Linkage","WrapperOpaque","Option","Range","RangeInclusive","Vec","WrapperKeepOpaque","extractSubType","_ref6","_type","arguments","nested","find","wrapped"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-create/util/getTypeDef.js"],"sourcesContent":["import { sanitize } from '@polkadot/types-codec';\nimport { isNumber, isString, objectSpread } from '@polkadot/util';\nimport { TypeDefInfo } from '../types/index.js';\nimport { typeSplit } from './typeSplit.js';\nconst KNOWN_INTERNALS = ['_alias', '_fallback'];\nfunction getTypeString(typeOrObj) {\n    return isString(typeOrObj)\n        ? typeOrObj.toString()\n        : JSON.stringify(typeOrObj);\n}\nfunction isRustEnum(details) {\n    const values = Object.values(details);\n    if (values.some((v) => isNumber(v))) {\n        if (!values.every((v) => isNumber(v) && v >= 0 && v <= 255)) {\n            throw new Error('Invalid number-indexed enum definition');\n        }\n        return false;\n    }\n    return true;\n}\nfunction _decodeEnum(value, details, count, fallbackType) {\n    value.info = TypeDefInfo.Enum;\n    value.fallbackType = fallbackType;\n    // not as pretty, but remain compatible with oo7 for both struct and Array types\n    if (Array.isArray(details)) {\n        value.sub = details.map((name, index) => ({\n            index,\n            info: TypeDefInfo.Plain,\n            name,\n            type: 'Null'\n        }));\n    }\n    else if (isRustEnum(details)) {\n        value.sub = Object.entries(details).map(([name, typeOrObj], index) => objectSpread({}, getTypeDef(getTypeString(typeOrObj || 'Null'), { name }, count), { index }));\n    }\n    else {\n        value.sub = Object.entries(details).map(([name, index]) => ({\n            index,\n            info: TypeDefInfo.Plain,\n            name,\n            type: 'Null'\n        }));\n    }\n    return value;\n}\nfunction _decodeSet(value, details, fallbackType) {\n    value.info = TypeDefInfo.Set;\n    value.fallbackType = fallbackType;\n    value.length = details._bitLength;\n    value.sub = Object\n        .entries(details)\n        .filter(([name]) => !name.startsWith('_'))\n        .map(([name, index]) => ({\n        index,\n        info: TypeDefInfo.Plain,\n        name,\n        type: 'Null'\n    }));\n    return value;\n}\nfunction _decodeStruct(value, type, _, count) {\n    const parsed = JSON.parse(type);\n    const keys = Object.keys(parsed);\n    if (keys.includes('_enum')) {\n        return _decodeEnum(value, parsed._enum, count, parsed._fallback);\n    }\n    else if (keys.includes('_set')) {\n        return _decodeSet(value, parsed._set, parsed._fallback);\n    }\n    value.alias = parsed._alias\n        ? new Map(Object.entries(parsed._alias))\n        : undefined;\n    value.fallbackType = parsed._fallback;\n    value.sub = keys\n        .filter((name) => !KNOWN_INTERNALS.includes(name))\n        .map((name) => getTypeDef(getTypeString(parsed[name]), { name }, count));\n    return value;\n}\nfunction _decodeFixedVec(value, type, _, count) {\n    const max = type.length - 1;\n    let index = -1;\n    let inner = 0;\n    for (let i = 1; (i < max) && (index === -1); i++) {\n        switch (type[i]) {\n            case ';': {\n                if (inner === 0) {\n                    index = i;\n                }\n                break;\n            }\n            case '[':\n            case '(':\n            case '<':\n                inner++;\n                break;\n            case ']':\n            case ')':\n            case '>':\n                inner--;\n                break;\n        }\n    }\n    if (index === -1) {\n        throw new Error(`${type}: Unable to extract location of ';'`);\n    }\n    const vecType = type.substring(1, index);\n    const [strLength, displayName] = type.substring(index + 1, max).split(';');\n    const length = parseInt(strLength.trim(), 10);\n    if (length > 2048) {\n        throw new Error(`${type}: Only support for [Type; <length>], where length <= 2048`);\n    }\n    value.displayName = displayName;\n    value.length = length;\n    value.sub = getTypeDef(vecType, {}, count);\n    return value;\n}\nfunction _decodeTuple(value, _, subType, count) {\n    value.sub = subType.length === 0\n        ? []\n        : typeSplit(subType).map((inner) => getTypeDef(inner, {}, count));\n    return value;\n}\nfunction _decodeAnyInt(value, type, _, clazz) {\n    const [strLength, displayName] = type.substring(clazz.length + 1, type.length - 1).split(',');\n    const length = parseInt(strLength.trim(), 10);\n    if ((length > 8192) || (length % 8)) {\n        throw new Error(`${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n    }\n    value.displayName = displayName;\n    value.length = length;\n    return value;\n}\nfunction _decodeInt(value, type, subType) {\n    return _decodeAnyInt(value, type, subType, 'Int');\n}\nfunction _decodeUInt(value, type, subType) {\n    return _decodeAnyInt(value, type, subType, 'UInt');\n}\nfunction _decodeDoNotConstruct(value, type, _) {\n    const NAME_LENGTH = 'DoNotConstruct'.length;\n    value.displayName = type.substring(NAME_LENGTH + 1, type.length - 1);\n    return value;\n}\nfunction hasWrapper(type, [start, end]) {\n    return (type.substring(0, start.length) === start) && (type.slice(-1 * end.length) === end);\n}\nconst nestedExtraction = [\n    ['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec],\n    ['{', '}', TypeDefInfo.Struct, _decodeStruct],\n    ['(', ')', TypeDefInfo.Tuple, _decodeTuple],\n    // the inner for these are the same as tuple, multiple values\n    ['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple],\n    ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple],\n    ['Int<', '>', TypeDefInfo.Int, _decodeInt],\n    ['Result<', '>', TypeDefInfo.Result, _decodeTuple],\n    ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt],\n    ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]\n];\nconst wrappedExtraction = [\n    ['BTreeSet<', '>', TypeDefInfo.BTreeSet],\n    ['Compact<', '>', TypeDefInfo.Compact],\n    ['Linkage<', '>', TypeDefInfo.Linkage],\n    ['Opaque<', '>', TypeDefInfo.WrapperOpaque],\n    ['Option<', '>', TypeDefInfo.Option],\n    ['Range<', '>', TypeDefInfo.Range],\n    ['RangeInclusive<', '>', TypeDefInfo.RangeInclusive],\n    ['Vec<', '>', TypeDefInfo.Vec],\n    ['WrapperKeepOpaque<', '>', TypeDefInfo.WrapperKeepOpaque],\n    ['WrapperOpaque<', '>', TypeDefInfo.WrapperOpaque]\n];\nfunction extractSubType(type, [start, end]) {\n    return type.substring(start.length, type.length - end.length);\n}\nexport function getTypeDef(_type, { displayName, name } = {}, count = 0) {\n    // create the type via Type, allowing types to be sanitized\n    const type = sanitize(_type);\n    const value = { displayName, info: TypeDefInfo.Plain, name, type };\n    if (++count > 64) {\n        throw new Error('getTypeDef: Maximum nested limit reached');\n    }\n    const nested = nestedExtraction.find((nested) => hasWrapper(type, nested));\n    if (nested) {\n        value.info = nested[2];\n        return nested[3](value, type, extractSubType(type, nested), count);\n    }\n    const wrapped = wrappedExtraction.find((wrapped) => hasWrapper(type, wrapped));\n    if (wrapped) {\n        value.info = wrapped[2];\n        value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n    }\n    return value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}