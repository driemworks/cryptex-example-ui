{"ast":null,"code":"var _Vec_Type;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8aLim, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\nfunction noopSetDefinition(d) {\n  return d;\n}\nfunction decodeVecLength(value) {\n  if (Array.isArray(value)) {\n    return [value, value.length, 0];\n  } else if (isU8a(value) || isHex(value)) {\n    const u8a = u8aToU8a(value);\n    const [startAt, length] = compactFromU8aLim(u8a);\n    if (length > MAX_LENGTH) {\n      throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    }\n    return [u8a, length, startAt];\n  } else if (!value) {\n    return [null, 0, 0];\n  }\n  throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n  if (Array.isArray(value)) {\n    const count = result.length;\n    for (let i = 0; i < count; i++) {\n      // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const entry = value[i];\n      try {\n        result[i] = entry instanceof Type ? entry : new Type(registry, entry);\n      } catch (error) {\n        l.error(`Unable to decode on index ${i}`, error.message);\n        throw error;\n      }\n    }\n    return [0, 0];\n  } else if (!value) {\n    return [0, 0];\n  }\n  // we don't need more checks, we already limited it via the length decoding\n  return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n  constructor(registry, Type) {\n    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let {\n      definition,\n      setDefinition = noopSetDefinition\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const [decodeFrom, length, startAt] = decodeVecLength(value);\n    super(registry, length);\n    _Vec_Type.set(this, void 0);\n    __classPrivateFieldSet(this, _Vec_Type, definition || setDefinition(typeToConstructor(registry, Type)), \"f\");\n    this.initialU8aLength = (isU8a(decodeFrom) ? decodeU8aVec(registry, this, decodeFrom, startAt, __classPrivateFieldGet(this, _Vec_Type, \"f\")) : decodeVec(registry, this, decodeFrom, startAt, __classPrivateFieldGet(this, _Vec_Type, \"f\")))[0];\n  }\n  static with(Type) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n  get Type() {\n    return __classPrivateFieldGet(this, _Vec_Type, \"f\").name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n  indexOf(other) {\n    // convert type first, this removes overhead from the eq\n    const check = other instanceof __classPrivateFieldGet(this, _Vec_Type, \"f\") ? other : new (__classPrivateFieldGet(this, _Vec_Type, \"f\"))(this.registry, other);\n    for (let i = 0; i < this.length; i++) {\n      if (check.eq(this[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `Vec<${this.registry.getClassName(__classPrivateFieldGet(this, _Vec_Type, \"f\")) || new (__classPrivateFieldGet(this, _Vec_Type, \"f\"))(this.registry).toRawType()}>`;\n  }\n}\n_Vec_Type = new WeakMap();","map":{"version":3,"names":["_Vec_Type","__classPrivateFieldGet","__classPrivateFieldSet","compactFromU8aLim","isHex","isU8a","logger","stringify","u8aToU8a","AbstractArray","decodeU8aVec","typeToConstructor","MAX_LENGTH","l","noopSetDefinition","d","decodeVecLength","value","Array","isArray","length","u8a","startAt","Error","toString","decodeVec","registry","result","Type","count","i","entry","error","message","Vec","constructor","arguments","undefined","definition","setDefinition","decodeFrom","set","initialU8aLength","with","name","indexOf","other","check","eq","toRawType","getClassName","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/base/Vec.js"],"sourcesContent":["var _Vec_Type;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8aLim, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 64 * 1024;\nconst l = logger('Vec');\nfunction noopSetDefinition(d) {\n    return d;\n}\nfunction decodeVecLength(value) {\n    if (Array.isArray(value)) {\n        return [value, value.length, 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        const u8a = u8aToU8a(value);\n        const [startAt, length] = compactFromU8aLim(u8a);\n        if (length > MAX_LENGTH) {\n            throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n        }\n        return [u8a, length, startAt];\n    }\n    else if (!value) {\n        return [null, 0, 0];\n    }\n    throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n    if (Array.isArray(value)) {\n        const count = result.length;\n        for (let i = 0; i < count; i++) {\n            // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const entry = value[i];\n            try {\n                result[i] = entry instanceof Type\n                    ? entry\n                    : new Type(registry, entry);\n            }\n            catch (error) {\n                l.error(`Unable to decode on index ${i}`, error.message);\n                throw error;\n            }\n        }\n        return [0, 0];\n    }\n    else if (!value) {\n        return [0, 0];\n    }\n    // we don't need more checks, we already limited it via the length decoding\n    return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n    constructor(registry, Type, value = [], { definition, setDefinition = noopSetDefinition } = {}) {\n        const [decodeFrom, length, startAt] = decodeVecLength(value);\n        super(registry, length);\n        _Vec_Type.set(this, void 0);\n        __classPrivateFieldSet(this, _Vec_Type, definition || setDefinition(typeToConstructor(registry, Type)), \"f\");\n        this.initialU8aLength = (isU8a(decodeFrom)\n            ? decodeU8aVec(registry, this, decodeFrom, startAt, __classPrivateFieldGet(this, _Vec_Type, \"f\"))\n            : decodeVec(registry, this, decodeFrom, startAt, __classPrivateFieldGet(this, _Vec_Type, \"f\")))[0];\n    }\n    static with(Type) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends Vec {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The type for the items\n     */\n    get Type() {\n        return __classPrivateFieldGet(this, _Vec_Type, \"f\").name;\n    }\n    /**\n     * @description Finds the index of the value in the array\n     */\n    indexOf(other) {\n        // convert type first, this removes overhead from the eq\n        const check = other instanceof __classPrivateFieldGet(this, _Vec_Type, \"f\")\n            ? other\n            : new (__classPrivateFieldGet(this, _Vec_Type, \"f\"))(this.registry, other);\n        for (let i = 0; i < this.length; i++) {\n            if (check.eq(this[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `Vec<${this.registry.getClassName(__classPrivateFieldGet(this, _Vec_Type, \"f\")) || new (__classPrivateFieldGet(this, _Vec_Type, \"f\"))(this.registry).toRawType()}>`;\n    }\n}\n_Vec_Type = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}