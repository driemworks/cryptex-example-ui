{"ast":null,"code":"var _GenericExtrinsicSignatureV4_signKeys;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Struct } from '@polkadot/types-codec';\nimport { isU8a, isUndefined, objectProperties, objectSpread, stringify, u8aToHex } from '@polkadot/util';\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants.js';\nimport { GenericExtrinsicPayloadV4 } from './ExtrinsicPayload.js';\nconst FAKE_SIGNATURE = new Uint8Array(256).fill(1);\nfunction toAddress(registry, address) {\n  return registry.createTypeUnsafe('Address', [isU8a(address) ? u8aToHex(address) : address]);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\nexport class GenericExtrinsicSignatureV4 extends Struct {\n  constructor(registry, value) {\n    let {\n      isSigned\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const signTypes = registry.getSignedExtensionTypes();\n    super(registry, objectSpread(\n    // eslint-disable-next-line sort-keys\n    {\n      signer: 'Address',\n      signature: 'ExtrinsicSignature'\n    }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n    _GenericExtrinsicSignatureV4_signKeys.set(this, void 0);\n    __classPrivateFieldSet(this, _GenericExtrinsicSignatureV4_signKeys, Object.keys(signTypes), \"f\");\n    objectProperties(this, __classPrivateFieldGet(this, _GenericExtrinsicSignatureV4_signKeys, \"f\"), k => this.get(k));\n  }\n  /** @internal */\n  static decodeExtrinsicSignature(value) {\n    let isSigned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!value) {\n      return EMPTY_U8A;\n    } else if (value instanceof GenericExtrinsicSignatureV4) {\n      return value;\n    }\n    return isSigned ? value : EMPTY_U8A;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.isSigned ? super.encodedLength : 0;\n  }\n  /**\n   * @description `true` if the signature is valid\n   */\n  get isSigned() {\n    return !this.signature.isEmpty;\n  }\n  /**\n   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n   */\n  get era() {\n    return this.getT('era');\n  }\n  /**\n   * @description The [[Index]] for the signature\n   */\n  get nonce() {\n    return this.getT('nonce');\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n  get signature() {\n    // the second case here is when we don't have an enum signature, treat as raw\n    return this.multiSignature.value || this.multiSignature;\n  }\n  /**\n   * @description The raw [[ExtrinsicSignature]]\n   */\n  get multiSignature() {\n    return this.getT('signature');\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n  get signer() {\n    return this.getT('signer');\n  }\n  /**\n   * @description The [[Balance]] tip\n   */\n  get tip() {\n    return this.getT('tip');\n  }\n  _injectSignature(signer, signature, payload) {\n    // use the fields exposed to guide the getters\n    for (let i = 0; i < __classPrivateFieldGet(this, _GenericExtrinsicSignatureV4_signKeys, \"f\").length; i++) {\n      const k = __classPrivateFieldGet(this, _GenericExtrinsicSignatureV4_signKeys, \"f\")[i];\n      const v = payload.get(k);\n      if (!isUndefined(v)) {\n        this.set(k, v);\n      }\n    }\n    // additional fields (exposed in struct itself)\n    this.set('signer', signer);\n    this.set('signature', signature);\n    return this;\n  }\n  /**\n   * @description Adds a raw signature\n   */\n  addSignature(signer, signature, payload) {\n    return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe('ExtrinsicSignature', [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));\n  }\n  /**\n   * @description Creates a payload from the supplied options\n   */\n  createPayload(method, options) {\n    const {\n      era,\n      runtimeVersion: {\n        specVersion,\n        transactionVersion\n      }\n    } = options;\n    return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {\n      era: era || IMMORTAL_ERA,\n      method: method.toHex(),\n      specVersion,\n      transactionVersion\n    }));\n  }\n  /**\n   * @description Generate a payload and applies the signature from a keypair\n   */\n  sign(method, account, options) {\n    if (!account || !account.addressRaw) {\n      throw new Error(`Expected a valid keypair for signing, found ${stringify(account)}`);\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe('ExtrinsicSignature', [payload.sign(account)]), payload);\n  }\n  /**\n   * @description Generate a payload and applies a fake signature\n   */\n  signFake(method, address, options) {\n    if (!address) {\n      throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe('ExtrinsicSignature', [FAKE_SIGNATURE]), payload);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A;\n  }\n}\n_GenericExtrinsicSignatureV4_signKeys = new WeakMap();","map":{"version":3,"names":["_GenericExtrinsicSignatureV4_signKeys","__classPrivateFieldGet","__classPrivateFieldSet","Struct","isU8a","isUndefined","objectProperties","objectSpread","stringify","u8aToHex","EMPTY_U8A","IMMORTAL_ERA","GenericExtrinsicPayloadV4","FAKE_SIGNATURE","Uint8Array","fill","toAddress","registry","address","createTypeUnsafe","GenericExtrinsicSignatureV4","constructor","value","isSigned","arguments","length","undefined","signTypes","getSignedExtensionTypes","signer","signature","decodeExtrinsicSignature","set","Object","keys","k","get","encodedLength","isEmpty","era","getT","nonce","multiSignature","tip","_injectSignature","payload","i","v","addSignature","createPayload","method","options","runtimeVersion","specVersion","transactionVersion","toHex","sign","account","addressRaw","Error","signFake","toU8a","isBare","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js"],"sourcesContent":["var _GenericExtrinsicSignatureV4_signKeys;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Struct } from '@polkadot/types-codec';\nimport { isU8a, isUndefined, objectProperties, objectSpread, stringify, u8aToHex } from '@polkadot/util';\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants.js';\nimport { GenericExtrinsicPayloadV4 } from './ExtrinsicPayload.js';\nconst FAKE_SIGNATURE = new Uint8Array(256).fill(1);\nfunction toAddress(registry, address) {\n    return registry.createTypeUnsafe('Address', [isU8a(address) ? u8aToHex(address) : address]);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\nexport class GenericExtrinsicSignatureV4 extends Struct {\n    constructor(registry, value, { isSigned } = {}) {\n        const signTypes = registry.getSignedExtensionTypes();\n        super(registry, objectSpread(\n        // eslint-disable-next-line sort-keys\n        { signer: 'Address', signature: 'ExtrinsicSignature' }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n        _GenericExtrinsicSignatureV4_signKeys.set(this, void 0);\n        __classPrivateFieldSet(this, _GenericExtrinsicSignatureV4_signKeys, Object.keys(signTypes), \"f\");\n        objectProperties(this, __classPrivateFieldGet(this, _GenericExtrinsicSignatureV4_signKeys, \"f\"), (k) => this.get(k));\n    }\n    /** @internal */\n    static decodeExtrinsicSignature(value, isSigned = false) {\n        if (!value) {\n            return EMPTY_U8A;\n        }\n        else if (value instanceof GenericExtrinsicSignatureV4) {\n            return value;\n        }\n        return isSigned\n            ? value\n            : EMPTY_U8A;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.isSigned\n            ? super.encodedLength\n            : 0;\n    }\n    /**\n     * @description `true` if the signature is valid\n     */\n    get isSigned() {\n        return !this.signature.isEmpty;\n    }\n    /**\n     * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n     */\n    get era() {\n        return this.getT('era');\n    }\n    /**\n     * @description The [[Index]] for the signature\n     */\n    get nonce() {\n        return this.getT('nonce');\n    }\n    /**\n     * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n     */\n    get signature() {\n        // the second case here is when we don't have an enum signature, treat as raw\n        return (this.multiSignature.value || this.multiSignature);\n    }\n    /**\n     * @description The raw [[ExtrinsicSignature]]\n     */\n    get multiSignature() {\n        return this.getT('signature');\n    }\n    /**\n     * @description The [[Address]] that signed\n     */\n    get signer() {\n        return this.getT('signer');\n    }\n    /**\n     * @description The [[Balance]] tip\n     */\n    get tip() {\n        return this.getT('tip');\n    }\n    _injectSignature(signer, signature, payload) {\n        // use the fields exposed to guide the getters\n        for (let i = 0; i < __classPrivateFieldGet(this, _GenericExtrinsicSignatureV4_signKeys, \"f\").length; i++) {\n            const k = __classPrivateFieldGet(this, _GenericExtrinsicSignatureV4_signKeys, \"f\")[i];\n            const v = payload.get(k);\n            if (!isUndefined(v)) {\n                this.set(k, v);\n            }\n        }\n        // additional fields (exposed in struct itself)\n        this.set('signer', signer);\n        this.set('signature', signature);\n        return this;\n    }\n    /**\n     * @description Adds a raw signature\n     */\n    addSignature(signer, signature, payload) {\n        return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe('ExtrinsicSignature', [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));\n    }\n    /**\n     * @description Creates a payload from the supplied options\n     */\n    createPayload(method, options) {\n        const { era, runtimeVersion: { specVersion, transactionVersion } } = options;\n        return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {\n            era: era || IMMORTAL_ERA,\n            method: method.toHex(),\n            specVersion,\n            transactionVersion\n        }));\n    }\n    /**\n     * @description Generate a payload and applies the signature from a keypair\n     */\n    sign(method, account, options) {\n        if (!account || !account.addressRaw) {\n            throw new Error(`Expected a valid keypair for signing, found ${stringify(account)}`);\n        }\n        const payload = this.createPayload(method, options);\n        return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe('ExtrinsicSignature', [payload.sign(account)]), payload);\n    }\n    /**\n     * @description Generate a payload and applies a fake signature\n     */\n    signFake(method, address, options) {\n        if (!address) {\n            throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);\n        }\n        const payload = this.createPayload(method, options);\n        return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe('ExtrinsicSignature', [FAKE_SIGNATURE]), payload);\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return this.isSigned\n            ? super.toU8a(isBare)\n            : EMPTY_U8A;\n    }\n}\n_GenericExtrinsicSignatureV4_signKeys = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}