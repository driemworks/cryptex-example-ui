{"ast":null,"code":"const MMR_V2 = {\n  generate_proof: {\n    description: 'Generate MMR proof for the given block numbers.',\n    params: [{\n      name: 'blockNumbers',\n      type: 'Vec<BlockNumber>'\n    }, {\n      name: 'bestKnownBlockNumber',\n      type: 'Option<BlockNumber>'\n    }],\n    type: 'Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>'\n  },\n  root: {\n    description: 'Return the on-chain MMR root hash.',\n    params: [],\n    type: 'Result<Hash, MmrError>'\n  },\n  verify_proof: {\n    description: 'Verify MMR proof against on-chain MMR.',\n    params: [{\n      name: 'leaves',\n      type: 'Vec<MmrEncodableOpaqueLeaf>'\n    }, {\n      name: 'proof',\n      type: 'MmrBatchProof'\n    }],\n    type: 'Result<(), MmrError>'\n  },\n  verify_proof_stateless: {\n    description: 'Verify MMR proof against given root hash.',\n    params: [{\n      name: 'root',\n      type: 'Hash'\n    }, {\n      name: 'leaves',\n      type: 'Vec<MmrEncodableOpaqueLeaf>'\n    }, {\n      name: 'proof',\n      type: 'MmrBatchProof'\n    }],\n    type: 'Result<(), MmrError>'\n  }\n};\nconst MMR_V1 = {\n  generate_batch_proof: {\n    description: 'Generate MMR proof for a series of leaves under given indices.',\n    params: [{\n      name: 'leafIndices',\n      type: 'Vec<MmrLeafIndex>'\n    }],\n    type: 'Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>'\n  },\n  generate_proof: {\n    description: 'Generate MMR proof for a leaf under given index.',\n    params: [{\n      name: 'leafIndex',\n      type: 'MmrLeafIndex'\n    }],\n    type: 'Result<(MmrEncodableOpaqueLeaf, MmrProof), MmrError>'\n  },\n  mmr_root: {\n    description: 'Return the on-chain MMR root hash.',\n    params: [],\n    type: 'Result<Hash, MmrError>'\n  },\n  verify_batch_proof: {\n    description: 'Verify MMR proof against on-chain MMR for a batch of leaves.',\n    params: [{\n      name: 'leaves',\n      type: 'Vec<MmrEncodableOpaqueLeaf>'\n    }, {\n      name: 'proof',\n      type: 'MmrBatchProof'\n    }],\n    type: 'Result<(), MmrError>'\n  },\n  verify_batch_proof_stateless: {\n    description: 'Verify MMR proof against given root hash or a batch of leaves.',\n    params: [{\n      name: 'root',\n      type: 'Hash'\n    }, {\n      name: 'leaves',\n      type: 'Vec<MmrEncodableOpaqueLeaf>'\n    }, {\n      name: 'proof',\n      type: 'MmrBatchProof'\n    }],\n    type: 'Result<(), MmrError>'\n  },\n  verify_proof: {\n    description: 'Verify MMR proof against on-chain MMR.',\n    params: [{\n      name: 'leaf',\n      type: 'MmrEncodableOpaqueLeaf'\n    }, {\n      name: 'proof',\n      type: 'MmrProof'\n    }],\n    type: 'Result<(), MmrError>'\n  },\n  verify_proof_stateless: {\n    description: 'Verify MMR proof against given root hash.',\n    params: [{\n      name: 'root',\n      type: 'Hash'\n    }, {\n      name: 'leaf',\n      type: 'MmrEncodableOpaqueLeaf'\n    }, {\n      name: 'proof',\n      type: 'MmrProof'\n    }],\n    type: 'Result<(), MmrError>'\n  }\n};\nexport const runtime = {\n  MmrApi: [{\n    methods: MMR_V2,\n    version: 2\n  }, {\n    methods: MMR_V1,\n    version: 1\n  }]\n};","map":{"version":3,"names":["MMR_V2","generate_proof","description","params","name","type","root","verify_proof","verify_proof_stateless","MMR_V1","generate_batch_proof","mmr_root","verify_batch_proof","verify_batch_proof_stateless","runtime","MmrApi","methods","version"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/interfaces/mmr/runtime.js"],"sourcesContent":["const MMR_V2 = {\n    generate_proof: {\n        description: 'Generate MMR proof for the given block numbers.',\n        params: [\n            {\n                name: 'blockNumbers',\n                type: 'Vec<BlockNumber>'\n            },\n            {\n                name: 'bestKnownBlockNumber',\n                type: 'Option<BlockNumber>'\n            }\n        ],\n        type: 'Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>'\n    },\n    root: {\n        description: 'Return the on-chain MMR root hash.',\n        params: [],\n        type: 'Result<Hash, MmrError>'\n    },\n    verify_proof: {\n        description: 'Verify MMR proof against on-chain MMR.',\n        params: [\n            {\n                name: 'leaves',\n                type: 'Vec<MmrEncodableOpaqueLeaf>'\n            },\n            {\n                name: 'proof',\n                type: 'MmrBatchProof'\n            }\n        ],\n        type: 'Result<(), MmrError>'\n    },\n    verify_proof_stateless: {\n        description: 'Verify MMR proof against given root hash.',\n        params: [\n            {\n                name: 'root',\n                type: 'Hash'\n            },\n            {\n                name: 'leaves',\n                type: 'Vec<MmrEncodableOpaqueLeaf>'\n            },\n            {\n                name: 'proof',\n                type: 'MmrBatchProof'\n            }\n        ],\n        type: 'Result<(), MmrError>'\n    }\n};\nconst MMR_V1 = {\n    generate_batch_proof: {\n        description: 'Generate MMR proof for a series of leaves under given indices.',\n        params: [\n            {\n                name: 'leafIndices',\n                type: 'Vec<MmrLeafIndex>'\n            }\n        ],\n        type: 'Result<(Vec<MmrEncodableOpaqueLeaf>, MmrBatchProof), MmrError>'\n    },\n    generate_proof: {\n        description: 'Generate MMR proof for a leaf under given index.',\n        params: [\n            {\n                name: 'leafIndex',\n                type: 'MmrLeafIndex'\n            }\n        ],\n        type: 'Result<(MmrEncodableOpaqueLeaf, MmrProof), MmrError>'\n    },\n    mmr_root: {\n        description: 'Return the on-chain MMR root hash.',\n        params: [],\n        type: 'Result<Hash, MmrError>'\n    },\n    verify_batch_proof: {\n        description: 'Verify MMR proof against on-chain MMR for a batch of leaves.',\n        params: [\n            {\n                name: 'leaves',\n                type: 'Vec<MmrEncodableOpaqueLeaf>'\n            },\n            {\n                name: 'proof',\n                type: 'MmrBatchProof'\n            }\n        ],\n        type: 'Result<(), MmrError>'\n    },\n    verify_batch_proof_stateless: {\n        description: 'Verify MMR proof against given root hash or a batch of leaves.',\n        params: [\n            {\n                name: 'root',\n                type: 'Hash'\n            },\n            {\n                name: 'leaves',\n                type: 'Vec<MmrEncodableOpaqueLeaf>'\n            },\n            {\n                name: 'proof',\n                type: 'MmrBatchProof'\n            }\n        ],\n        type: 'Result<(), MmrError>'\n    },\n    verify_proof: {\n        description: 'Verify MMR proof against on-chain MMR.',\n        params: [\n            {\n                name: 'leaf',\n                type: 'MmrEncodableOpaqueLeaf'\n            },\n            {\n                name: 'proof',\n                type: 'MmrProof'\n            }\n        ],\n        type: 'Result<(), MmrError>'\n    },\n    verify_proof_stateless: {\n        description: 'Verify MMR proof against given root hash.',\n        params: [\n            {\n                name: 'root',\n                type: 'Hash'\n            },\n            {\n                name: 'leaf',\n                type: 'MmrEncodableOpaqueLeaf'\n            },\n            {\n                name: 'proof',\n                type: 'MmrProof'\n            }\n        ],\n        type: 'Result<(), MmrError>'\n    }\n};\nexport const runtime = {\n    MmrApi: [\n        {\n            methods: MMR_V2,\n            version: 2\n        },\n        {\n            methods: MMR_V1,\n            version: 1\n        }\n    ]\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}