{"ast":null,"code":"var _Decorate_instanceId, _Decorate_runtimeLog, _Decorate_registry, _Decorate_storageGetQ, _Decorate_storageSubQ;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, _ref) {\n  let {\n    method,\n    section\n  } = _ref;\n  return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n}\nexport class Decorate extends Events {\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    super();\n    _Decorate_instanceId.set(this, void 0);\n    _Decorate_runtimeLog.set(this, {});\n    _Decorate_registry.set(this, void 0);\n    _Decorate_storageGetQ.set(this, []);\n    _Decorate_storageSubQ.set(this, []);\n    // HACK Use BN import so decorateDerive works... yes, wtf.\n    this.__phantom = new BN(0);\n    this._call = {};\n    this._consts = {};\n    this._errors = {};\n    this._events = {};\n    this._extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;\n    this._isReady = false;\n    this._query = {};\n    this._runtimeMap = {};\n    this._rx = {\n      call: {},\n      consts: {},\n      query: {},\n      tx: {}\n    };\n    /**\n     * Put the `this.onCall` function of ApiRx here, because it is needed by\n     * `api._rx`.\n     */\n    this._rxDecorateMethod = method => {\n      return method;\n    };\n    __classPrivateFieldSet(this, _Decorate_instanceId, `${++instanceCounter}`, \"f\");\n    __classPrivateFieldSet(this, _Decorate_registry, options.source?.registry || options.registry || new TypeRegistry(), \"f\");\n    this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.call));\n    this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.query));\n    this._rx.registry = __classPrivateFieldGet(this, _Decorate_registry, \"f\");\n    const thisProvider = options.source ? options.source._rpcCore.provider.isClonable ? options.source._rpcCore.provider.clone() : options.source._rpcCore.provider : options.provider || new WsProvider();\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type;\n    // The RPC interface decorates the known interfaces on init\n    this._rpcCore = new RpcCore(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), __classPrivateFieldGet(this, _Decorate_registry, \"f\"), thisProvider, this._options.rpc);\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @description Return the current used registry\n   */\n  get registry() {\n    return __classPrivateFieldGet(this, _Decorate_registry, \"f\");\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createType(type) {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    return __classPrivateFieldGet(this, _Decorate_registry, \"f\").createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n  registerTypes(types) {\n    types && __classPrivateFieldGet(this, _Decorate_registry, \"f\").register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n  _emptyDecorated(registry, blockHash) {\n    return {\n      call: {},\n      consts: {},\n      errors: {},\n      events: {},\n      query: {},\n      registry,\n      rx: {\n        call: {},\n        query: {}\n      },\n      tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n    };\n  }\n  _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n    if (!decoratedApi) {\n      decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n    }\n    if (fromEmpty || !registry.decoratedMeta) {\n      registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n    }\n    const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n    const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n    const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n    const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n    augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n    augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n    augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n    augmentObject('query', storage, decoratedApi.query, fromEmpty);\n    augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n    augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n    augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n    decoratedApi.findCall = callIndex => findCall(registry.registry, callIndex);\n    decoratedApi.findError = errorIndex => findError(registry.registry, errorIndex);\n    decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);\n    decoratedApi.runtimeVersion = registry.runtimeVersion;\n    return {\n      createdAt: blockHash,\n      decoratedApi,\n      decoratedMeta: registry.decoratedMeta\n    };\n  }\n  _injectMetadata(registry) {\n    let fromEmpty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // clear the decoration, we are redoing it here\n    if (fromEmpty || !registry.decoratedApi) {\n      registry.decoratedApi = this._emptyDecorated(registry.registry);\n    }\n    const {\n      decoratedApi,\n      decoratedMeta\n    } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n    this._call = decoratedApi.call;\n    this._consts = decoratedApi.consts;\n    this._errors = decoratedApi.errors;\n    this._events = decoratedApi.events;\n    this._query = decoratedApi.query;\n    this._rx.call = decoratedApi.rx.call;\n    this._rx.query = decoratedApi.rx.query;\n    const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n    const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = tx;\n      this._rx.tx = rxtx;\n    } else {\n      augmentObject('tx', tx, this._extrinsics, false);\n      augmentObject(null, rxtx, this._rx.tx, false);\n    }\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n    this.emit('decorated');\n  }\n  /**\n   * @deprecated\n   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n   */\n  injectMetadata(metadata, fromEmpty, registry) {\n    this._injectMetadata({\n      counter: 0,\n      metadata,\n      registry: registry || __classPrivateFieldGet(this, _Decorate_registry, \"f\"),\n      runtimeVersion: __classPrivateFieldGet(this, _Decorate_registry, \"f\").createType('RuntimeVersionPartial')\n    }, fromEmpty);\n  }\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n    return output;\n  }\n  // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n  _filterRpc(methods, additional) {\n    // add any specific user-base RPCs\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional);\n      // re-decorate, only adding any new additional interfaces\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n    // extract the actual sections from the methods (this is useful when\n    // we try and create mappings to runtime names via a hash mapping)\n    const sectionMap = {};\n    for (let i = 0; i < methods.length; i++) {\n      const [section] = methods[i].split('_');\n      sectionMap[section] = true;\n    }\n    // convert the actual section names into an easy name lookup\n    const sections = Object.keys(sectionMap);\n    for (let i = 0; i < sections.length; i++) {\n      const nameA = stringUpperFirst(sections[i]);\n      const nameB = `${nameA}Api`;\n      this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n      this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n    }\n    // finally we filter the actual methods to expose\n    this._filterRpcMethods(methods);\n  }\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = [];\n    for (let i = 0; i < allKnown.length; i++) {\n      const [, {\n        alias,\n        endpoint,\n        method,\n        pubsub,\n        section\n      }] = allKnown[i];\n      allKeys.push(`${section}_${method}`);\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n      if (alias) {\n        allKeys.push(...alias);\n      }\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n    }\n    const unknown = exposed.filter(k => !allKeys.includes(k) && !k.includes('_unstable_'));\n    if (unknown.length && !this._options.noInitWarn) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    }\n    // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n    for (let i = 0; i < allKnown.length; i++) {\n      const [k, {\n        method,\n        section\n      }] = allKnown[i];\n      if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n        if (this._rpc[section]) {\n          delete this._rpc[section][method];\n          delete this._rx.rpc[section][method];\n        }\n      }\n    }\n  }\n  _rpcSubmitter(decorateMethod) {\n    var _this = this;\n    const method = function (method) {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      return from(_this._rpcCore.provider.send(method, params));\n    };\n    return decorateMethod(method);\n  }\n  _decorateRpc(rpc, decorateMethod) {\n    let input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._rpcSubmitter(decorateMethod);\n    const out = input;\n    const decorateFn = (section, method) => {\n      const source = rpc[section][method];\n      const fn = decorateMethod(source, {\n        methodName: method\n      });\n      fn.meta = source.meta;\n      fn.raw = decorateMethod(source.raw, {\n        methodName: method\n      });\n      return fn;\n    };\n    for (let s = 0; s < rpc.sections.length; s++) {\n      const section = rpc.sections[s];\n      if (!Object.prototype.hasOwnProperty.call(out, section)) {\n        const methods = Object.keys(rpc[section]);\n        const decorateInternal = method => decorateFn(section, method);\n        for (let m = 0; m < methods.length; m++) {\n          const method = methods[m];\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n              out[section] = {};\n            }\n            lazyMethod(out[section], method, decorateInternal);\n          }\n        }\n      }\n    }\n    return out;\n  }\n  // add all definition entries\n  _addRuntimeDef(result, additional) {\n    if (!additional) {\n      return;\n    }\n    const entries = Object.entries(additional);\n    for (let j = 0; j < entries.length; j++) {\n      const [key, defs] = entries[j];\n      if (result[key]) {\n        // we have this one already, step through for new versions or\n        // new methods and add those as applicable\n        for (let k = 0; k < defs.length; k++) {\n          const def = defs[k];\n          const prev = result[key].find(_ref2 => {\n            let {\n              version\n            } = _ref2;\n            return def.version === version;\n          });\n          if (prev) {\n            // interleave the new methods with the old - last definition wins\n            objectSpread(prev.methods, def.methods);\n          } else {\n            // we don't have this specific version, add it\n            result[key].push(def);\n          }\n        }\n      } else {\n        // we don't have this runtime definition, add it as-is\n        result[key] = defs;\n      }\n    }\n  }\n  // extract all runtime definitions\n  _getRuntimeDefs(registry, specName) {\n    let chain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const result = {};\n    const defValues = Object.values(typeDefinitions);\n    // options > chain/spec > built-in, apply in reverse order with\n    // methods overriding previous definitions (or interleave missing)\n    for (let i = 0; i < defValues.length; i++) {\n      this._addRuntimeDef(result, defValues[i].runtime);\n    }\n    this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n    this._addRuntimeDef(result, this._options.runtime);\n    return Object.entries(result);\n  }\n  // pre-metadata decoration\n  _decorateCalls(_ref3, decorateMethod, blockHash) {\n    let {\n      registry,\n      runtimeVersion: {\n        apis,\n        specName,\n        specVersion\n      }\n    } = _ref3;\n    const result = {};\n    const named = {};\n    const hashes = {};\n    const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);\n    const older = [];\n    const implName = `${specName.toString()}/${specVersion.toString()}`;\n    const hasLogged = __classPrivateFieldGet(this, _Decorate_runtimeLog, \"f\")[implName] || false;\n    __classPrivateFieldGet(this, _Decorate_runtimeLog, \"f\")[implName] = true;\n    for (let i = 0; i < sections.length; i++) {\n      const [_section, secs] = sections[i];\n      const sectionHash = blake2AsHex(_section, 64);\n      const rtApi = apis.find(_ref4 => {\n        let [a] = _ref4;\n        return a.eq(sectionHash);\n      });\n      hashes[sectionHash] = true;\n      if (rtApi) {\n        const all = secs.map(_ref5 => {\n          let {\n            version\n          } = _ref5;\n          return version;\n        }).sort();\n        const sec = secs.find(_ref6 => {\n          let {\n            version\n          } = _ref6;\n          return rtApi[1].eq(version);\n        });\n        if (sec) {\n          const section = stringCamelCase(_section);\n          const methods = Object.entries(sec.methods);\n          if (methods.length) {\n            if (!named[section]) {\n              named[section] = {};\n            }\n            for (let m = 0; m < methods.length; m++) {\n              const [_method, def] = methods[m];\n              const method = stringCamelCase(_method);\n              named[section][method] = objectSpread({\n                method,\n                name: `${_section}_${_method}`,\n                section,\n                sectionHash\n              }, def);\n            }\n          }\n        } else {\n          older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);\n        }\n      }\n    }\n    // find the runtimes that we don't have hashes for\n    const notFound = apis.map(_ref7 => {\n      let [a, v] = _ref7;\n      return [a.toHex(), v.toString()];\n    }).filter(_ref8 => {\n      let [a] = _ref8;\n      return !hashes[a];\n    }).map(_ref9 => {\n      let [a, v] = _ref9;\n      return `${this._runtimeMap[a] || a}/${v}`;\n    });\n    if (!this._options.noInitWarn && !hasLogged) {\n      if (older.length) {\n        l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);\n      }\n      if (notFound.length) {\n        l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);\n      }\n    }\n    const stateCall = blockHash ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash) : (name, bytes) => this._rpcCore.state.call(name, bytes);\n    const lazySection = section => lazyMethods({}, Object.keys(named[section]), method => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n    const modules = Object.keys(named);\n    for (let i = 0; i < modules.length; i++) {\n      lazyMethod(result, modules[i], lazySection);\n    }\n    return result;\n  }\n  _decorateCall(registry, def, stateCall, decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const decorated = decorateMethod(function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      if (args.length !== def.params.length) {\n        throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);\n      }\n      const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n      return stateCall(def.name, bytes).pipe(map(r => registry.createTypeUnsafe(def.type, [r])));\n    });\n    decorated.meta = def;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorated;\n  }\n  // only be called if supportMulti is true\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(keys => keys.length ? (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys.map(args => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])) : of([]));\n  }\n  _decorateMultiAt(atApi, decorateMethod, blockHash) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => calls.length ? this._rpcCore.state.queryStorageAt(calls.map(args => {\n      if (Array.isArray(args)) {\n        const {\n          creator\n        } = getAtQueryFn(atApi, args[0].creator);\n        return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];\n      }\n      return [getAtQueryFn(atApi, args.creator).creator];\n    }), blockHash) : of([]));\n  }\n  _decorateExtrinsics(_ref10, decorateMethod) {\n    let {\n      tx\n    } = _ref10;\n    const result = createSubmittable(this._type, this._rx, decorateMethod);\n    const lazySection = section => lazyMethods({}, Object.keys(tx[section]), method => method.startsWith('$') ? tx[section][method] : this._decorateExtrinsicEntry(tx[section][method], result));\n    const sections = Object.keys(tx);\n    for (let i = 0; i < sections.length; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = function () {\n      return creator(method(...arguments));\n    };\n    // pass through the `.is`\n    decorated.is = other => method.is(other);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._decorateFunctionMeta(method, decorated);\n  }\n  _decorateStorage(_ref11, decorateMethod, blockHash) {\n    let {\n      query,\n      registry\n    } = _ref11;\n    const result = {};\n    const lazySection = section => lazyMethods({}, Object.keys(query[section]), method => blockHash ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash) : this._decorateStorageEntry(query[section][method], decorateMethod));\n    const sections = Object.keys(query);\n    for (let i = 0; i < sections.length; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateStorageEntry(creator, decorateMethod) {\n    var _this2 = this;\n    const getArgs = (args, registry) => extractStorageArgs(registry || __classPrivateFieldGet(this, _Decorate_registry, \"f\"), creator, args);\n    const getQueryAt = blockHash => from(this.at(blockHash)).pipe(map(api => getAtQueryFn(api, creator)));\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n    decorated.creator = creator;\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.at = decorateMethod(function (blockHash) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n      return getQueryAt(blockHash).pipe(switchMap(q => q(...args)));\n    });\n    decorated.hash = decorateMethod(function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this2._rpcCore.state.getStorageHash(getArgs(args));\n    });\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = function () {\n      return u8aToHex(compactStripLength(creator(...arguments))[1]);\n    };\n    decorated.keyPrefix = function () {\n      return u8aToHex(creator.keyPrefix(...arguments));\n    };\n    decorated.size = decorateMethod(function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this2._rpcCore.state.getStorageSize(getArgs(args));\n    });\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.sizeAt = decorateMethod(function (blockHash) {\n      for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        args[_key7 - 1] = arguments[_key7];\n      }\n      return getQueryAt(blockHash).pipe(switchMap(q => _this2._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash)));\n    });\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), function () {\n        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n          args[_key8] = arguments[_key8];\n        }\n        return _this2._retrieveMapEntries(creator, null, args);\n      }));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.entriesAt = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), function (blockHash) {\n        for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n          args[_key9 - 1] = arguments[_key9];\n        }\n        return getQueryAt(blockHash).pipe(switchMap(q => _this2._retrieveMapEntries(q.creator, blockHash, args)));\n      }));\n      decorated.entriesPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), opts => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n      decorated.keys = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), function () {\n        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n          args[_key10] = arguments[_key10];\n        }\n        return _this2._retrieveMapKeys(creator, null, args);\n      }));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.keysAt = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), function (blockHash) {\n        for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n          args[_key11 - 1] = arguments[_key11];\n        }\n        return getQueryAt(blockHash).pipe(switchMap(q => _this2._retrieveMapKeys(q.creator, blockHash, args)));\n      }));\n      decorated.keysPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), opts => this._retrieveMapKeysPaged(creator, undefined, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]])) : this._retrieveMulti(args.map(a => [creator, a])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n    var _this3 = this;\n    const getArgs = args => extractStorageArgs(registry, creator, args);\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = decorateMethod(function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _this3._rpcCore.state.getStorage(getArgs(args), blockHash);\n    });\n    decorated.creator = creator;\n    decorated.hash = decorateMethod(function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _this3._rpcCore.state.getStorageHash(getArgs(args), blockHash);\n    });\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = function () {\n      return u8aToHex(compactStripLength(creator(...arguments))[1]);\n    };\n    decorated.keyPrefix = function () {\n      return u8aToHex(creator.keyPrefix(...arguments));\n    };\n    decorated.size = decorateMethod(function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _this3._rpcCore.state.getStorageSize(getArgs(args), blockHash);\n    });\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), function () {\n        for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n          args[_key15] = arguments[_key15];\n        }\n        return _this3._retrieveMapEntries(creator, blockHash, args);\n      }));\n      decorated.entriesPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), opts => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n      decorated.keys = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), function () {\n        for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n          args[_key16] = arguments[_key16];\n        }\n        return _this3._retrieveMapKeys(creator, blockHash, args);\n      }));\n      decorated.keysPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), opts => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]]), blockHash) : this._retrieveMulti(args.map(a => [creator, a]), blockHash));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _queueStorage(call, queue) {\n    const query = queue === __classPrivateFieldGet(this, _Decorate_storageSubQ, \"f\") ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    let queueIdx = queue.length - 1;\n    let valueIdx = 0;\n    let valueObs;\n    // if we don't have queue entries yet,\n    // or the current queue has fired (see from below),\n    // or the current queue has the max entries,\n    // then we create a new queue\n    if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n      queueIdx++;\n      valueObs = from(\n      // we delay the execution until the next tick, this allows\n      // any queries made in this timeframe to be added to the same\n      // queue for a single query\n      new Promise(resolve => {\n        nextTick(() => {\n          // get all the calls in this instance, resolve with it\n          // and then clear the queue so we don't add more\n          // (anything after this will be added to a new queue)\n          const calls = queue[queueIdx][1];\n          delete queue[queueIdx];\n          resolve(calls);\n        });\n      })).pipe(switchMap(calls => query(calls)));\n      queue.push([valueObs, [call]]);\n    } else {\n      valueObs = queue[queueIdx][0];\n      valueIdx = queue[queueIdx][1].length;\n      queue[queueIdx][1].push(call);\n    }\n    return valueObs.pipe(\n    // return the single value at this index\n    map(values => values[valueIdx]));\n  }\n  // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n  _decorateStorageCall(creator, decorateMethod) {\n    var _this4 = this;\n    const memoed = memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), function () {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      const call = extractStorageArgs(__classPrivateFieldGet(_this4, _Decorate_registry, \"f\"), creator, args);\n      if (!_this4.hasSubscriptions) {\n        return _this4._rpcCore.state.getStorage(call);\n      }\n      return _this4._queueStorage(call, __classPrivateFieldGet(_this4, _Decorate_storageSubQ, \"f\"));\n    });\n    return decorateMethod(memoed, {\n      methodName: creator.method,\n      overrideNoSub: function () {\n        for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n          args[_key18] = arguments[_key18];\n        }\n        return _this4._queueStorage(extractStorageArgs(__classPrivateFieldGet(_this4, _Decorate_registry, \"f\"), creator, args), __classPrivateFieldGet(_this4, _Decorate_storageGetQ, \"f\"));\n      }\n    });\n  }\n  // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n  _retrieveMulti(keys, blockHash) {\n    if (!keys.length) {\n      return of([]);\n    }\n    const query = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    if (keys.length <= PAGE_SIZE_V) {\n      return blockHash ? query(keys, blockHash) : query(keys);\n    }\n    return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(k => blockHash ? query(k, blockHash) : query(k))).pipe(map(arrayFlatten));\n  }\n  _retrieveMapKeys(_ref12, at, args) {\n    let {\n      iterKey,\n      meta,\n      method,\n      section\n    } = _ref12;\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const headKey = iterKey(...args).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const query = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n    const setMeta = key => key.setMeta(meta, section, method);\n    return startSubject.pipe(switchMap(query), map(keys => keys.map(setMeta)), tap(keys => nextTick(() => {\n      keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();\n    })), toArray(),\n    // toArray since we want to startSubject to be completed\n    map(arrayFlatten));\n  }\n  _retrieveMapKeysPaged(_ref13, at, opts) {\n    let {\n      iterKey,\n      meta,\n      method,\n      section\n    } = _ref13;\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const setMeta = key => key.setMeta(meta, section, method);\n    const query = at ? headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n    return query(iterKey(...opts.args).toHex()).pipe(map(keys => keys.map(setMeta)));\n  }\n  _retrieveMapEntries(entry, at, args) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeys(entry, at, args).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _retrieveMapEntriesPaged(entry, at, opts) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap(keys => keys.length ? query(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _decorateDeriveRx(decorateMethod) {\n    const specName = this._runtimeVersion?.specName.toString();\n    // Pull in derive from api-derive\n    const available = getAvailableDerives(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));\n    return decorateDeriveSections(decorateMethod, available);\n  }\n  _decorateDerive(decorateMethod) {\n    return decorateDeriveSections(decorateMethod, this._rx.derive);\n  }\n}\n_Decorate_instanceId = new WeakMap(), _Decorate_runtimeLog = new WeakMap(), _Decorate_registry = new WeakMap(), _Decorate_storageGetQ = new WeakMap(), _Decorate_storageSubQ = new WeakMap();","map":{"version":3,"names":["_Decorate_instanceId","_Decorate_runtimeLog","_Decorate_registry","_Decorate_storageGetQ","_Decorate_storageSubQ","__classPrivateFieldGet","__classPrivateFieldSet","BehaviorSubject","combineLatest","from","map","of","switchMap","tap","toArray","getAvailableDerives","memo","RpcCore","WsProvider","expandMetadata","GenericExtrinsic","typeDefinitions","TypeRegistry","getSpecRuntime","arrayChunk","arrayFlatten","assertReturn","BN","compactStripLength","lazyMethod","lazyMethods","logger","nextTick","objectSpread","stringCamelCase","stringUpperFirst","u8aConcatStrict","u8aToHex","blake2AsHex","createSubmittable","augmentObject","decorateDeriveSections","extractStorageArgs","Events","findCall","findError","PAGE_SIZE_K","PAGE_SIZE_V","PAGE_SIZE_Q","l","instanceCounter","getAtQueryFn","api","_ref","method","section","rx","query","Decorate","constructor","options","type","decorateMethod","set","__phantom","_call","_consts","_errors","_events","_extrinsicType","LATEST_EXTRINSIC_VERSION","_isReady","_query","_runtimeMap","_rx","call","consts","tx","_rxDecorateMethod","source","registry","callAt","blockHash","knownVersion","at","pipe","a","queryAt","thisProvider","_rpcCore","provider","isClonable","clone","_decorateMethod","_options","_type","rpc","_isConnected","isConnected","hasSubscriptions","createType","_len","arguments","length","params","Array","_key","registerTypes","types","register","supportMulti","state","queryStorageAt","_emptyDecorated","errors","events","_createDecorated","fromEmpty","decoratedApi","decoratedMeta","metadata","runtime","_decorateCalls","runtimeRx","storage","_decorateStorage","storageRx","callIndex","errorIndex","queryMulti","_decorateMultiAt","_decorateMulti","runtimeVersion","createdAt","_injectMetadata","undefined","_decorateExtrinsics","rxtx","_extrinsics","emit","injectMetadata","counter","_decorateFunctionMeta","input","output","meta","toJSON","_filterRpc","methods","additional","Object","keys","addUserInterfaces","_decorateRpc","_rpc","sectionMap","i","split","sections","nameA","nameB","_filterRpcMethods","exposed","hasResults","allKnown","mapping","entries","allKeys","alias","endpoint","pubsub","push","unknown","filter","k","includes","noInitWarn","warn","join","_rpcSubmitter","_this","_len2","_key2","send","out","decorateFn","fn","methodName","raw","s","prototype","hasOwnProperty","decorateInternal","m","startsWith","_addRuntimeDef","result","j","key","defs","def","prev","find","_ref2","version","_getRuntimeDefs","specName","chain","defValues","values","_ref3","apis","specVersion","named","hashes","_runtimeChain","older","implName","toString","hasLogged","_section","secs","sectionHash","rtApi","_ref4","eq","all","_ref5","sort","sec","_ref6","_method","name","notFound","_ref7","v","toHex","_ref8","_ref9","stateCall","bytes","lazySection","_decorateCall","modules","decorated","_len3","args","_key3","Error","createTypeUnsafe","toU8a","r","subscribeStorage","isArray","creator","isPlain","asMap","hashers","slice","atApi","calls","_ref10","_decorateExtrinsicEntry","is","other","_ref11","_decorateStorageEntryAt","_decorateStorageEntry","_this2","getArgs","getQueryAt","_decorateStorageCall","_len4","_key4","q","hash","_len5","_key5","getStorageHash","keyPrefix","size","_len6","_key6","getStorageSize","sizeAt","_len7","_key7","iterKey","isMap","_len8","_key8","_retrieveMapEntries","entriesAt","_len9","_key9","entriesPaged","opts","_retrieveMapEntriesPaged","_len10","_key10","_retrieveMapKeys","keysAt","_len11","_key11","keysPaged","_retrieveMapKeysPaged","multi","_retrieveMulti","_this3","_len12","_key12","getStorage","_len13","_key13","_len14","_key14","_len15","_key15","_len16","_key16","_queueStorage","queue","queueIdx","valueIdx","valueObs","Promise","resolve","_this4","memoed","_len17","_key17","overrideNoSub","_len18","_key18","_ref12","headKey","startSubject","startKey","getKeysPaged","setMeta","next","complete","_ref13","pageSize","entry","valsArr","value","index","_decorateDeriveRx","_runtimeVersion","available","derives","typesBundle","spec","_decorateDerive","derive","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api/base/Decorate.js"],"sourcesContent":["var _Decorate_instanceId, _Decorate_runtimeLog, _Decorate_registry, _Decorate_storageGetQ, _Decorate_storageSubQ;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, { method, section }) {\n    return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n}\nexport class Decorate extends Events {\n    /**\n     * @description Create an instance of the class\n     *\n     * @param options Options object to create API instance or a Provider instance\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * const api = new Api().isReady();\n     *\n     * api.rpc.subscribeNewHeads((header) => {\n     *   console.log(`new block #${header.number.toNumber()}`);\n     * });\n     * ```\n     */\n    constructor(options, type, decorateMethod) {\n        super();\n        _Decorate_instanceId.set(this, void 0);\n        _Decorate_runtimeLog.set(this, {});\n        _Decorate_registry.set(this, void 0);\n        _Decorate_storageGetQ.set(this, []);\n        _Decorate_storageSubQ.set(this, []);\n        // HACK Use BN import so decorateDerive works... yes, wtf.\n        this.__phantom = new BN(0);\n        this._call = {};\n        this._consts = {};\n        this._errors = {};\n        this._events = {};\n        this._extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;\n        this._isReady = false;\n        this._query = {};\n        this._runtimeMap = {};\n        this._rx = { call: {}, consts: {}, query: {}, tx: {} };\n        /**\n         * Put the `this.onCall` function of ApiRx here, because it is needed by\n         * `api._rx`.\n         */\n        this._rxDecorateMethod = (method) => {\n            return method;\n        };\n        __classPrivateFieldSet(this, _Decorate_instanceId, `${++instanceCounter}`, \"f\");\n        __classPrivateFieldSet(this, _Decorate_registry, options.source?.registry || options.registry || new TypeRegistry(), \"f\");\n        this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.call));\n        this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.query));\n        this._rx.registry = __classPrivateFieldGet(this, _Decorate_registry, \"f\");\n        const thisProvider = options.source\n            ? options.source._rpcCore.provider.isClonable\n                ? options.source._rpcCore.provider.clone()\n                : options.source._rpcCore.provider\n            : (options.provider || new WsProvider());\n        this._decorateMethod = decorateMethod;\n        this._options = options;\n        this._type = type;\n        // The RPC interface decorates the known interfaces on init\n        this._rpcCore = new RpcCore(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), __classPrivateFieldGet(this, _Decorate_registry, \"f\"), thisProvider, this._options.rpc);\n        this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n        this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @description Return the current used registry\n     */\n    get registry() {\n        return __classPrivateFieldGet(this, _Decorate_registry, \"f\");\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n    createType(type, ...params) {\n        return __classPrivateFieldGet(this, _Decorate_registry, \"f\").createType(type, ...params);\n    }\n    /**\n     * @description Register additional user-defined of chain-specific types in the type registry\n     */\n    registerTypes(types) {\n        types && __classPrivateFieldGet(this, _Decorate_registry, \"f\").register(types);\n    }\n    /**\n     * @returns `true` if the API operates with subscriptions\n     */\n    get hasSubscriptions() {\n        return this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @returns `true` if the API decorate multi-key queries\n     */\n    get supportMulti() {\n        return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n    }\n    _emptyDecorated(registry, blockHash) {\n        return {\n            call: {},\n            consts: {},\n            errors: {},\n            events: {},\n            query: {},\n            registry,\n            rx: {\n                call: {},\n                query: {}\n            },\n            tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n        };\n    }\n    _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n        if (!decoratedApi) {\n            decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n        }\n        if (fromEmpty || !registry.decoratedMeta) {\n            registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n        }\n        const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n        const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n        const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n        const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n        augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n        augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n        augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n        augmentObject('query', storage, decoratedApi.query, fromEmpty);\n        augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n        augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n        augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n        decoratedApi.findCall = (callIndex) => findCall(registry.registry, callIndex);\n        decoratedApi.findError = (errorIndex) => findError(registry.registry, errorIndex);\n        decoratedApi.queryMulti = blockHash\n            ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash)\n            : this._decorateMulti(this._decorateMethod);\n        decoratedApi.runtimeVersion = registry.runtimeVersion;\n        return {\n            createdAt: blockHash,\n            decoratedApi,\n            decoratedMeta: registry.decoratedMeta\n        };\n    }\n    _injectMetadata(registry, fromEmpty = false) {\n        // clear the decoration, we are redoing it here\n        if (fromEmpty || !registry.decoratedApi) {\n            registry.decoratedApi = this._emptyDecorated(registry.registry);\n        }\n        const { decoratedApi, decoratedMeta } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n        this._call = decoratedApi.call;\n        this._consts = decoratedApi.consts;\n        this._errors = decoratedApi.errors;\n        this._events = decoratedApi.events;\n        this._query = decoratedApi.query;\n        this._rx.call = decoratedApi.rx.call;\n        this._rx.query = decoratedApi.rx.query;\n        const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n        const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n        if (fromEmpty || !this._extrinsics) {\n            this._extrinsics = tx;\n            this._rx.tx = rxtx;\n        }\n        else {\n            augmentObject('tx', tx, this._extrinsics, false);\n            augmentObject(null, rxtx, this._rx.tx, false);\n        }\n        augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n        this.emit('decorated');\n    }\n    /**\n     * @deprecated\n     * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n     */\n    injectMetadata(metadata, fromEmpty, registry) {\n        this._injectMetadata({ counter: 0, metadata, registry: registry || __classPrivateFieldGet(this, _Decorate_registry, \"f\"), runtimeVersion: __classPrivateFieldGet(this, _Decorate_registry, \"f\").createType('RuntimeVersionPartial') }, fromEmpty);\n    }\n    _decorateFunctionMeta(input, output) {\n        output.meta = input.meta;\n        output.method = input.method;\n        output.section = input.section;\n        output.toJSON = input.toJSON;\n        if (input.callIndex) {\n            output.callIndex = input.callIndex;\n        }\n        return output;\n    }\n    // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n    // manner to cater for both old and new:\n    //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n    //   - when non-zero, remove anything that is not in the array (we don't do this)\n    _filterRpc(methods, additional) {\n        // add any specific user-base RPCs\n        if (Object.keys(additional).length !== 0) {\n            this._rpcCore.addUserInterfaces(additional);\n            // re-decorate, only adding any new additional interfaces\n            this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n            this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n        }\n        // extract the actual sections from the methods (this is useful when\n        // we try and create mappings to runtime names via a hash mapping)\n        const sectionMap = {};\n        for (let i = 0; i < methods.length; i++) {\n            const [section] = methods[i].split('_');\n            sectionMap[section] = true;\n        }\n        // convert the actual section names into an easy name lookup\n        const sections = Object.keys(sectionMap);\n        for (let i = 0; i < sections.length; i++) {\n            const nameA = stringUpperFirst(sections[i]);\n            const nameB = `${nameA}Api`;\n            this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n            this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n        }\n        // finally we filter the actual methods to expose\n        this._filterRpcMethods(methods);\n    }\n    _filterRpcMethods(exposed) {\n        const hasResults = exposed.length !== 0;\n        const allKnown = [...this._rpcCore.mapping.entries()];\n        const allKeys = [];\n        for (let i = 0; i < allKnown.length; i++) {\n            const [, { alias, endpoint, method, pubsub, section }] = allKnown[i];\n            allKeys.push(`${section}_${method}`);\n            if (pubsub) {\n                allKeys.push(`${section}_${pubsub[1]}`);\n                allKeys.push(`${section}_${pubsub[2]}`);\n            }\n            if (alias) {\n                allKeys.push(...alias);\n            }\n            if (endpoint) {\n                allKeys.push(endpoint);\n            }\n        }\n        const unknown = exposed.filter((k) => !allKeys.includes(k) &&\n            !k.includes('_unstable_'));\n        if (unknown.length && !this._options.noInitWarn) {\n            l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n        }\n        // loop through all entries we have (populated in decorate) and filter as required\n        // only remove when we have results and method missing, or with no results if optional\n        for (let i = 0; i < allKnown.length; i++) {\n            const [k, { method, section }] = allKnown[i];\n            if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n                if (this._rpc[section]) {\n                    delete this._rpc[section][method];\n                    delete this._rx.rpc[section][method];\n                }\n            }\n        }\n    }\n    _rpcSubmitter(decorateMethod) {\n        const method = (method, ...params) => {\n            return from(this._rpcCore.provider.send(method, params));\n        };\n        return decorateMethod(method);\n    }\n    _decorateRpc(rpc, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {\n        const out = input;\n        const decorateFn = (section, method) => {\n            const source = rpc[section][method];\n            const fn = decorateMethod(source, { methodName: method });\n            fn.meta = source.meta;\n            fn.raw = decorateMethod(source.raw, { methodName: method });\n            return fn;\n        };\n        for (let s = 0; s < rpc.sections.length; s++) {\n            const section = rpc.sections[s];\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                const methods = Object.keys(rpc[section]);\n                const decorateInternal = (method) => decorateFn(section, method);\n                for (let m = 0; m < methods.length; m++) {\n                    const method = methods[m];\n                    //  skip subscriptions where we have a non-subscribe interface\n                    if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n                        if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                            out[section] = {};\n                        }\n                        lazyMethod(out[section], method, decorateInternal);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    // add all definition entries\n    _addRuntimeDef(result, additional) {\n        if (!additional) {\n            return;\n        }\n        const entries = Object.entries(additional);\n        for (let j = 0; j < entries.length; j++) {\n            const [key, defs] = entries[j];\n            if (result[key]) {\n                // we have this one already, step through for new versions or\n                // new methods and add those as applicable\n                for (let k = 0; k < defs.length; k++) {\n                    const def = defs[k];\n                    const prev = result[key].find(({ version }) => def.version === version);\n                    if (prev) {\n                        // interleave the new methods with the old - last definition wins\n                        objectSpread(prev.methods, def.methods);\n                    }\n                    else {\n                        // we don't have this specific version, add it\n                        result[key].push(def);\n                    }\n                }\n            }\n            else {\n                // we don't have this runtime definition, add it as-is\n                result[key] = defs;\n            }\n        }\n    }\n    // extract all runtime definitions\n    _getRuntimeDefs(registry, specName, chain = '') {\n        const result = {};\n        const defValues = Object.values(typeDefinitions);\n        // options > chain/spec > built-in, apply in reverse order with\n        // methods overriding previous definitions (or interleave missing)\n        for (let i = 0; i < defValues.length; i++) {\n            this._addRuntimeDef(result, defValues[i].runtime);\n        }\n        this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n        this._addRuntimeDef(result, this._options.runtime);\n        return Object.entries(result);\n    }\n    // pre-metadata decoration\n    _decorateCalls({ registry, runtimeVersion: { apis, specName, specVersion } }, decorateMethod, blockHash) {\n        const result = {};\n        const named = {};\n        const hashes = {};\n        const sections = this._getRuntimeDefs(registry, specName, this._runtimeChain);\n        const older = [];\n        const implName = `${specName.toString()}/${specVersion.toString()}`;\n        const hasLogged = __classPrivateFieldGet(this, _Decorate_runtimeLog, \"f\")[implName] || false;\n        __classPrivateFieldGet(this, _Decorate_runtimeLog, \"f\")[implName] = true;\n        for (let i = 0; i < sections.length; i++) {\n            const [_section, secs] = sections[i];\n            const sectionHash = blake2AsHex(_section, 64);\n            const rtApi = apis.find(([a]) => a.eq(sectionHash));\n            hashes[sectionHash] = true;\n            if (rtApi) {\n                const all = secs.map(({ version }) => version).sort();\n                const sec = secs.find(({ version }) => rtApi[1].eq(version));\n                if (sec) {\n                    const section = stringCamelCase(_section);\n                    const methods = Object.entries(sec.methods);\n                    if (methods.length) {\n                        if (!named[section]) {\n                            named[section] = {};\n                        }\n                        for (let m = 0; m < methods.length; m++) {\n                            const [_method, def] = methods[m];\n                            const method = stringCamelCase(_method);\n                            named[section][method] = objectSpread({ method, name: `${_section}_${_method}`, section, sectionHash }, def);\n                        }\n                    }\n                }\n                else {\n                    older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);\n                }\n            }\n        }\n        // find the runtimes that we don't have hashes for\n        const notFound = apis\n            .map(([a, v]) => [a.toHex(), v.toString()])\n            .filter(([a]) => !hashes[a])\n            .map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);\n        if (!this._options.noInitWarn && !hasLogged) {\n            if (older.length) {\n                l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);\n            }\n            if (notFound.length) {\n                l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);\n            }\n        }\n        const stateCall = blockHash\n            ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash)\n            : (name, bytes) => this._rpcCore.state.call(name, bytes);\n        const lazySection = (section) => lazyMethods({}, Object.keys(named[section]), (method) => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n        const modules = Object.keys(named);\n        for (let i = 0; i < modules.length; i++) {\n            lazyMethod(result, modules[i], lazySection);\n        }\n        return result;\n    }\n    _decorateCall(registry, def, stateCall, decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const decorated = decorateMethod((...args) => {\n            if (args.length !== def.params.length) {\n                throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);\n            }\n            const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n            return stateCall(def.name, bytes).pipe(map((r) => registry.createTypeUnsafe(def.type, [r])));\n        });\n        decorated.meta = def;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorated;\n    }\n    // only be called if supportMulti is true\n    _decorateMulti(decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((keys) => keys.length\n            ? (this.hasSubscriptions\n                ? this._rpcCore.state.subscribeStorage\n                : this._rpcCore.state.queryStorageAt)(keys.map((args) => Array.isArray(args)\n                ? args[0].creator.meta.type.isPlain\n                    ? [args[0].creator]\n                    : args[0].creator.meta.type.asMap.hashers.length === 1\n                        ? [args[0].creator, args.slice(1)]\n                        : [args[0].creator, ...args.slice(1)]\n                : [args.creator]))\n            : of([]));\n    }\n    _decorateMultiAt(atApi, decorateMethod, blockHash) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((calls) => calls.length\n            ? this._rpcCore.state.queryStorageAt(calls.map((args) => {\n                if (Array.isArray(args)) {\n                    const { creator } = getAtQueryFn(atApi, args[0].creator);\n                    return creator.meta.type.isPlain\n                        ? [creator]\n                        : creator.meta.type.asMap.hashers.length === 1\n                            ? [creator, args.slice(1)]\n                            : [creator, ...args.slice(1)];\n                }\n                return [getAtQueryFn(atApi, args.creator).creator];\n            }), blockHash)\n            : of([]));\n    }\n    _decorateExtrinsics({ tx }, decorateMethod) {\n        const result = createSubmittable(this._type, this._rx, decorateMethod);\n        const lazySection = (section) => lazyMethods({}, Object.keys(tx[section]), (method) => method.startsWith('$')\n            ? tx[section][method]\n            : this._decorateExtrinsicEntry(tx[section][method], result));\n        const sections = Object.keys(tx);\n        for (let i = 0; i < sections.length; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateExtrinsicEntry(method, creator) {\n        const decorated = (...params) => creator(method(...params));\n        // pass through the `.is`\n        decorated.is = (other) => method.is(other);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this._decorateFunctionMeta(method, decorated);\n    }\n    _decorateStorage({ query, registry }, decorateMethod, blockHash) {\n        const result = {};\n        const lazySection = (section) => lazyMethods({}, Object.keys(query[section]), (method) => blockHash\n            ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash)\n            : this._decorateStorageEntry(query[section][method], decorateMethod));\n        const sections = Object.keys(query);\n        for (let i = 0; i < sections.length; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateStorageEntry(creator, decorateMethod) {\n        const getArgs = (args, registry) => extractStorageArgs(registry || __classPrivateFieldGet(this, _Decorate_registry, \"f\"), creator, args);\n        const getQueryAt = (blockHash) => from(this.at(blockHash)).pipe(map((api) => getAtQueryFn(api, creator)));\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = this._decorateStorageCall(creator, decorateMethod);\n        decorated.creator = creator;\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => q(...args))));\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (...args) => this._retrieveMapEntries(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.entriesAt = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapEntries(q.creator, blockHash, args)))));\n            decorated.entriesPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (opts) => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n            decorated.keys = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (...args) => this._retrieveMapKeys(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.keysAt = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapKeys(q.creator, blockHash, args)))));\n            decorated.keysPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (opts) => this._retrieveMapKeysPaged(creator, undefined, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]))\n                : this._retrieveMulti(args.map((a) => [creator, a])));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n        const getArgs = (args) => extractStorageArgs(registry, creator, args);\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n        decorated.creator = creator;\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n            decorated.entriesPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (opts) => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n            decorated.keys = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n            decorated.keysPaged = decorateMethod(memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (opts) => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]), blockHash)\n                : this._retrieveMulti(args.map((a) => [creator, a]), blockHash));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _queueStorage(call, queue) {\n        const query = queue === __classPrivateFieldGet(this, _Decorate_storageSubQ, \"f\")\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        let queueIdx = queue.length - 1;\n        let valueIdx = 0;\n        let valueObs;\n        // if we don't have queue entries yet,\n        // or the current queue has fired (see from below),\n        // or the current queue has the max entries,\n        // then we create a new queue\n        if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n            queueIdx++;\n            valueObs = from(\n            // we delay the execution until the next tick, this allows\n            // any queries made in this timeframe to be added to the same\n            // queue for a single query\n            new Promise((resolve) => {\n                nextTick(() => {\n                    // get all the calls in this instance, resolve with it\n                    // and then clear the queue so we don't add more\n                    // (anything after this will be added to a new queue)\n                    const calls = queue[queueIdx][1];\n                    delete queue[queueIdx];\n                    resolve(calls);\n                });\n            })).pipe(switchMap((calls) => query(calls)));\n            queue.push([valueObs, [call]]);\n        }\n        else {\n            valueObs = queue[queueIdx][0];\n            valueIdx = queue[queueIdx][1].length;\n            queue[queueIdx][1].push(call);\n        }\n        return valueObs.pipe(\n        // return the single value at this index\n        map((values) => values[valueIdx]));\n    }\n    // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n    // we make a subscription, alternatively we push this through a single-shot query\n    _decorateStorageCall(creator, decorateMethod) {\n        const memoed = memo(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), (...args) => {\n            const call = extractStorageArgs(__classPrivateFieldGet(this, _Decorate_registry, \"f\"), creator, args);\n            if (!this.hasSubscriptions) {\n                return this._rpcCore.state.getStorage(call);\n            }\n            return this._queueStorage(call, __classPrivateFieldGet(this, _Decorate_storageSubQ, \"f\"));\n        });\n        return decorateMethod(memoed, {\n            methodName: creator.method,\n            overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(__classPrivateFieldGet(this, _Decorate_registry, \"f\"), creator, args), __classPrivateFieldGet(this, _Decorate_storageGetQ, \"f\"))\n        });\n    }\n    // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n    _retrieveMulti(keys, blockHash) {\n        if (!keys.length) {\n            return of([]);\n        }\n        const query = this.hasSubscriptions && !blockHash\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        if (keys.length <= PAGE_SIZE_V) {\n            return blockHash\n                ? query(keys, blockHash)\n                : query(keys);\n        }\n        return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map((k) => blockHash\n            ? query(k, blockHash)\n            : query(k))).pipe(map(arrayFlatten));\n    }\n    _retrieveMapKeys({ iterKey, meta, method, section }, at, args) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const headKey = iterKey(...args).toHex();\n        const startSubject = new BehaviorSubject(headKey);\n        const query = at\n            ? (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at)\n            : (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        return startSubject.pipe(switchMap(query), map((keys) => keys.map(setMeta)), tap((keys) => nextTick(() => {\n            keys.length === PAGE_SIZE_K\n                ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex())\n                : startSubject.complete();\n        })), toArray(), // toArray since we want to startSubject to be completed\n        map(arrayFlatten));\n    }\n    _retrieveMapKeysPaged({ iterKey, meta, method, section }, at, opts) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        const query = at\n            ? (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at)\n            : (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n        return query(iterKey(...opts.args).toHex()).pipe(map((keys) => keys.map(setMeta)));\n    }\n    _retrieveMapEntries(entry, at, args) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeys(entry, at, args).pipe(switchMap((keys) => keys.length\n            ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map((valsArr) => arrayFlatten(valsArr).map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _retrieveMapEntriesPaged(entry, at, opts) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap((keys) => keys.length\n            ? query(keys).pipe(map((valsArr) => valsArr.map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _decorateDeriveRx(decorateMethod) {\n        const specName = this._runtimeVersion?.specName.toString();\n        // Pull in derive from api-derive\n        const available = getAvailableDerives(__classPrivateFieldGet(this, _Decorate_instanceId, \"f\"), this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));\n        return decorateDeriveSections(decorateMethod, available);\n    }\n    _decorateDerive(decorateMethod) {\n        return decorateDeriveSections(decorateMethod, this._rx.derive);\n    }\n}\n_Decorate_instanceId = new WeakMap(), _Decorate_runtimeLog = new WeakMap(), _Decorate_registry = new WeakMap(), _Decorate_storageGetQ = new WeakMap(), _Decorate_storageSubQ = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}