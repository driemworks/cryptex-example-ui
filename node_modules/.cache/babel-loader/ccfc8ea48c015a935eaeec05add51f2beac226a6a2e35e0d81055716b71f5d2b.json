{"ast":null,"code":"const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\nalias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false), alias('VecDeque<', 'Vec<', false),\n// <T::Balance as HasCompact>\ncleanupCompact(),\n// Change BoundedVec<Type, Size> to Vec<Type>\nremoveExtensions('Bounded', true),\n// Change WeakVec<Type> to Vec<Type>\nremoveExtensions('Weak', false),\n// Remove all the trait prefixes\nremoveTraits(),\n// remove PairOf<T> -> (T, T)\nremovePairOf(),\n// remove boxing, `Box<Proposal>` -> `Proposal`\nremoveWrap('Box<'),\n// remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\nremoveGenerics(),\n// alias String -> Text (compat with jsonrpc methods)\nalias('String', 'Text'),\n// alias Vec<u8> -> Bytes\nalias('Vec<u8>', 'Bytes'), alias('&\\\\[u8\\\\]', 'Bytes'), alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n// alias RawAddress -> Address\nalias('RawAddress', 'Address'),\n// lookups, mapped to Address/AccountId as appropriate in runtime\nalias('Lookup::Source', 'LookupSource'), alias('Lookup::Target', 'LookupTarget'),\n// HACK duplication between contracts & primitives, however contracts prefixed with exec\nalias('exec::StorageKey', 'ContractStorageKey'),\n// flattens tuples with one value, `(AccountId)` -> `AccountId`\nflattenSingleTuple(),\n// converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\nremoveColons(),\n// remove all trailing spaces - this should always be the last\ntrim()];\nexport function trim() {\n  return value => value.trim();\n}\nexport function findClosing(value, start) {\n  let depth = 0;\n  for (let index = start; index < value.length; index++) {\n    if (value[index] === '>') {\n      if (!depth) {\n        return index;\n      }\n      depth--;\n    } else if (value[index] === '<') {\n      depth++;\n    }\n  }\n  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\nexport function alias(src, dest) {\n  let withChecks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const from = new RegExp(`(^${src}|${BOX_PRECEDING.map(box => `\\\\${box}${src}`).join('|')})`, 'g');\n  const to = src => {\n    from.lastIndex = 0;\n    return withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest;\n  };\n  return value => value.replace(from, to);\n}\nexport function cleanupCompact() {\n  return value => {\n    if (value.includes(' as HasCompact')) {\n      for (let index = 0; index < value.length; index++) {\n        if (value[index] === '<') {\n          const end = findClosing(value, index + 1) - 14;\n          if (value.substring(end, end + 14) === ' as HasCompact') {\n            value = `Compact<${value.substring(index + 1, end)}>`;\n          }\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function flattenSingleTuple() {\n  const from1 = /,\\)/g;\n  const from2 = /\\(([^,]+)\\)/;\n  return value => {\n    from1.lastIndex = 0;\n    return value\n    // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n    .replace(from1, ')')\n    // change (u32) -> u32\n    .replace(from2, '$1');\n  };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n  let index = -1;\n  while (true) {\n    index = value.indexOf(matcher, index + 1);\n    if (index === -1) {\n      return value;\n    }\n    const start = index + matcher.length;\n    const end = findClosing(value, start);\n    value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;\n  }\n}\nexport function removeExtensions(type, isSized) {\n  return value => {\n    for (let i = 0; i < BOUNDED.length; i++) {\n      const tag = BOUNDED[i];\n      value = replaceTagWith(value, `${type}${tag}<`, v => {\n        const parts = v.split(',').map(s => s.trim()).filter(s => s);\n        if (isSized) {\n          parts.pop();\n        }\n        return `${tag}<${parts.join(',')}>`;\n      });\n    }\n    return value;\n  };\n}\nexport function removeColons() {\n  return value => {\n    let index = 0;\n    while (index !== -1) {\n      index = value.indexOf('::');\n      if (index === 0) {\n        value = value.substring(2);\n      } else if (index !== -1) {\n        let start = index;\n        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n          start--;\n        }\n        value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;\n      }\n    }\n    return value;\n  };\n}\nexport function removeGenerics() {\n  return value => {\n    for (let index = 0; index < value.length; index++) {\n      if (value[index] === '<') {\n        // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n        const box = ALLOWED_BOXES.find(box => {\n          const start = index - box.length;\n          return start >= 0 && value.substring(start, index) === box && (\n          // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n          start === 0 || BOX_PRECEDING.includes(value[start - 1]));\n        });\n        // we have not found anything, unwrap generic innards\n        if (!box) {\n          const end = findClosing(value, index + 1);\n          value = `${value.substring(0, index)}${value.substring(end + 1)}`;\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function removePairOf() {\n  const replacer = v => `(${v},${v})`;\n  return value => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n  const from1 = /\\s/g;\n  const from2 = /(T|Self)::/g;\n  const from3 = /<(T|Self)asTrait>::/g;\n  const from4 = /<Tas[a-z]+::Trait>::/g;\n  const from5 = /<LookupasStaticLookup>/g;\n  const from6 = /::Type/g;\n  return value => {\n    from1.lastIndex = 0;\n    from2.lastIndex = 0;\n    from3.lastIndex = 0;\n    from4.lastIndex = 0;\n    from5.lastIndex = 0;\n    from6.lastIndex = 0;\n    return value\n    // remove all whitespaces\n    .replace(from1, '')\n    // anything `T::<type>` to end up as `<type>`\n    .replace(from2, '')\n    // replace `<T as Trait>::` (whitespaces were removed above)\n    .replace(from3, '')\n    // replace `<T as something::Trait>::` (whitespaces were removed above)\n    .replace(from4, '')\n    // replace <Lookup as StaticLookup>\n    .replace(from5, 'Lookup')\n    // replace `<...>::Type`\n    .replace(from6, '');\n  };\n}\nexport function removeWrap(check) {\n  const replacer = v => v;\n  return value => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n  const startValue = value.toString();\n  const memoized = sanitizeMap.get(startValue);\n  if (memoized) {\n    return memoized;\n  }\n  let result = startValue;\n  for (let i = 0; i < mappings.length; i++) {\n    result = mappings[i](result);\n  }\n  sanitizeMap.set(startValue, result);\n  return result;\n}","map":{"version":3,"names":["BOUNDED","ALLOWED_BOXES","concat","BOX_PRECEDING","mappings","alias","cleanupCompact","removeExtensions","removeTraits","removePairOf","removeWrap","removeGenerics","flattenSingleTuple","removeColons","trim","value","findClosing","start","depth","index","length","Error","src","dest","withChecks","arguments","undefined","from","RegExp","map","box","join","to","lastIndex","includes","replace","end","substring","from1","from2","replaceTagWith","matcher","replacer","indexOf","type","isSized","i","tag","v","parts","split","s","filter","pop","find","from3","from4","from5","from6","check","sanitizeMap","Map","sanitize","startValue","toString","memoized","get","result","set"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/utils/sanitize.js"],"sourcesContent":["const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n    // alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\n    alias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false),\n    alias('VecDeque<', 'Vec<', false),\n    // <T::Balance as HasCompact>\n    cleanupCompact(),\n    // Change BoundedVec<Type, Size> to Vec<Type>\n    removeExtensions('Bounded', true),\n    // Change WeakVec<Type> to Vec<Type>\n    removeExtensions('Weak', false),\n    // Remove all the trait prefixes\n    removeTraits(),\n    // remove PairOf<T> -> (T, T)\n    removePairOf(),\n    // remove boxing, `Box<Proposal>` -> `Proposal`\n    removeWrap('Box<'),\n    // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\n    removeGenerics(),\n    // alias String -> Text (compat with jsonrpc methods)\n    alias('String', 'Text'),\n    // alias Vec<u8> -> Bytes\n    alias('Vec<u8>', 'Bytes'),\n    alias('&\\\\[u8\\\\]', 'Bytes'),\n    alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n    // alias RawAddress -> Address\n    alias('RawAddress', 'Address'),\n    // lookups, mapped to Address/AccountId as appropriate in runtime\n    alias('Lookup::Source', 'LookupSource'),\n    alias('Lookup::Target', 'LookupTarget'),\n    // HACK duplication between contracts & primitives, however contracts prefixed with exec\n    alias('exec::StorageKey', 'ContractStorageKey'),\n    // flattens tuples with one value, `(AccountId)` -> `AccountId`\n    flattenSingleTuple(),\n    // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\n    removeColons(),\n    // remove all trailing spaces - this should always be the last\n    trim()\n];\nexport function trim() {\n    return (value) => value.trim();\n}\nexport function findClosing(value, start) {\n    let depth = 0;\n    for (let index = start; index < value.length; index++) {\n        if (value[index] === '>') {\n            if (!depth) {\n                return index;\n            }\n            depth--;\n        }\n        else if (value[index] === '<') {\n            depth++;\n        }\n    }\n    throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\nexport function alias(src, dest, withChecks = true) {\n    const from = new RegExp(`(^${src}|${BOX_PRECEDING.map((box) => `\\\\${box}${src}`).join('|')})`, 'g');\n    const to = (src) => {\n        from.lastIndex = 0;\n        return withChecks && BOX_PRECEDING.includes(src[0])\n            ? `${src[0]}${dest}`\n            : dest;\n    };\n    return (value) => value.replace(from, to);\n}\nexport function cleanupCompact() {\n    return (value) => {\n        if (value.includes(' as HasCompact')) {\n            for (let index = 0; index < value.length; index++) {\n                if (value[index] === '<') {\n                    const end = findClosing(value, index + 1) - 14;\n                    if (value.substring(end, end + 14) === ' as HasCompact') {\n                        value = `Compact<${value.substring(index + 1, end)}>`;\n                    }\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function flattenSingleTuple() {\n    const from1 = /,\\)/g;\n    const from2 = /\\(([^,]+)\\)/;\n    return (value) => {\n        from1.lastIndex = 0;\n        return value\n            // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n            .replace(from1, ')')\n            // change (u32) -> u32\n            .replace(from2, '$1');\n    };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n    let index = -1;\n    while (true) {\n        index = value.indexOf(matcher, index + 1);\n        if (index === -1) {\n            return value;\n        }\n        const start = index + matcher.length;\n        const end = findClosing(value, start);\n        value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;\n    }\n}\nexport function removeExtensions(type, isSized) {\n    return (value) => {\n        for (let i = 0; i < BOUNDED.length; i++) {\n            const tag = BOUNDED[i];\n            value = replaceTagWith(value, `${type}${tag}<`, (v) => {\n                const parts = v\n                    .split(',')\n                    .map((s) => s.trim())\n                    .filter((s) => s);\n                if (isSized) {\n                    parts.pop();\n                }\n                return `${tag}<${parts.join(',')}>`;\n            });\n        }\n        return value;\n    };\n}\nexport function removeColons() {\n    return (value) => {\n        let index = 0;\n        while (index !== -1) {\n            index = value.indexOf('::');\n            if (index === 0) {\n                value = value.substring(2);\n            }\n            else if (index !== -1) {\n                let start = index;\n                while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n                    start--;\n                }\n                value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;\n            }\n        }\n        return value;\n    };\n}\nexport function removeGenerics() {\n    return (value) => {\n        for (let index = 0; index < value.length; index++) {\n            if (value[index] === '<') {\n                // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n                const box = ALLOWED_BOXES.find((box) => {\n                    const start = index - box.length;\n                    return ((start >= 0 &&\n                        value.substring(start, index) === box) && (\n                    // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n                    start === 0 ||\n                        BOX_PRECEDING.includes(value[start - 1])));\n                });\n                // we have not found anything, unwrap generic innards\n                if (!box) {\n                    const end = findClosing(value, index + 1);\n                    value = `${value.substring(0, index)}${value.substring(end + 1)}`;\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function removePairOf() {\n    const replacer = (v) => `(${v},${v})`;\n    return (value) => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n    const from1 = /\\s/g;\n    const from2 = /(T|Self)::/g;\n    const from3 = /<(T|Self)asTrait>::/g;\n    const from4 = /<Tas[a-z]+::Trait>::/g;\n    const from5 = /<LookupasStaticLookup>/g;\n    const from6 = /::Type/g;\n    return (value) => {\n        from1.lastIndex = 0;\n        from2.lastIndex = 0;\n        from3.lastIndex = 0;\n        from4.lastIndex = 0;\n        from5.lastIndex = 0;\n        from6.lastIndex = 0;\n        return value\n            // remove all whitespaces\n            .replace(from1, '')\n            // anything `T::<type>` to end up as `<type>`\n            .replace(from2, '')\n            // replace `<T as Trait>::` (whitespaces were removed above)\n            .replace(from3, '')\n            // replace `<T as something::Trait>::` (whitespaces were removed above)\n            .replace(from4, '')\n            // replace <Lookup as StaticLookup>\n            .replace(from5, 'Lookup')\n            // replace `<...>::Type`\n            .replace(from6, '');\n    };\n}\nexport function removeWrap(check) {\n    const replacer = (v) => v;\n    return (value) => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n    const startValue = value.toString();\n    const memoized = sanitizeMap.get(startValue);\n    if (memoized) {\n        return memoized;\n    }\n    let result = startValue;\n    for (let i = 0; i < mappings.length; i++) {\n        result = mappings[i](result);\n    }\n    sanitizeMap.set(startValue, result);\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}