{"ast":null,"code":"import { bnToBn, isBigInt, isBn, isFunction, isNumber, stringify } from '@polkadot/util';\n/** @internal **/\nfunction isArrayLike(arg) {\n  return arg instanceof Uint8Array || Array.isArray(arg);\n}\n/** @internal **/\nfunction isCodec(arg) {\n  return isFunction(arg && arg.toU8a);\n}\n/** @internal **/\nfunction isEnum(arg) {\n  return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);\n}\n/** @internal */\nfunction isNumberLike(arg) {\n  return isNumber(arg) || isBn(arg) || isBigInt(arg);\n}\n/** @internal */\nfunction sortArray(a, b) {\n  // Vec, Tuple, Bytes etc.\n  let sortRes = 0;\n  const minLen = Math.min(a.length, b.length);\n  for (let i = 0; i < minLen; ++i) {\n    sortRes = sortAsc(a[i], b[i]);\n    if (sortRes !== 0) {\n      return sortRes;\n    }\n  }\n  return a.length - b.length;\n}\n/**\n* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)\n*/\nexport function sortAsc(a, b) {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    return bnToBn(a).cmp(bnToBn(b));\n  } else if (a instanceof Map && b instanceof Map) {\n    return sortAsc(Array.from(a.values()), Array.from(b.values()));\n  } else if (isEnum(a) && isEnum(b)) {\n    return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);\n  } else if (isArrayLike(a) && isArrayLike(b)) {\n    return sortArray(a, b);\n  } else if (isCodec(a) && isCodec(b)) {\n    // Text, Bool etc.\n    return sortAsc(a.toU8a(true), b.toU8a(true));\n  }\n  throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);\n}\nexport function sortSet(set) {\n  return new Set(Array.from(set).sort(sortAsc));\n}\nexport function sortMap(map) {\n  return new Map(Array.from(map.entries()).sort((_ref, _ref2) => {\n    let [keyA] = _ref;\n    let [keyB] = _ref2;\n    return sortAsc(keyA, keyB);\n  }));\n}","map":{"version":3,"names":["bnToBn","isBigInt","isBn","isFunction","isNumber","stringify","isArrayLike","arg","Uint8Array","Array","isArray","isCodec","toU8a","isEnum","index","value","isNumberLike","sortArray","a","b","sortRes","minLen","Math","min","length","i","sortAsc","cmp","Map","from","values","Error","sortSet","set","Set","sort","sortMap","map","entries","_ref","_ref2","keyA","keyB"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/utils/sortValues.js"],"sourcesContent":["import { bnToBn, isBigInt, isBn, isFunction, isNumber, stringify } from '@polkadot/util';\n/** @internal **/\nfunction isArrayLike(arg) {\n    return arg instanceof Uint8Array || Array.isArray(arg);\n}\n/** @internal **/\nfunction isCodec(arg) {\n    return isFunction(arg && arg.toU8a);\n}\n/** @internal **/\nfunction isEnum(arg) {\n    return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);\n}\n/** @internal */\nfunction isNumberLike(arg) {\n    return isNumber(arg) || isBn(arg) || isBigInt(arg);\n}\n/** @internal */\nfunction sortArray(a, b) {\n    // Vec, Tuple, Bytes etc.\n    let sortRes = 0;\n    const minLen = Math.min(a.length, b.length);\n    for (let i = 0; i < minLen; ++i) {\n        sortRes = sortAsc(a[i], b[i]);\n        if (sortRes !== 0) {\n            return sortRes;\n        }\n    }\n    return a.length - b.length;\n}\n/**\n* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)\n*/\nexport function sortAsc(a, b) {\n    if (isNumberLike(a) && isNumberLike(b)) {\n        return bnToBn(a).cmp(bnToBn(b));\n    }\n    else if (a instanceof Map && b instanceof Map) {\n        return sortAsc(Array.from(a.values()), Array.from(b.values()));\n    }\n    else if (isEnum(a) && isEnum(b)) {\n        return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);\n    }\n    else if (isArrayLike(a) && isArrayLike(b)) {\n        return sortArray(a, b);\n    }\n    else if (isCodec(a) && isCodec(b)) {\n        // Text, Bool etc.\n        return sortAsc(a.toU8a(true), b.toU8a(true));\n    }\n    throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);\n}\nexport function sortSet(set) {\n    return new Set(Array.from(set).sort(sortAsc));\n}\nexport function sortMap(map) {\n    return new Map(Array.from(map.entries()).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}