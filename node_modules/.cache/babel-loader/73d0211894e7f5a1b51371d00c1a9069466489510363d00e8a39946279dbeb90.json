{"ast":null,"code":"var _Keyring_pairs, _Keyring_type, _Keyring_ss58;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { hexToU8a, isHex, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, ed25519PairFromSeed as ed25519FromSeed, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, secp256k1PairFromSeed as secp256k1FromSeed, sr25519PairFromSeed as sr25519FromSeed } from '@polkadot/util-crypto';\nimport { createPair } from './pair/index.js';\nimport { DEV_PHRASE } from './defaults.js';\nimport { Pairs } from './pairs.js';\nconst PairFromSeed = {\n  ecdsa: seed => secp256k1FromSeed(seed),\n  ed25519: seed => ed25519FromSeed(seed),\n  ethereum: seed => secp256k1FromSeed(seed),\n  sr25519: seed => sr25519FromSeed(seed)\n};\nfunction pairToPublic(_ref) {\n  let {\n    publicKey\n  } = _ref;\n  return publicKey;\n}\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\nexport class Keyring {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _Keyring_pairs.set(this, void 0);\n    _Keyring_type.set(this, void 0);\n    _Keyring_ss58.set(this, void 0);\n    this.decodeAddress = decodeAddress;\n    /**\n     * @name encodeAddress\n     * @description Encodes the input into an ss58 representation\n     */\n    this.encodeAddress = (address, ss58Format) => {\n      return this.type === 'ethereum' ? ethereumEncode(address) : encodeAddress(address, ss58Format === undefined ? __classPrivateFieldGet(this, _Keyring_ss58, \"f\") : ss58Format);\n    };\n    options.type = options.type || 'ed25519';\n    if (!['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined')) {\n      throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);\n    }\n    __classPrivateFieldSet(this, _Keyring_pairs, new Pairs(), \"f\");\n    __classPrivateFieldSet(this, _Keyring_ss58, options.ss58Format, \"f\");\n    __classPrivateFieldSet(this, _Keyring_type, options.type, \"f\");\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n  get pairs() {\n    return this.getPairs();\n  }\n  /**\n   * @description retrieve the publicKeys (alias for getPublicKeys)\n   */\n  get publicKeys() {\n    return this.getPublicKeys();\n  }\n  /**\n   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n   */\n  get type() {\n    return __classPrivateFieldGet(this, _Keyring_type, \"f\");\n  }\n  /**\n   * @name addPair\n   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   */\n  addPair(pair) {\n    return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").add(pair);\n  }\n  /**\n   * @name addFromAddress\n   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from them that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromAddress(address) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let encoded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.type;\n    let ignoreChecksum = arguments.length > 4 ? arguments[4] : undefined;\n    let encType = arguments.length > 5 ? arguments[5] : undefined;\n    const publicKey = this.decodeAddress(address, ignoreChecksum);\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, encoded, encType));\n  }\n  /**\n   * @name addFromJson\n   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromJson(json, ignoreChecksum) {\n    return this.addPair(this.createFromJson(json, ignoreChecksum));\n  }\n  /**\n   * @name addFromMnemonic\n   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n   * argument and a metadata argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromMnemonic(mnemonic) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    return this.addFromUri(mnemonic, meta, type);\n  }\n  /**\n   * @name addFromPair\n   * @summary Stores an account created from an explicit publicKey/secreteKey combination\n   */\n  addFromPair(pair) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    return this.addPair(this.createFromPair(pair, meta, type));\n  }\n  /**\n   * @name addFromSeed\n   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromSeed(seed) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, PairFromSeed[type](seed), meta, null));\n  }\n  /**\n   * @name addFromUri\n   * @summary Creates an account via an suri\n   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n   */\n  addFromUri(suri) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    return this.addPair(this.createFromUri(suri, meta, type));\n  }\n  /**\n   * @name createFromJson\n   * @description Creates a pair from a JSON keyfile\n   */\n  createFromJson(_ref2, ignoreChecksum) {\n    let {\n      address,\n      encoded,\n      encoding: {\n        content,\n        type,\n        version\n      },\n      meta\n    } = _ref2;\n    if (version === '3' && content[0] !== 'pkcs8') {\n      throw new Error(`Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);\n    }\n    const cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n    const encType = !Array.isArray(type) ? [type] : type;\n    if (!['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType)) {\n      throw new Error(`Unknown crypto type ${cryptoType}`);\n    }\n    // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n    const publicKey = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);\n    const decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, decoded, encType);\n  }\n  /**\n   * @name createFromPair\n   * @summary Creates a pair from an explicit publicKey/secreteKey combination\n   */\n  createFromPair(pair) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, pair, meta, null);\n  }\n  /**\n   * @name createFromUri\n   * @summary Creates a Keypair from an suri\n   * @description This creates a pair from the suri, but does not add it to the keyring\n   */\n  createFromUri(_suri) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    // here we only aut-add the dev phrase if we have a hard-derived path\n    const suri = _suri.startsWith('//') ? `${DEV_PHRASE}${_suri}` : _suri;\n    const {\n      derivePath,\n      password,\n      path,\n      phrase\n    } = keyExtractSuri(suri);\n    let seed;\n    const isPhraseHex = isHex(phrase, 256);\n    if (isPhraseHex) {\n      seed = hexToU8a(phrase);\n    } else {\n      const parts = phrase.split(' ');\n      if ([12, 15, 18, 21, 24].includes(parts.length)) {\n        seed = type === 'ethereum' ? mnemonicToLegacySeed(phrase, '', false, 64) : mnemonicToMiniSecret(phrase, password);\n      } else {\n        if (phrase.length > 32) {\n          throw new Error('specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n        }\n        seed = stringToU8a(phrase.padEnd(32));\n      }\n    }\n    const derived = type === 'ethereum' ? isPhraseHex ? PairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n    : hdEthereum(seed, derivePath.substring(1)) : keyFromPath(PairFromSeed[type](seed), path, type);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, derived, meta, null);\n  }\n  /**\n   * @name getPair\n   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n   * @description Returns a keyring pair value from the keyring pair dictionary by performing\n   * a key lookup using the provided account address or public key (after decoding it).\n   */\n  getPair(address) {\n    return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").get(address);\n  }\n  /**\n   * @name getPairs\n   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n   */\n  getPairs() {\n    return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").all();\n  }\n  /**\n   * @name getPublicKeys\n   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n   */\n  getPublicKeys() {\n    return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").all().map(pairToPublic);\n  }\n  /**\n   * @name removePair\n   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n   */\n  removePair(address) {\n    __classPrivateFieldGet(this, _Keyring_pairs, \"f\").remove(address);\n  }\n  /**\n   * @name setSS58Format;\n   * @description Sets the ss58 format for the keyring\n   */\n  setSS58Format(ss58) {\n    __classPrivateFieldSet(this, _Keyring_ss58, ss58, \"f\");\n  }\n  /**\n   * @name toJson\n   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n   * @description Returns a JSON object containing the metadata associated with an account\n   * when valid address or public key and when the account passphrase is provided if the account secret\n   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n   * may backup their account to a JSON file that contains this information.\n   */\n  toJson(address, passphrase) {\n    return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").get(address).toJson(passphrase);\n  }\n}\n_Keyring_pairs = new WeakMap(), _Keyring_type = new WeakMap(), _Keyring_ss58 = new WeakMap();","map":{"version":3,"names":["_Keyring_pairs","_Keyring_type","_Keyring_ss58","__classPrivateFieldGet","__classPrivateFieldSet","hexToU8a","isHex","stringToU8a","base64Decode","decodeAddress","ed25519PairFromSeed","ed25519FromSeed","encodeAddress","ethereumEncode","hdEthereum","keyExtractSuri","keyFromPath","mnemonicToLegacySeed","mnemonicToMiniSecret","secp256k1PairFromSeed","secp256k1FromSeed","sr25519PairFromSeed","sr25519FromSeed","createPair","DEV_PHRASE","Pairs","PairFromSeed","ecdsa","seed","ed25519","ethereum","sr25519","pairToPublic","_ref","publicKey","Keyring","constructor","options","arguments","length","undefined","set","address","ss58Format","type","includes","Error","pairs","getPairs","publicKeys","getPublicKeys","addPair","pair","add","addFromAddress","meta","encoded","ignoreChecksum","encType","toSS58","secretKey","Uint8Array","addFromJson","json","createFromJson","addFromMnemonic","mnemonic","addFromUri","addFromPair","createFromPair","addFromSeed","suri","createFromUri","_ref2","encoding","content","version","join","cryptoType","Array","isArray","decoded","_suri","startsWith","derivePath","password","path","phrase","isPhraseHex","parts","split","padEnd","derived","substring","getPair","get","all","map","removePair","remove","setSS58Format","ss58","toJson","passphrase","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/keyring/keyring.js"],"sourcesContent":["var _Keyring_pairs, _Keyring_type, _Keyring_ss58;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { hexToU8a, isHex, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, ed25519PairFromSeed as ed25519FromSeed, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, secp256k1PairFromSeed as secp256k1FromSeed, sr25519PairFromSeed as sr25519FromSeed } from '@polkadot/util-crypto';\nimport { createPair } from './pair/index.js';\nimport { DEV_PHRASE } from './defaults.js';\nimport { Pairs } from './pairs.js';\nconst PairFromSeed = {\n    ecdsa: (seed) => secp256k1FromSeed(seed),\n    ed25519: (seed) => ed25519FromSeed(seed),\n    ethereum: (seed) => secp256k1FromSeed(seed),\n    sr25519: (seed) => sr25519FromSeed(seed)\n};\nfunction pairToPublic({ publicKey }) {\n    return publicKey;\n}\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\nexport class Keyring {\n    constructor(options = {}) {\n        _Keyring_pairs.set(this, void 0);\n        _Keyring_type.set(this, void 0);\n        _Keyring_ss58.set(this, void 0);\n        this.decodeAddress = decodeAddress;\n        /**\n         * @name encodeAddress\n         * @description Encodes the input into an ss58 representation\n         */\n        this.encodeAddress = (address, ss58Format) => {\n            return this.type === 'ethereum'\n                ? ethereumEncode(address)\n                : encodeAddress(address, ss58Format === undefined ? __classPrivateFieldGet(this, _Keyring_ss58, \"f\") : ss58Format);\n        };\n        options.type = options.type || 'ed25519';\n        if (!['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined')) {\n            throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);\n        }\n        __classPrivateFieldSet(this, _Keyring_pairs, new Pairs(), \"f\");\n        __classPrivateFieldSet(this, _Keyring_ss58, options.ss58Format, \"f\");\n        __classPrivateFieldSet(this, _Keyring_type, options.type, \"f\");\n    }\n    /**\n     * @description retrieve the pairs (alias for getPairs)\n     */\n    get pairs() {\n        return this.getPairs();\n    }\n    /**\n     * @description retrieve the publicKeys (alias for getPublicKeys)\n     */\n    get publicKeys() {\n        return this.getPublicKeys();\n    }\n    /**\n     * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n     */\n    get type() {\n        return __classPrivateFieldGet(this, _Keyring_type, \"f\");\n    }\n    /**\n     * @name addPair\n     * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     */\n    addPair(pair) {\n        return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").add(pair);\n    }\n    /**\n     * @name addFromAddress\n     * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n     * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from them that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n        const publicKey = this.decodeAddress(address, ignoreChecksum);\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, { publicKey, secretKey: new Uint8Array() }, meta, encoded, encType));\n    }\n    /**\n     * @name addFromJson\n     * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromJson(json, ignoreChecksum) {\n        return this.addPair(this.createFromJson(json, ignoreChecksum));\n    }\n    /**\n     * @name addFromMnemonic\n     * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n     * argument and a metadata argument that contains account information (that may be obtained from the json file\n     * of an account backup), and then generates a keyring pair from it that it passes to\n     * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromMnemonic(mnemonic, meta = {}, type = this.type) {\n        return this.addFromUri(mnemonic, meta, type);\n    }\n    /**\n     * @name addFromPair\n     * @summary Stores an account created from an explicit publicKey/secreteKey combination\n     */\n    addFromPair(pair, meta = {}, type = this.type) {\n        return this.addPair(this.createFromPair(pair, meta, type));\n    }\n    /**\n     * @name addFromSeed\n     * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n     * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n     * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n     * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n     */\n    addFromSeed(seed, meta = {}, type = this.type) {\n        return this.addPair(createPair({ toSS58: this.encodeAddress, type }, PairFromSeed[type](seed), meta, null));\n    }\n    /**\n     * @name addFromUri\n     * @summary Creates an account via an suri\n     * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n     */\n    addFromUri(suri, meta = {}, type = this.type) {\n        return this.addPair(this.createFromUri(suri, meta, type));\n    }\n    /**\n     * @name createFromJson\n     * @description Creates a pair from a JSON keyfile\n     */\n    createFromJson({ address, encoded, encoding: { content, type, version }, meta }, ignoreChecksum) {\n        if (version === '3' && content[0] !== 'pkcs8') {\n            throw new Error(`Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);\n        }\n        const cryptoType = version === '0' || !Array.isArray(content)\n            ? this.type\n            : content[1];\n        const encType = !Array.isArray(type)\n            ? [type]\n            : type;\n        if (!['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType)) {\n            throw new Error(`Unknown crypto type ${cryptoType}`);\n        }\n        // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n        const publicKey = isHex(address)\n            ? hexToU8a(address)\n            : this.decodeAddress(address, ignoreChecksum);\n        const decoded = isHex(encoded)\n            ? hexToU8a(encoded)\n            : base64Decode(encoded);\n        return createPair({ toSS58: this.encodeAddress, type: cryptoType }, { publicKey, secretKey: new Uint8Array() }, meta, decoded, encType);\n    }\n    /**\n     * @name createFromPair\n     * @summary Creates a pair from an explicit publicKey/secreteKey combination\n     */\n    createFromPair(pair, meta = {}, type = this.type) {\n        return createPair({ toSS58: this.encodeAddress, type }, pair, meta, null);\n    }\n    /**\n     * @name createFromUri\n     * @summary Creates a Keypair from an suri\n     * @description This creates a pair from the suri, but does not add it to the keyring\n     */\n    createFromUri(_suri, meta = {}, type = this.type) {\n        // here we only aut-add the dev phrase if we have a hard-derived path\n        const suri = _suri.startsWith('//')\n            ? `${DEV_PHRASE}${_suri}`\n            : _suri;\n        const { derivePath, password, path, phrase } = keyExtractSuri(suri);\n        let seed;\n        const isPhraseHex = isHex(phrase, 256);\n        if (isPhraseHex) {\n            seed = hexToU8a(phrase);\n        }\n        else {\n            const parts = phrase.split(' ');\n            if ([12, 15, 18, 21, 24].includes(parts.length)) {\n                seed = type === 'ethereum'\n                    ? mnemonicToLegacySeed(phrase, '', false, 64)\n                    : mnemonicToMiniSecret(phrase, password);\n            }\n            else {\n                if (phrase.length > 32) {\n                    throw new Error('specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n                }\n                seed = stringToU8a(phrase.padEnd(32));\n            }\n        }\n        const derived = type === 'ethereum'\n            ? isPhraseHex\n                ? PairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n                : hdEthereum(seed, derivePath.substring(1))\n            : keyFromPath(PairFromSeed[type](seed), path, type);\n        return createPair({ toSS58: this.encodeAddress, type }, derived, meta, null);\n    }\n    /**\n     * @name getPair\n     * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n     * @description Returns a keyring pair value from the keyring pair dictionary by performing\n     * a key lookup using the provided account address or public key (after decoding it).\n     */\n    getPair(address) {\n        return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").get(address);\n    }\n    /**\n     * @name getPairs\n     * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n     * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPairs() {\n        return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").all();\n    }\n    /**\n     * @name getPublicKeys\n     * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n     * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n     */\n    getPublicKeys() {\n        return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").all().map(pairToPublic);\n    }\n    /**\n     * @name removePair\n     * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n     */\n    removePair(address) {\n        __classPrivateFieldGet(this, _Keyring_pairs, \"f\").remove(address);\n    }\n    /**\n     * @name setSS58Format;\n     * @description Sets the ss58 format for the keyring\n     */\n    setSS58Format(ss58) {\n        __classPrivateFieldSet(this, _Keyring_ss58, ss58, \"f\");\n    }\n    /**\n     * @name toJson\n     * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n     * @description Returns a JSON object containing the metadata associated with an account\n     * when valid address or public key and when the account passphrase is provided if the account secret\n     * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n     * may backup their account to a JSON file that contains this information.\n     */\n    toJson(address, passphrase) {\n        return __classPrivateFieldGet(this, _Keyring_pairs, \"f\").get(address).toJson(passphrase);\n    }\n}\n_Keyring_pairs = new WeakMap(), _Keyring_type = new WeakMap(), _Keyring_ss58 = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}