{"ast":null,"code":"var _Text_override;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactAddLength, compactFromU8aLim, compactToU8a, hexToU8a, isHex, isString, isU8a, stringToU8a, u8aToHex, u8aToString } from '@polkadot/util';\nimport { Raw } from './Raw.js';\nconst MAX_LENGTH = 128 * 1024;\n/** @internal */\nfunction decodeText(value) {\n  if (isU8a(value)) {\n    if (!value.length) {\n      return ['', 0];\n    }\n    // for Raw, the internal buffer does not have an internal length\n    // (the same applies in e.g. Bytes, where length is added at encoding-time)\n    if (value instanceof Raw) {\n      return [u8aToString(value), 0];\n    }\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + length;\n    if (length > MAX_LENGTH) {\n      throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    } else if (total > value.length) {\n      throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [u8aToString(value.subarray(offset, total)), total];\n  } else if (isHex(value)) {\n    return [u8aToString(hexToU8a(value)), 0];\n  }\n  return [value ? value.toString() : '', 0];\n}\n/**\n * @name Text\n * @description\n * This is a string wrapper, along with the length. It is used both for strings as well\n * as items such as documentation. It simply extends the standard JS `String` built-in\n * object, inheriting all methods exposed from `String`.\n * @noInheritDoc\n */\nexport class Text extends String {\n  constructor(registry, value) {\n    const [str, decodedLength] = decodeText(value);\n    super(str);\n    _Text_override.set(this, null);\n    this.registry = registry;\n    this.initialU8aLength = decodedLength;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return isString(other) ? this.toString() === other.toString() : false;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const value = stringToU8a(super.toString());\n    return {\n      outer: value.length ? [compactToU8a(value.length), value] : [compactToU8a(value.length)]\n    };\n  }\n  /**\n   * @description Set an override value for this\n   */\n  setOverride(override) {\n    __classPrivateFieldSet(this, _Text_override, override, \"f\");\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    // like with Vec<u8>, when we are encoding to hex, we don't actually add\n    // the length prefix (it is already implied by the actual string length)\n    return u8aToHex(this.toU8a(true));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toJSON();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toJSON();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Text';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return __classPrivateFieldGet(this, _Text_override, \"f\") || super.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    // NOTE Here we use the super toString (we are not taking overrides into account,\n    // rather encoding the original value the string was constructed with)\n    const encoded = stringToU8a(super.toString());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n}\n_Text_override = new WeakMap();","map":{"version":3,"names":["_Text_override","__classPrivateFieldGet","__classPrivateFieldSet","compactAddLength","compactFromU8aLim","compactToU8a","hexToU8a","isHex","isString","isU8a","stringToU8a","u8aToHex","u8aToString","Raw","MAX_LENGTH","decodeText","value","length","offset","total","Error","toString","subarray","Text","String","constructor","registry","str","decodedLength","set","initialU8aLength","encodedLength","toU8a","hash","isEmpty","eq","other","inspect","outer","setOverride","override","toHex","toHuman","toJSON","toPrimitive","toRawType","isBare","encoded","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/native/Text.js"],"sourcesContent":["var _Text_override;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactAddLength, compactFromU8aLim, compactToU8a, hexToU8a, isHex, isString, isU8a, stringToU8a, u8aToHex, u8aToString } from '@polkadot/util';\nimport { Raw } from './Raw.js';\nconst MAX_LENGTH = 128 * 1024;\n/** @internal */\nfunction decodeText(value) {\n    if (isU8a(value)) {\n        if (!value.length) {\n            return ['', 0];\n        }\n        // for Raw, the internal buffer does not have an internal length\n        // (the same applies in e.g. Bytes, where length is added at encoding-time)\n        if (value instanceof Raw) {\n            return [u8aToString(value), 0];\n        }\n        const [offset, length] = compactFromU8aLim(value);\n        const total = offset + length;\n        if (length > MAX_LENGTH) {\n            throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);\n        }\n        else if (total > value.length) {\n            throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);\n        }\n        return [u8aToString(value.subarray(offset, total)), total];\n    }\n    else if (isHex(value)) {\n        return [u8aToString(hexToU8a(value)), 0];\n    }\n    return [value ? value.toString() : '', 0];\n}\n/**\n * @name Text\n * @description\n * This is a string wrapper, along with the length. It is used both for strings as well\n * as items such as documentation. It simply extends the standard JS `String` built-in\n * object, inheriting all methods exposed from `String`.\n * @noInheritDoc\n */\nexport class Text extends String {\n    constructor(registry, value) {\n        const [str, decodedLength] = decodeText(value);\n        super(str);\n        _Text_override.set(this, null);\n        this.registry = registry;\n        this.initialU8aLength = decodedLength;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * @description The length of the value\n     */\n    get length() {\n        // only included here since we ignore inherited docs\n        return super.length;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return isString(other)\n            ? this.toString() === other.toString()\n            : false;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const value = stringToU8a(super.toString());\n        return {\n            outer: value.length\n                ? [compactToU8a(value.length), value]\n                : [compactToU8a(value.length)]\n        };\n    }\n    /**\n     * @description Set an override value for this\n     */\n    setOverride(override) {\n        __classPrivateFieldSet(this, _Text_override, override, \"f\");\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        // like with Vec<u8>, when we are encoding to hex, we don't actually add\n        // the length prefix (it is already implied by the actual string length)\n        return u8aToHex(this.toU8a(true));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Text';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return __classPrivateFieldGet(this, _Text_override, \"f\") || super.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        // NOTE Here we use the super toString (we are not taking overrides into account,\n        // rather encoding the original value the string was constructed with)\n        const encoded = stringToU8a(super.toString());\n        return isBare\n            ? encoded\n            : compactAddLength(encoded);\n    }\n}\n_Text_override = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}