{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { Enum } from '@polkadot/types';\nimport { isFunction, objectSpread, stringToHex } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nconst DEMOCRACY_ID = stringToHex('democrac');\nfunction isMaybeHashedOrBounded(call) {\n  // check for enum\n  return call instanceof Enum;\n}\nfunction isBounded(call) {\n  // check for type\n  return call.isInline || call.isLegacy || call.isLookup;\n}\nfunction queryQueue(api) {\n  return api.query.democracy.dispatchQueue().pipe(switchMap(dispatches => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(_ref => {\n    let [, hash] = _ref;\n    return hash;\n  }))])), map(_ref2 => {\n    let [dispatches, images] = _ref2;\n    return dispatches.map((_ref3, dispatchIndex) => {\n      let [at, imageHash, index] = _ref3;\n      return {\n        at,\n        image: images[dispatchIndex],\n        imageHash: getImageHashBounded(imageHash),\n        index\n      };\n    });\n  }));\n}\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap(keys => {\n    const blockNumbers = keys.map(_ref4 => {\n      let {\n        args: [blockNumber]\n      } = _ref4;\n      return blockNumber;\n    });\n    return blockNumbers.length ? combineLatest([of(blockNumbers),\n    // this should simply be api.query.scheduler.agenda.multi,\n    // however we have had cases on Darwinia where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    api.query.scheduler.agenda.multi(blockNumbers).pipe(catchError(() => of(blockNumbers.map(() => []))))]) : of([[], []]);\n  }));\n}\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(_ref5 => {\n    let [blockNumbers, agendas] = _ref5;\n    const result = [];\n    blockNumbers.forEach((at, index) => {\n      (agendas[index] || []).filter(o => o.isSome).forEach(o => {\n        const scheduled = o.unwrap();\n        if (scheduled.maybeId.isSome) {\n          const id = scheduled.maybeId.unwrap().toHex();\n          if (id.startsWith(DEMOCRACY_ID)) {\n            const imageHash = isMaybeHashedOrBounded(scheduled.call) ? isBounded(scheduled.call) ? getImageHashBounded(scheduled.call) : scheduled.call.isHash ? scheduled.call.asHash.toHex() : scheduled.call.asValue.args[0].toHex() : scheduled.call.args[0].toHex();\n            result.push({\n              at,\n              imageHash,\n              index: api.registry.createType('(u64, ReferendumIndex)', id)[1]\n            });\n          }\n        }\n      });\n    });\n    return combineLatest([of(result), result.length ? api.derive.democracy.preimages(result.map(_ref6 => {\n      let {\n        imageHash\n      } = _ref6;\n      return imageHash;\n    })) : of([])]);\n  }), map(_ref7 => {\n    let [infos, images] = _ref7;\n    return infos.map((info, index) => objectSpread({\n      image: images[index]\n    }, info));\n  }));\n}\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, () => isFunction(api.query.scheduler?.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : of([]));\n}","map":{"version":3,"names":["catchError","combineLatest","map","of","switchMap","Enum","isFunction","objectSpread","stringToHex","memo","getImageHashBounded","DEMOCRACY_ID","isMaybeHashedOrBounded","call","isBounded","isInline","isLegacy","isLookup","queryQueue","api","query","democracy","dispatchQueue","pipe","dispatches","derive","preimages","_ref","hash","_ref2","images","_ref3","dispatchIndex","at","imageHash","index","image","schedulerEntries","referendumsFinished","scheduler","agenda","keys","blockNumbers","_ref4","args","blockNumber","length","multi","queryScheduler","_ref5","agendas","result","forEach","filter","o","isSome","scheduled","unwrap","maybeId","id","toHex","startsWith","isHash","asHash","asValue","push","registry","createType","_ref6","_ref7","infos","info","instanceId"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api-derive/democracy/dispatchQueue.js"],"sourcesContent":["import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { Enum } from '@polkadot/types';\nimport { isFunction, objectSpread, stringToHex } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nconst DEMOCRACY_ID = stringToHex('democrac');\nfunction isMaybeHashedOrBounded(call) {\n    // check for enum\n    return call instanceof Enum;\n}\nfunction isBounded(call) {\n    // check for type\n    return call.isInline || call.isLegacy || call.isLookup;\n}\nfunction queryQueue(api) {\n    return api.query.democracy.dispatchQueue().pipe(switchMap((dispatches) => combineLatest([\n        of(dispatches),\n        api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))\n    ])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n        at,\n        image: images[dispatchIndex],\n        imageHash: getImageHashBounded(imageHash),\n        index\n    }))));\n}\nfunction schedulerEntries(api) {\n    // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n    // the subscribe to those keys - this means we pickup when the schedulers actually executes\n    // at a block, the entry for that block will become empty\n    return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap((keys) => {\n        const blockNumbers = keys.map(({ args: [blockNumber] }) => blockNumber);\n        return blockNumbers.length\n            ? combineLatest([\n                of(blockNumbers),\n                // this should simply be api.query.scheduler.agenda.multi,\n                // however we have had cases on Darwinia where the indices have moved around after an\n                // upgrade, which results in invalid on-chain data\n                api.query.scheduler.agenda.multi(blockNumbers).pipe(catchError(() => of(blockNumbers.map(() => []))))\n            ])\n            : of([[], []]);\n    }));\n}\nfunction queryScheduler(api) {\n    return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n        const result = [];\n        blockNumbers.forEach((at, index) => {\n            (agendas[index] || []).filter((o) => o.isSome).forEach((o) => {\n                const scheduled = o.unwrap();\n                if (scheduled.maybeId.isSome) {\n                    const id = scheduled.maybeId.unwrap().toHex();\n                    if (id.startsWith(DEMOCRACY_ID)) {\n                        const imageHash = isMaybeHashedOrBounded(scheduled.call)\n                            ? isBounded(scheduled.call)\n                                ? getImageHashBounded(scheduled.call)\n                                : scheduled.call.isHash\n                                    ? scheduled.call.asHash.toHex()\n                                    : scheduled.call.asValue.args[0].toHex()\n                            : scheduled.call.args[0].toHex();\n                        result.push({ at, imageHash, index: api.registry.createType('(u64, ReferendumIndex)', id)[1] });\n                    }\n                }\n            });\n        });\n        return combineLatest([\n            of(result),\n            result.length\n                ? api.derive.democracy.preimages(result.map(({ imageHash }) => imageHash))\n                : of([])\n        ]);\n    }), map(([infos, images]) => infos.map((info, index) => objectSpread({ image: images[index] }, info))));\n}\nexport function dispatchQueue(instanceId, api) {\n    return memo(instanceId, () => isFunction(api.query.scheduler?.agenda)\n        ? queryScheduler(api)\n        : api.query.democracy.dispatchQueue\n            ? queryQueue(api)\n            : of([]));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}