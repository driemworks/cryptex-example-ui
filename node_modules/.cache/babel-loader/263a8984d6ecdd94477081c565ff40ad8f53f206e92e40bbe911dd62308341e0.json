{"ast":null,"code":"import { Struct, U8aFixed } from '@polkadot/types-codec';\nimport { isHex, isObject, isU8a, objectSpread, u8aToU8a } from '@polkadot/util';\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  return meta.fields.reduce((result, _ref, index) => {\n    let {\n      name,\n      type\n    } = _ref;\n    result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n    return result;\n  }, {});\n}\n/** @internal */\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value;\n  // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex;\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = registry.firstCallIndex.slice();\n  callIndex.set(value.subarray(0, 2), 0);\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\nfunction decodeCall(registry) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array();\n  let _meta = arguments.length > 2 ? arguments[2] : undefined;\n  if (isU8a(value) || isHex(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\nexport class GenericCallIndex extends U8aFixed {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toHex();\n  }\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\nexport class GenericCall extends Struct {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n    try {\n      super(registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n    } catch (error) {\n      let method = 'unknown.unknown';\n      try {\n        const c = registry.findMetaCall(decoded.callIndex);\n        method = `${c.section}.${c.method}`;\n      } catch {\n        // ignore\n      }\n      throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n    }\n    this._meta = decoded.meta;\n  }\n  /**\n   * @description The arguments for the function call\n   */\n  get args() {\n    return [...this.getT('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The argument entries\n   */\n  get argsEntries() {\n    return [...this.getT('args').entries()];\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n  get callIndex() {\n    return this.getT('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n  get data() {\n    return this.getT('args').toU8a();\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n  get method() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n  get section() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n  is(other) {\n    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExpanded) {\n    let call;\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch {\n      // swallow\n    }\n    return objectSpread({\n      args: this.argsEntries.reduce((args, _ref2) => {\n        let [n, a] = _ref2;\n        return objectSpread(args, {\n          [n]: a.toHuman(isExpanded)\n        });\n      }, {}),\n      method: call?.method,\n      section: call?.section\n    }, isExpanded && call ? {\n      docs: call.meta.docs.map(d => d.toString())\n    } : null);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Call';\n  }\n}","map":{"version":3,"names":["Struct","U8aFixed","isHex","isObject","isU8a","objectSpread","u8aToU8a","getArgsDef","registry","meta","fields","reduce","result","_ref","index","name","type","unwrapOr","toString","createLookupType","decodeCallViaObject","value","_meta","args","callIndex","lookupIndex","GenericCallIndex","toU8a","findMetaCall","argsDef","decodeCallViaU8a","firstCallIndex","slice","set","subarray","decodeCall","arguments","length","undefined","Uint8Array","Error","constructor","toPrimitive","toHex","GenericCall","decoded","with","error","method","c","section","message","getT","values","argsEntries","entries","data","is","other","toHuman","isExpanded","call","_ref2","n","a","docs","map","d","toRawType"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/generic/Call.js"],"sourcesContent":["import { Struct, U8aFixed } from '@polkadot/types-codec';\nimport { isHex, isObject, isU8a, objectSpread, u8aToU8a } from '@polkadot/util';\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n    return meta.fields.reduce((result, { name, type }, index) => {\n        result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n        return result;\n    }, {});\n}\n/** @internal */\nfunction decodeCallViaObject(registry, value, _meta) {\n    // we only pass args/methodsIndex out\n    const { args, callIndex } = value;\n    // Get the correct lookupIndex\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const lookupIndex = callIndex instanceof GenericCallIndex\n        ? callIndex.toU8a()\n        : callIndex;\n    // Find metadata with callIndex\n    const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n    return {\n        args,\n        argsDef: getArgsDef(registry, meta),\n        callIndex,\n        meta\n    };\n}\n/** @internal */\nfunction decodeCallViaU8a(registry, value, _meta) {\n    // We need 2 bytes for the callIndex\n    const callIndex = registry.firstCallIndex.slice();\n    callIndex.set(value.subarray(0, 2), 0);\n    // Find metadata with callIndex\n    const meta = _meta || registry.findMetaCall(callIndex).meta;\n    return {\n        args: value.subarray(2),\n        argsDef: getArgsDef(registry, meta),\n        callIndex,\n        meta\n    };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n    if (isU8a(value) || isHex(value)) {\n        return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n    }\n    else if (isObject(value) && value.callIndex && value.args) {\n        return decodeCallViaObject(registry, value, _meta);\n    }\n    throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\nexport class GenericCallIndex extends U8aFixed {\n    constructor(registry, value) {\n        super(registry, value, 16);\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toHex();\n    }\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\nexport class GenericCall extends Struct {\n    constructor(registry, value, meta) {\n        const decoded = decodeCall(registry, value, meta);\n        try {\n            super(registry, {\n                callIndex: GenericCallIndex,\n                // eslint-disable-next-line sort-keys\n                args: Struct.with(decoded.argsDef)\n            }, decoded);\n        }\n        catch (error) {\n            let method = 'unknown.unknown';\n            try {\n                const c = registry.findMetaCall(decoded.callIndex);\n                method = `${c.section}.${c.method}`;\n            }\n            catch {\n                // ignore\n            }\n            throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n        }\n        this._meta = decoded.meta;\n    }\n    /**\n     * @description The arguments for the function call\n     */\n    get args() {\n        return [...this.getT('args').values()];\n    }\n    /**\n     * @description The argument definitions\n     */\n    get argsDef() {\n        return getArgsDef(this.registry, this.meta);\n    }\n    /**\n     * @description The argument entries\n     */\n    get argsEntries() {\n        return [...this.getT('args').entries()];\n    }\n    /**\n     * @description The encoded `[sectionIndex, methodIndex]` identifier\n     */\n    get callIndex() {\n        return this.getT('callIndex').toU8a();\n    }\n    /**\n     * @description The encoded data\n     */\n    get data() {\n        return this.getT('args').toU8a();\n    }\n    /**\n     * @description The [[FunctionMetadata]]\n     */\n    get meta() {\n        return this._meta;\n    }\n    /**\n     * @description Returns the name of the method\n     */\n    get method() {\n        return this.registry.findMetaCall(this.callIndex).method;\n    }\n    /**\n     * @description Returns the module containing the method\n     */\n    get section() {\n        return this.registry.findMetaCall(this.callIndex).section;\n    }\n    /**\n     * @description Checks if the source matches this in type\n     */\n    is(other) {\n        return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExpanded) {\n        let call;\n        try {\n            call = this.registry.findMetaCall(this.callIndex);\n        }\n        catch {\n            // swallow\n        }\n        return objectSpread({\n            args: this.argsEntries.reduce((args, [n, a]) => objectSpread(args, { [n]: a.toHuman(isExpanded) }), {}),\n            method: call?.method,\n            section: call?.section\n        }, isExpanded && call\n            ? { docs: call.meta.docs.map((d) => d.toString()) }\n            : null);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Call';\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}