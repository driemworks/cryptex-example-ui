{"ast":null,"code":"var _ScProvider_Sc, _ScProvider_coder, _ScProvider_spec, _ScProvider_sharedSandbox, _ScProvider_subscriptions, _ScProvider_resubscribeMethods, _ScProvider_requests, _ScProvider_wellKnownChains, _ScProvider_eventemitter, _ScProvider_chain, _ScProvider_isChainReady, _ScProvider_resubscribe;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'], ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'], ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'], ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'], ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'], ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'], ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'], ['subscribe_newHead', 'unsubscribe_newHead'], ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'], ['state_subscribeStorage', 'state_unsubscribeStorage']]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n  constructor(Sc, spec, sharedSandbox) {\n    _ScProvider_Sc.set(this, void 0);\n    _ScProvider_coder.set(this, new RpcCoder());\n    _ScProvider_spec.set(this, void 0);\n    _ScProvider_sharedSandbox.set(this, void 0);\n    _ScProvider_subscriptions.set(this, new Map());\n    _ScProvider_resubscribeMethods.set(this, new Map());\n    _ScProvider_requests.set(this, new Map());\n    _ScProvider_wellKnownChains.set(this, void 0);\n    _ScProvider_eventemitter.set(this, new EventEmitter());\n    _ScProvider_chain.set(this, null);\n    _ScProvider_isChainReady.set(this, false);\n    _ScProvider_resubscribe.set(this, () => {\n      const promises = [];\n      __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").forEach(subDetails => {\n        // only re-create subscriptions which are not in author (only area where\n        // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n        // are not included (and will not be re-broadcast)\n        if (subDetails.type.startsWith('author_')) {\n          return;\n        }\n        try {\n          const promise = new Promise(resolve => {\n            this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch(error => console.log(error));\n            resolve();\n          });\n          promises.push(promise);\n        } catch (error) {\n          l.error(error);\n        }\n      });\n      Promise.all(promises).catch(err => l.log(err));\n    });\n    if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n      throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n    }\n    __classPrivateFieldSet(this, _ScProvider_Sc, Sc, \"f\");\n    __classPrivateFieldSet(this, _ScProvider_spec, spec, \"f\");\n    __classPrivateFieldSet(this, _ScProvider_sharedSandbox, sharedSandbox, \"f\");\n    __classPrivateFieldSet(this, _ScProvider_wellKnownChains, new Set(Object.values(Sc.WellKnownChain)), \"f\");\n  }\n  get hasSubscriptions() {\n    // Indicates that subscriptions are supported\n    return true;\n  }\n  get isClonable() {\n    return false;\n  }\n  get isConnected() {\n    return !!__classPrivateFieldGet(this, _ScProvider_chain, \"f\") && __classPrivateFieldGet(this, _ScProvider_isChainReady, \"f\");\n  }\n  clone() {\n    throw new Error('clone() is not supported.');\n  }\n  // Config details can be found in @substrate/connect repo following the link:\n  // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n  async connect(config) {\n    let checkerFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : healthChecker;\n    if (this.isConnected) {\n      throw new Error('Already connected!');\n    }\n    // it could happen that after emitting `disconnected` due to the fact taht\n    // smoldot is syncing, the consumer tries to reconnect after a certain amount\n    // of time... In which case we want to make sure that we don't create a new\n    // chain.\n    if (__classPrivateFieldGet(this, _ScProvider_chain, \"f\")) {\n      await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n      return;\n    }\n    if (__classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\") && !__classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\").isConnected) {\n      await __classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\").connect();\n    }\n    const client = __classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\") ? scClients.get(__classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\")) : __classPrivateFieldGet(this, _ScProvider_Sc, \"f\").createScClient(config);\n    if (!client) {\n      throw new Error('Unkown ScProvider!');\n    }\n    scClients.set(this, client);\n    const hc = checkerFactory();\n    const onResponse = res => {\n      const hcRes = hc.responsePassThrough(res);\n      if (!hcRes) {\n        return;\n      }\n      const response = JSON.parse(hcRes);\n      let decodedResponse;\n      try {\n        decodedResponse = __classPrivateFieldGet(this, _ScProvider_coder, \"f\").decodeResponse(response);\n      } catch (e) {\n        decodedResponse = e;\n      }\n      // It's not a subscription message, but rather a standar RPC response\n      if (response.params?.subscription === undefined || !response.method) {\n        return __classPrivateFieldGet(this, _ScProvider_requests, \"f\").get(response.id)?.(decodedResponse);\n      }\n      // We are dealing with a subscription message\n      const subscriptionId = `${response.method}::${response.params.subscription}`;\n      const callback = __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").get(subscriptionId)?.[0];\n      callback?.(decodedResponse);\n    };\n    const addChain = __classPrivateFieldGet(this, _ScProvider_wellKnownChains, \"f\").has(__classPrivateFieldGet(this, _ScProvider_spec, \"f\")) ? client.addWellKnownChain : client.addChain;\n    __classPrivateFieldSet(this, _ScProvider_chain, addChain(__classPrivateFieldGet(this, _ScProvider_spec, \"f\"), onResponse).then(chain => {\n      hc.setSendJsonRpc(chain.sendJsonRpc);\n      __classPrivateFieldSet(this, _ScProvider_isChainReady, false, \"f\");\n      const cleanup = () => {\n        // If there are any callbacks left, we have to reject/error them.\n        // Otherwise, that would cause a memory leak.\n        const disconnectionError = new Error('Disconnected');\n        __classPrivateFieldGet(this, _ScProvider_requests, \"f\").forEach(cb => cb(disconnectionError));\n        __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").forEach(_ref => {\n          let [cb] = _ref;\n          return cb(disconnectionError);\n        });\n        __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").clear();\n      };\n      const staleSubscriptions = [];\n      const killStaleSubscriptions = () => {\n        if (staleSubscriptions.length === 0) {\n          return;\n        }\n        const stale = staleSubscriptions.pop();\n        if (!stale) {\n          throw new Error('Unable to get stale subscription');\n        }\n        const {\n          id,\n          unsubscribeMethod\n        } = stale;\n        Promise.race([this.send(unsubscribeMethod, [id]).catch(() => undefined), new Promise(resolve => setTimeout(resolve, 500))]).then(killStaleSubscriptions).catch(() => undefined);\n      };\n      hc.start(health => {\n        const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n        // if it's the same as before, then nothing has changed and we are done\n        if (__classPrivateFieldGet(this, _ScProvider_isChainReady, \"f\") === isReady) {\n          return;\n        }\n        __classPrivateFieldSet(this, _ScProvider_isChainReady, isReady, \"f\");\n        if (!isReady) {\n          // If we've reached this point, that means that the chain used to be \"ready\"\n          // and now we are about to emit `disconnected`.\n          //\n          // This will cause the PolkadotJs API think that the connection is\n          // actually dead. In reality the smoldot chain is not dead, of course.\n          // However, we have to cleanup all the existing callbacks because when\n          // the smoldot chain stops syncing, then we will emit `connected` and\n          // the PolkadotJs API will try to re-create the previous\n          // subscriptions and requests. Although, now is not a good moment\n          // to be sending unsubscription messages to the smoldot chain, we\n          // should wait until is no longer syncing to send the unsubscription\n          // messages from the stale subscriptions of the previous connection.\n          //\n          // That's why -before we perform the cleanup of `this.#subscriptions`-\n          // we keep the necessary information that we will need later on to\n          // kill the stale subscriptions.\n          [...__classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").values()].forEach(s => {\n            staleSubscriptions.push(s[1]);\n          });\n          cleanup();\n          __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('disconnected');\n        } else {\n          killStaleSubscriptions();\n          __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('connected');\n          if (__classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").size) {\n            __classPrivateFieldGet(this, _ScProvider_resubscribe, \"f\").call(this);\n          }\n        }\n      });\n      return objectSpread({}, chain, {\n        remove: () => {\n          hc.stop();\n          chain.remove();\n          cleanup();\n        },\n        sendJsonRpc: hc.sendJsonRpc.bind(hc)\n      });\n    }), \"f\");\n    try {\n      await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n    } catch (e) {\n      __classPrivateFieldSet(this, _ScProvider_chain, null, \"f\");\n      __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('error', e);\n      throw e;\n    }\n  }\n  async disconnect() {\n    if (!__classPrivateFieldGet(this, _ScProvider_chain, \"f\")) {\n      return;\n    }\n    const chain = await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n    __classPrivateFieldSet(this, _ScProvider_chain, null, \"f\");\n    __classPrivateFieldSet(this, _ScProvider_isChainReady, false, \"f\");\n    try {\n      chain.remove();\n    } catch (_) {}\n    __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('disconnected');\n  }\n  on(type, sub) {\n    // It's possible. Although, quite unlikely, that by the time that polkadot\n    // subscribes to the `connected` event, the Provider is already connected.\n    // In that case, we must emit to let the consumer know that we are connected.\n    if (type === 'connected' && this.isConnected) {\n      sub();\n    }\n    __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").on(type, sub);\n    return () => {\n      __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").removeListener(type, sub);\n    };\n  }\n  async send(method, params) {\n    if (!this.isConnected || !__classPrivateFieldGet(this, _ScProvider_chain, \"f\")) {\n      throw new Error('Provider is not connected');\n    }\n    const chain = await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n    const [id, json] = __classPrivateFieldGet(this, _ScProvider_coder, \"f\").encodeJson(method, params);\n    const result = new Promise((resolve, reject) => {\n      __classPrivateFieldGet(this, _ScProvider_requests, \"f\").set(id, response => {\n        (isError(response) ? reject : resolve)(response);\n      });\n      try {\n        chain.sendJsonRpc(json);\n      } catch (e) {\n        __classPrivateFieldSet(this, _ScProvider_chain, null, \"f\");\n        try {\n          chain.remove();\n        } catch (_) {}\n        __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('error', e);\n      }\n    });\n    try {\n      return await result;\n    } finally {\n      // let's ensure that once the Promise is resolved/rejected, then we remove\n      // remove its entry from the internal #requests\n      __classPrivateFieldGet(this, _ScProvider_requests, \"f\").delete(id);\n    }\n  }\n  async subscribe(type, method, params, callback) {\n    if (!subscriptionUnsubscriptionMethods.has(method)) {\n      throw new Error(`Unsupported subscribe method: ${method}`);\n    }\n    const id = await this.send(method, params);\n    const subscriptionId = `${type}::${id}`;\n    const cb = response => {\n      if (response instanceof Error) {\n        callback(response, undefined);\n      } else {\n        callback(null, response);\n      }\n    };\n    const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n    if (!unsubscribeMethod) {\n      throw new Error('Invalid unsubscribe method found');\n    }\n    __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").set(subscriptionId, {\n      callback,\n      method,\n      params,\n      type\n    });\n    __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").set(subscriptionId, [cb, {\n      id,\n      unsubscribeMethod\n    }]);\n    return id;\n  }\n  unsubscribe(type, method, id) {\n    if (!this.isConnected) {\n      throw new Error('Provider is not connected');\n    }\n    const subscriptionId = `${type}::${id}`;\n    if (!__classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").has(subscriptionId)) {\n      return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n    }\n    __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").delete(subscriptionId);\n    __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").delete(subscriptionId);\n    return this.send(method, [id]);\n  }\n}\n_ScProvider_Sc = new WeakMap(), _ScProvider_coder = new WeakMap(), _ScProvider_spec = new WeakMap(), _ScProvider_sharedSandbox = new WeakMap(), _ScProvider_subscriptions = new WeakMap(), _ScProvider_resubscribeMethods = new WeakMap(), _ScProvider_requests = new WeakMap(), _ScProvider_wellKnownChains = new WeakMap(), _ScProvider_eventemitter = new WeakMap(), _ScProvider_chain = new WeakMap(), _ScProvider_isChainReady = new WeakMap(), _ScProvider_resubscribe = new WeakMap();","map":{"version":3,"names":["_ScProvider_Sc","_ScProvider_coder","_ScProvider_spec","_ScProvider_sharedSandbox","_ScProvider_subscriptions","_ScProvider_resubscribeMethods","_ScProvider_requests","_ScProvider_wellKnownChains","_ScProvider_eventemitter","_ScProvider_chain","_ScProvider_isChainReady","_ScProvider_resubscribe","__classPrivateFieldGet","__classPrivateFieldSet","EventEmitter","isError","isFunction","isObject","logger","objectSpread","RpcCoder","healthChecker","l","subscriptionUnsubscriptionMethods","Map","scClients","WeakMap","ScProvider","constructor","Sc","spec","sharedSandbox","set","promises","forEach","subDetails","type","startsWith","promise","Promise","resolve","subscribe","method","params","callback","catch","error","console","log","push","all","err","WellKnownChain","createScClient","Error","Set","Object","values","hasSubscriptions","isClonable","isConnected","clone","connect","config","checkerFactory","arguments","length","undefined","client","get","hc","onResponse","res","hcRes","responsePassThrough","response","JSON","parse","decodedResponse","decodeResponse","e","subscription","id","subscriptionId","addChain","has","addWellKnownChain","then","chain","setSendJsonRpc","sendJsonRpc","cleanup","disconnectionError","cb","_ref","clear","staleSubscriptions","killStaleSubscriptions","stale","pop","unsubscribeMethod","race","send","setTimeout","start","health","isReady","isSyncing","peers","shouldHavePeers","s","emit","size","call","remove","stop","bind","disconnect","_","on","sub","removeListener","json","encodeJson","result","reject","delete","unsubscribe"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/rpc-provider/substrate-connect/index.js"],"sourcesContent":["var _ScProvider_Sc, _ScProvider_coder, _ScProvider_spec, _ScProvider_sharedSandbox, _ScProvider_subscriptions, _ScProvider_resubscribeMethods, _ScProvider_requests, _ScProvider_wellKnownChains, _ScProvider_eventemitter, _ScProvider_chain, _ScProvider_isChainReady, _ScProvider_resubscribe;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([\n    ['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'],\n    ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'],\n    ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'],\n    ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'],\n    ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'],\n    ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'],\n    ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],\n    ['subscribe_newHead', 'unsubscribe_newHead'],\n    ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'],\n    ['state_subscribeStorage', 'state_unsubscribeStorage']\n]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n    constructor(Sc, spec, sharedSandbox) {\n        _ScProvider_Sc.set(this, void 0);\n        _ScProvider_coder.set(this, new RpcCoder());\n        _ScProvider_spec.set(this, void 0);\n        _ScProvider_sharedSandbox.set(this, void 0);\n        _ScProvider_subscriptions.set(this, new Map());\n        _ScProvider_resubscribeMethods.set(this, new Map());\n        _ScProvider_requests.set(this, new Map());\n        _ScProvider_wellKnownChains.set(this, void 0);\n        _ScProvider_eventemitter.set(this, new EventEmitter());\n        _ScProvider_chain.set(this, null);\n        _ScProvider_isChainReady.set(this, false);\n        _ScProvider_resubscribe.set(this, () => {\n            const promises = [];\n            __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").forEach((subDetails) => {\n                // only re-create subscriptions which are not in author (only area where\n                // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n                // are not included (and will not be re-broadcast)\n                if (subDetails.type.startsWith('author_')) {\n                    return;\n                }\n                try {\n                    const promise = new Promise((resolve) => {\n                        this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));\n                        resolve();\n                    });\n                    promises.push(promise);\n                }\n                catch (error) {\n                    l.error(error);\n                }\n            });\n            Promise.all(promises).catch((err) => l.log(err));\n        });\n        if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n            throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n        }\n        __classPrivateFieldSet(this, _ScProvider_Sc, Sc, \"f\");\n        __classPrivateFieldSet(this, _ScProvider_spec, spec, \"f\");\n        __classPrivateFieldSet(this, _ScProvider_sharedSandbox, sharedSandbox, \"f\");\n        __classPrivateFieldSet(this, _ScProvider_wellKnownChains, new Set(Object.values(Sc.WellKnownChain)), \"f\");\n    }\n    get hasSubscriptions() {\n        // Indicates that subscriptions are supported\n        return true;\n    }\n    get isClonable() {\n        return false;\n    }\n    get isConnected() {\n        return !!__classPrivateFieldGet(this, _ScProvider_chain, \"f\") && __classPrivateFieldGet(this, _ScProvider_isChainReady, \"f\");\n    }\n    clone() {\n        throw new Error('clone() is not supported.');\n    }\n    // Config details can be found in @substrate/connect repo following the link:\n    // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n    async connect(config, checkerFactory = healthChecker) {\n        if (this.isConnected) {\n            throw new Error('Already connected!');\n        }\n        // it could happen that after emitting `disconnected` due to the fact taht\n        // smoldot is syncing, the consumer tries to reconnect after a certain amount\n        // of time... In which case we want to make sure that we don't create a new\n        // chain.\n        if (__classPrivateFieldGet(this, _ScProvider_chain, \"f\")) {\n            await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n            return;\n        }\n        if (__classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\") && !__classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\").isConnected) {\n            await __classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\").connect();\n        }\n        const client = __classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\")\n            ? scClients.get(__classPrivateFieldGet(this, _ScProvider_sharedSandbox, \"f\"))\n            : __classPrivateFieldGet(this, _ScProvider_Sc, \"f\").createScClient(config);\n        if (!client) {\n            throw new Error('Unkown ScProvider!');\n        }\n        scClients.set(this, client);\n        const hc = checkerFactory();\n        const onResponse = (res) => {\n            const hcRes = hc.responsePassThrough(res);\n            if (!hcRes) {\n                return;\n            }\n            const response = JSON.parse(hcRes);\n            let decodedResponse;\n            try {\n                decodedResponse = __classPrivateFieldGet(this, _ScProvider_coder, \"f\").decodeResponse(response);\n            }\n            catch (e) {\n                decodedResponse = e;\n            }\n            // It's not a subscription message, but rather a standar RPC response\n            if (response.params?.subscription === undefined || !response.method) {\n                return __classPrivateFieldGet(this, _ScProvider_requests, \"f\").get(response.id)?.(decodedResponse);\n            }\n            // We are dealing with a subscription message\n            const subscriptionId = `${response.method}::${response.params.subscription}`;\n            const callback = __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").get(subscriptionId)?.[0];\n            callback?.(decodedResponse);\n        };\n        const addChain = __classPrivateFieldGet(this, _ScProvider_wellKnownChains, \"f\").has(__classPrivateFieldGet(this, _ScProvider_spec, \"f\"))\n            ? client.addWellKnownChain\n            : client.addChain;\n        __classPrivateFieldSet(this, _ScProvider_chain, addChain(__classPrivateFieldGet(this, _ScProvider_spec, \"f\"), onResponse).then((chain) => {\n            hc.setSendJsonRpc(chain.sendJsonRpc);\n            __classPrivateFieldSet(this, _ScProvider_isChainReady, false, \"f\");\n            const cleanup = () => {\n                // If there are any callbacks left, we have to reject/error them.\n                // Otherwise, that would cause a memory leak.\n                const disconnectionError = new Error('Disconnected');\n                __classPrivateFieldGet(this, _ScProvider_requests, \"f\").forEach((cb) => cb(disconnectionError));\n                __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").forEach(([cb]) => cb(disconnectionError));\n                __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").clear();\n            };\n            const staleSubscriptions = [];\n            const killStaleSubscriptions = () => {\n                if (staleSubscriptions.length === 0) {\n                    return;\n                }\n                const stale = staleSubscriptions.pop();\n                if (!stale) {\n                    throw new Error('Unable to get stale subscription');\n                }\n                const { id, unsubscribeMethod } = stale;\n                Promise\n                    .race([\n                    this.send(unsubscribeMethod, [id]).catch(() => undefined),\n                    new Promise((resolve) => setTimeout(resolve, 500))\n                ])\n                    .then(killStaleSubscriptions)\n                    .catch(() => undefined);\n            };\n            hc.start((health) => {\n                const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n                // if it's the same as before, then nothing has changed and we are done\n                if (__classPrivateFieldGet(this, _ScProvider_isChainReady, \"f\") === isReady) {\n                    return;\n                }\n                __classPrivateFieldSet(this, _ScProvider_isChainReady, isReady, \"f\");\n                if (!isReady) {\n                    // If we've reached this point, that means that the chain used to be \"ready\"\n                    // and now we are about to emit `disconnected`.\n                    //\n                    // This will cause the PolkadotJs API think that the connection is\n                    // actually dead. In reality the smoldot chain is not dead, of course.\n                    // However, we have to cleanup all the existing callbacks because when\n                    // the smoldot chain stops syncing, then we will emit `connected` and\n                    // the PolkadotJs API will try to re-create the previous\n                    // subscriptions and requests. Although, now is not a good moment\n                    // to be sending unsubscription messages to the smoldot chain, we\n                    // should wait until is no longer syncing to send the unsubscription\n                    // messages from the stale subscriptions of the previous connection.\n                    //\n                    // That's why -before we perform the cleanup of `this.#subscriptions`-\n                    // we keep the necessary information that we will need later on to\n                    // kill the stale subscriptions.\n                    [...__classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").values()].forEach((s) => {\n                        staleSubscriptions.push(s[1]);\n                    });\n                    cleanup();\n                    __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('disconnected');\n                }\n                else {\n                    killStaleSubscriptions();\n                    __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('connected');\n                    if (__classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").size) {\n                        __classPrivateFieldGet(this, _ScProvider_resubscribe, \"f\").call(this);\n                    }\n                }\n            });\n            return objectSpread({}, chain, {\n                remove: () => {\n                    hc.stop();\n                    chain.remove();\n                    cleanup();\n                },\n                sendJsonRpc: hc.sendJsonRpc.bind(hc)\n            });\n        }), \"f\");\n        try {\n            await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n        }\n        catch (e) {\n            __classPrivateFieldSet(this, _ScProvider_chain, null, \"f\");\n            __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('error', e);\n            throw e;\n        }\n    }\n    async disconnect() {\n        if (!__classPrivateFieldGet(this, _ScProvider_chain, \"f\")) {\n            return;\n        }\n        const chain = await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n        __classPrivateFieldSet(this, _ScProvider_chain, null, \"f\");\n        __classPrivateFieldSet(this, _ScProvider_isChainReady, false, \"f\");\n        try {\n            chain.remove();\n        }\n        catch (_) { }\n        __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('disconnected');\n    }\n    on(type, sub) {\n        // It's possible. Although, quite unlikely, that by the time that polkadot\n        // subscribes to the `connected` event, the Provider is already connected.\n        // In that case, we must emit to let the consumer know that we are connected.\n        if (type === 'connected' && this.isConnected) {\n            sub();\n        }\n        __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").on(type, sub);\n        return () => {\n            __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").removeListener(type, sub);\n        };\n    }\n    async send(method, params) {\n        if (!this.isConnected || !__classPrivateFieldGet(this, _ScProvider_chain, \"f\")) {\n            throw new Error('Provider is not connected');\n        }\n        const chain = await __classPrivateFieldGet(this, _ScProvider_chain, \"f\");\n        const [id, json] = __classPrivateFieldGet(this, _ScProvider_coder, \"f\").encodeJson(method, params);\n        const result = new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _ScProvider_requests, \"f\").set(id, (response) => {\n                (isError(response) ? reject : resolve)(response);\n            });\n            try {\n                chain.sendJsonRpc(json);\n            }\n            catch (e) {\n                __classPrivateFieldSet(this, _ScProvider_chain, null, \"f\");\n                try {\n                    chain.remove();\n                }\n                catch (_) { }\n                __classPrivateFieldGet(this, _ScProvider_eventemitter, \"f\").emit('error', e);\n            }\n        });\n        try {\n            return await result;\n        }\n        finally {\n            // let's ensure that once the Promise is resolved/rejected, then we remove\n            // remove its entry from the internal #requests\n            __classPrivateFieldGet(this, _ScProvider_requests, \"f\").delete(id);\n        }\n    }\n    async subscribe(type, method, params, callback) {\n        if (!subscriptionUnsubscriptionMethods.has(method)) {\n            throw new Error(`Unsupported subscribe method: ${method}`);\n        }\n        const id = await this.send(method, params);\n        const subscriptionId = `${type}::${id}`;\n        const cb = (response) => {\n            if (response instanceof Error) {\n                callback(response, undefined);\n            }\n            else {\n                callback(null, response);\n            }\n        };\n        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n        if (!unsubscribeMethod) {\n            throw new Error('Invalid unsubscribe method found');\n        }\n        __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").set(subscriptionId, { callback, method, params, type });\n        __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").set(subscriptionId, [cb, { id, unsubscribeMethod }]);\n        return id;\n    }\n    unsubscribe(type, method, id) {\n        if (!this.isConnected) {\n            throw new Error('Provider is not connected');\n        }\n        const subscriptionId = `${type}::${id}`;\n        if (!__classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").has(subscriptionId)) {\n            return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n        }\n        __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, \"f\").delete(subscriptionId);\n        __classPrivateFieldGet(this, _ScProvider_subscriptions, \"f\").delete(subscriptionId);\n        return this.send(method, [id]);\n    }\n}\n_ScProvider_Sc = new WeakMap(), _ScProvider_coder = new WeakMap(), _ScProvider_spec = new WeakMap(), _ScProvider_sharedSandbox = new WeakMap(), _ScProvider_subscriptions = new WeakMap(), _ScProvider_resubscribeMethods = new WeakMap(), _ScProvider_requests = new WeakMap(), _ScProvider_wellKnownChains = new WeakMap(), _ScProvider_eventemitter = new WeakMap(), _ScProvider_chain = new WeakMap(), _ScProvider_isChainReady = new WeakMap(), _ScProvider_resubscribe = new WeakMap();\n"],"mappings":"AAAA,IAAIA,cAAc,EAAEC,iBAAiB,EAAEC,gBAAgB,EAAEC,yBAAyB,EAAEC,yBAAyB,EAAEC,8BAA8B,EAAEC,oBAAoB,EAAEC,2BAA2B,EAAEC,wBAAwB,EAAEC,iBAAiB,EAAEC,wBAAwB,EAAEC,uBAAuB;AAChS,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,OAAO;AACtE,SAASC,YAAY,QAAQ,eAAe;AAC5C,SAASC,OAAO,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,YAAY,QAAQ,gBAAgB;AACpF,SAASC,QAAQ,QAAQ,mBAAmB;AAC5C,SAASC,aAAa,QAAQ,aAAa;AAC3C,MAAMC,CAAC,GAAGJ,MAAM,CAAC,uBAAuB,CAAC;AACzC,MAAMK,iCAAiC,GAAG,IAAIC,GAAG,CAAC,CAC9C,CAAC,gCAAgC,EAAE,yBAAyB,CAAC,EAC7D,CAAC,yBAAyB,EAAE,2BAA2B,CAAC,EACxD,CAAC,+BAA+B,EAAE,iCAAiC,CAAC,EACpE,CAAC,+BAA+B,EAAE,+BAA+B,CAAC,EAClE,CAAC,yBAAyB,EAAE,2BAA2B,CAAC,EACxD,CAAC,wBAAwB,EAAE,0BAA0B,CAAC,EACtD,CAAC,+BAA+B,EAAE,iCAAiC,CAAC,EACpE,CAAC,mBAAmB,EAAE,qBAAqB,CAAC,EAC5C,CAAC,+BAA+B,EAAE,iCAAiC,CAAC,EACpE,CAAC,wBAAwB,EAAE,0BAA0B,CAAC,CACzD,CAAC;AACF,MAAMC,SAAS,GAAG,IAAIC,OAAO,EAAE;AAC/B,OAAO,MAAMC,UAAU,CAAC;EACpBC,WAAWA,CAACC,EAAE,EAAEC,IAAI,EAAEC,aAAa,EAAE;IACjC/B,cAAc,CAACgC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAChC/B,iBAAiB,CAAC+B,GAAG,CAAC,IAAI,EAAE,IAAIZ,QAAQ,EAAE,CAAC;IAC3ClB,gBAAgB,CAAC8B,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAClC7B,yBAAyB,CAAC6B,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3C5B,yBAAyB,CAAC4B,GAAG,CAAC,IAAI,EAAE,IAAIR,GAAG,EAAE,CAAC;IAC9CnB,8BAA8B,CAAC2B,GAAG,CAAC,IAAI,EAAE,IAAIR,GAAG,EAAE,CAAC;IACnDlB,oBAAoB,CAAC0B,GAAG,CAAC,IAAI,EAAE,IAAIR,GAAG,EAAE,CAAC;IACzCjB,2BAA2B,CAACyB,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC7CxB,wBAAwB,CAACwB,GAAG,CAAC,IAAI,EAAE,IAAIlB,YAAY,EAAE,CAAC;IACtDL,iBAAiB,CAACuB,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACjCtB,wBAAwB,CAACsB,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IACzCrB,uBAAuB,CAACqB,GAAG,CAAC,IAAI,EAAE,MAAM;MACpC,MAAMC,QAAQ,GAAG,EAAE;MACnBrB,sBAAsB,CAAC,IAAI,EAAEP,8BAA8B,EAAE,GAAG,CAAC,CAAC6B,OAAO,CAAEC,UAAU,IAAK;QACtF;QACA;QACA;QACA,IAAIA,UAAU,CAACC,IAAI,CAACC,UAAU,CAAC,SAAS,CAAC,EAAE;UACvC;QACJ;QACA,IAAI;UACA,MAAMC,OAAO,GAAG,IAAIC,OAAO,CAAEC,OAAO,IAAK;YACrC,IAAI,CAACC,SAAS,CAACN,UAAU,CAACC,IAAI,EAAED,UAAU,CAACO,MAAM,EAAEP,UAAU,CAACQ,MAAM,EAAER,UAAU,CAACS,QAAQ,CAAC,CAACC,KAAK,CAAEC,KAAK,IAAKC,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC,CAAC;YAC/HN,OAAO,EAAE;UACb,CAAC,CAAC;UACFP,QAAQ,CAACgB,IAAI,CAACX,OAAO,CAAC;QAC1B,CAAC,CACD,OAAOQ,KAAK,EAAE;UACVxB,CAAC,CAACwB,KAAK,CAACA,KAAK,CAAC;QAClB;MACJ,CAAC,CAAC;MACFP,OAAO,CAACW,GAAG,CAACjB,QAAQ,CAAC,CAACY,KAAK,CAAEM,GAAG,IAAK7B,CAAC,CAAC0B,GAAG,CAACG,GAAG,CAAC,CAAC;IACpD,CAAC,CAAC;IACF,IAAI,CAAClC,QAAQ,CAACY,EAAE,CAAC,IAAI,CAACZ,QAAQ,CAACY,EAAE,CAACuB,cAAc,CAAC,IAAI,CAACpC,UAAU,CAACa,EAAE,CAACwB,cAAc,CAAC,EAAE;MACjF,MAAM,IAAIC,KAAK,CAAC,2EAA2E,CAAC;IAChG;IACAzC,sBAAsB,CAAC,IAAI,EAAEb,cAAc,EAAE6B,EAAE,EAAE,GAAG,CAAC;IACrDhB,sBAAsB,CAAC,IAAI,EAAEX,gBAAgB,EAAE4B,IAAI,EAAE,GAAG,CAAC;IACzDjB,sBAAsB,CAAC,IAAI,EAAEV,yBAAyB,EAAE4B,aAAa,EAAE,GAAG,CAAC;IAC3ElB,sBAAsB,CAAC,IAAI,EAAEN,2BAA2B,EAAE,IAAIgD,GAAG,CAACC,MAAM,CAACC,MAAM,CAAC5B,EAAE,CAACuB,cAAc,CAAC,CAAC,EAAE,GAAG,CAAC;EAC7G;EACA,IAAIM,gBAAgBA,CAAA,EAAG;IACnB;IACA,OAAO,IAAI;EACf;EACA,IAAIC,UAAUA,CAAA,EAAG;IACb,OAAO,KAAK;EAChB;EACA,IAAIC,WAAWA,CAAA,EAAG;IACd,OAAO,CAAC,CAAChD,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC,IAAIG,sBAAsB,CAAC,IAAI,EAAEF,wBAAwB,EAAE,GAAG,CAAC;EAChI;EACAmD,KAAKA,CAAA,EAAG;IACJ,MAAM,IAAIP,KAAK,CAAC,2BAA2B,CAAC;EAChD;EACA;EACA;EACA,MAAMQ,OAAOA,CAACC,MAAM,EAAkC;IAAA,IAAhCC,cAAc,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG5C,aAAa;IAChD,IAAI,IAAI,CAACuC,WAAW,EAAE;MAClB,MAAM,IAAIN,KAAK,CAAC,oBAAoB,CAAC;IACzC;IACA;IACA;IACA;IACA;IACA,IAAI1C,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC,EAAE;MACtD,MAAMG,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC;MAC1D;IACJ;IACA,IAAIG,sBAAsB,CAAC,IAAI,EAAET,yBAAyB,EAAE,GAAG,CAAC,IAAI,CAACS,sBAAsB,CAAC,IAAI,EAAET,yBAAyB,EAAE,GAAG,CAAC,CAACyD,WAAW,EAAE;MAC3I,MAAMhD,sBAAsB,CAAC,IAAI,EAAET,yBAAyB,EAAE,GAAG,CAAC,CAAC2D,OAAO,EAAE;IAChF;IACA,MAAMM,MAAM,GAAGxD,sBAAsB,CAAC,IAAI,EAAET,yBAAyB,EAAE,GAAG,CAAC,GACrEsB,SAAS,CAAC4C,GAAG,CAACzD,sBAAsB,CAAC,IAAI,EAAET,yBAAyB,EAAE,GAAG,CAAC,CAAC,GAC3ES,sBAAsB,CAAC,IAAI,EAAEZ,cAAc,EAAE,GAAG,CAAC,CAACqD,cAAc,CAACU,MAAM,CAAC;IAC9E,IAAI,CAACK,MAAM,EAAE;MACT,MAAM,IAAId,KAAK,CAAC,oBAAoB,CAAC;IACzC;IACA7B,SAAS,CAACO,GAAG,CAAC,IAAI,EAAEoC,MAAM,CAAC;IAC3B,MAAME,EAAE,GAAGN,cAAc,EAAE;IAC3B,MAAMO,UAAU,GAAIC,GAAG,IAAK;MACxB,MAAMC,KAAK,GAAGH,EAAE,CAACI,mBAAmB,CAACF,GAAG,CAAC;MACzC,IAAI,CAACC,KAAK,EAAE;QACR;MACJ;MACA,MAAME,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACJ,KAAK,CAAC;MAClC,IAAIK,eAAe;MACnB,IAAI;QACAA,eAAe,GAAGlE,sBAAsB,CAAC,IAAI,EAAEX,iBAAiB,EAAE,GAAG,CAAC,CAAC8E,cAAc,CAACJ,QAAQ,CAAC;MACnG,CAAC,CACD,OAAOK,CAAC,EAAE;QACNF,eAAe,GAAGE,CAAC;MACvB;MACA;MACA,IAAIL,QAAQ,CAAChC,MAAM,EAAEsC,YAAY,KAAKd,SAAS,IAAI,CAACQ,QAAQ,CAACjC,MAAM,EAAE;QACjE,OAAO9B,sBAAsB,CAAC,IAAI,EAAEN,oBAAoB,EAAE,GAAG,CAAC,CAAC+D,GAAG,CAACM,QAAQ,CAACO,EAAE,CAAC,GAAGJ,eAAe,CAAC;MACtG;MACA;MACA,MAAMK,cAAc,GAAI,GAAER,QAAQ,CAACjC,MAAO,KAAIiC,QAAQ,CAAChC,MAAM,CAACsC,YAAa,EAAC;MAC5E,MAAMrC,QAAQ,GAAGhC,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC,CAACiE,GAAG,CAACc,cAAc,CAAC,GAAG,CAAC,CAAC;MACtGvC,QAAQ,GAAGkC,eAAe,CAAC;IAC/B,CAAC;IACD,MAAMM,QAAQ,GAAGxE,sBAAsB,CAAC,IAAI,EAAEL,2BAA2B,EAAE,GAAG,CAAC,CAAC8E,GAAG,CAACzE,sBAAsB,CAAC,IAAI,EAAEV,gBAAgB,EAAE,GAAG,CAAC,CAAC,GAClIkE,MAAM,CAACkB,iBAAiB,GACxBlB,MAAM,CAACgB,QAAQ;IACrBvE,sBAAsB,CAAC,IAAI,EAAEJ,iBAAiB,EAAE2E,QAAQ,CAACxE,sBAAsB,CAAC,IAAI,EAAEV,gBAAgB,EAAE,GAAG,CAAC,EAAEqE,UAAU,CAAC,CAACgB,IAAI,CAAEC,KAAK,IAAK;MACtIlB,EAAE,CAACmB,cAAc,CAACD,KAAK,CAACE,WAAW,CAAC;MACpC7E,sBAAsB,CAAC,IAAI,EAAEH,wBAAwB,EAAE,KAAK,EAAE,GAAG,CAAC;MAClE,MAAMiF,OAAO,GAAGA,CAAA,KAAM;QAClB;QACA;QACA,MAAMC,kBAAkB,GAAG,IAAItC,KAAK,CAAC,cAAc,CAAC;QACpD1C,sBAAsB,CAAC,IAAI,EAAEN,oBAAoB,EAAE,GAAG,CAAC,CAAC4B,OAAO,CAAE2D,EAAE,IAAKA,EAAE,CAACD,kBAAkB,CAAC,CAAC;QAC/FhF,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC,CAAC8B,OAAO,CAAC4D,IAAA;UAAA,IAAC,CAACD,EAAE,CAAC,GAAAC,IAAA;UAAA,OAAKD,EAAE,CAACD,kBAAkB,CAAC;QAAA,EAAC;QACtGhF,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC,CAAC2F,KAAK,EAAE;MACxE,CAAC;MACD,MAAMC,kBAAkB,GAAG,EAAE;MAC7B,MAAMC,sBAAsB,GAAGA,CAAA,KAAM;QACjC,IAAID,kBAAkB,CAAC9B,MAAM,KAAK,CAAC,EAAE;UACjC;QACJ;QACA,MAAMgC,KAAK,GAAGF,kBAAkB,CAACG,GAAG,EAAE;QACtC,IAAI,CAACD,KAAK,EAAE;UACR,MAAM,IAAI5C,KAAK,CAAC,kCAAkC,CAAC;QACvD;QACA,MAAM;UAAE4B,EAAE;UAAEkB;QAAkB,CAAC,GAAGF,KAAK;QACvC3D,OAAO,CACF8D,IAAI,CAAC,CACN,IAAI,CAACC,IAAI,CAACF,iBAAiB,EAAE,CAAClB,EAAE,CAAC,CAAC,CAACrC,KAAK,CAAC,MAAMsB,SAAS,CAAC,EACzD,IAAI5B,OAAO,CAAEC,OAAO,IAAK+D,UAAU,CAAC/D,OAAO,EAAE,GAAG,CAAC,CAAC,CACrD,CAAC,CACG+C,IAAI,CAACU,sBAAsB,CAAC,CAC5BpD,KAAK,CAAC,MAAMsB,SAAS,CAAC;MAC/B,CAAC;MACDG,EAAE,CAACkC,KAAK,CAAEC,MAAM,IAAK;QACjB,MAAMC,OAAO,GAAG,CAACD,MAAM,CAACE,SAAS,KAAKF,MAAM,CAACG,KAAK,GAAG,CAAC,IAAI,CAACH,MAAM,CAACI,eAAe,CAAC;QAClF;QACA,IAAIjG,sBAAsB,CAAC,IAAI,EAAEF,wBAAwB,EAAE,GAAG,CAAC,KAAKgG,OAAO,EAAE;UACzE;QACJ;QACA7F,sBAAsB,CAAC,IAAI,EAAEH,wBAAwB,EAAEgG,OAAO,EAAE,GAAG,CAAC;QACpE,IAAI,CAACA,OAAO,EAAE;UACV;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,CAAC,GAAG9F,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC,CAACqD,MAAM,EAAE,CAAC,CAACvB,OAAO,CAAE4E,CAAC,IAAK;YACtFd,kBAAkB,CAAC/C,IAAI,CAAC6D,CAAC,CAAC,CAAC,CAAC,CAAC;UACjC,CAAC,CAAC;UACFnB,OAAO,EAAE;UACT/E,sBAAsB,CAAC,IAAI,EAAEJ,wBAAwB,EAAE,GAAG,CAAC,CAACuG,IAAI,CAAC,cAAc,CAAC;QACpF,CAAC,MACI;UACDd,sBAAsB,EAAE;UACxBrF,sBAAsB,CAAC,IAAI,EAAEJ,wBAAwB,EAAE,GAAG,CAAC,CAACuG,IAAI,CAAC,WAAW,CAAC;UAC7E,IAAInG,sBAAsB,CAAC,IAAI,EAAEP,8BAA8B,EAAE,GAAG,CAAC,CAAC2G,IAAI,EAAE;YACxEpG,sBAAsB,CAAC,IAAI,EAAED,uBAAuB,EAAE,GAAG,CAAC,CAACsG,IAAI,CAAC,IAAI,CAAC;UACzE;QACJ;MACJ,CAAC,CAAC;MACF,OAAO9F,YAAY,CAAC,CAAC,CAAC,EAAEqE,KAAK,EAAE;QAC3B0B,MAAM,EAAEA,CAAA,KAAM;UACV5C,EAAE,CAAC6C,IAAI,EAAE;UACT3B,KAAK,CAAC0B,MAAM,EAAE;UACdvB,OAAO,EAAE;QACb,CAAC;QACDD,WAAW,EAAEpB,EAAE,CAACoB,WAAW,CAAC0B,IAAI,CAAC9C,EAAE;MACvC,CAAC,CAAC;IACN,CAAC,CAAC,EAAE,GAAG,CAAC;IACR,IAAI;MACA,MAAM1D,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC;IAC9D,CAAC,CACD,OAAOuE,CAAC,EAAE;MACNnE,sBAAsB,CAAC,IAAI,EAAEJ,iBAAiB,EAAE,IAAI,EAAE,GAAG,CAAC;MAC1DG,sBAAsB,CAAC,IAAI,EAAEJ,wBAAwB,EAAE,GAAG,CAAC,CAACuG,IAAI,CAAC,OAAO,EAAE/B,CAAC,CAAC;MAC5E,MAAMA,CAAC;IACX;EACJ;EACA,MAAMqC,UAAUA,CAAA,EAAG;IACf,IAAI,CAACzG,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC,EAAE;MACvD;IACJ;IACA,MAAM+E,KAAK,GAAG,MAAM5E,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC;IACxEI,sBAAsB,CAAC,IAAI,EAAEJ,iBAAiB,EAAE,IAAI,EAAE,GAAG,CAAC;IAC1DI,sBAAsB,CAAC,IAAI,EAAEH,wBAAwB,EAAE,KAAK,EAAE,GAAG,CAAC;IAClE,IAAI;MACA8E,KAAK,CAAC0B,MAAM,EAAE;IAClB,CAAC,CACD,OAAOI,CAAC,EAAE,CAAE;IACZ1G,sBAAsB,CAAC,IAAI,EAAEJ,wBAAwB,EAAE,GAAG,CAAC,CAACuG,IAAI,CAAC,cAAc,CAAC;EACpF;EACAQ,EAAEA,CAACnF,IAAI,EAAEoF,GAAG,EAAE;IACV;IACA;IACA;IACA,IAAIpF,IAAI,KAAK,WAAW,IAAI,IAAI,CAACwB,WAAW,EAAE;MAC1C4D,GAAG,EAAE;IACT;IACA5G,sBAAsB,CAAC,IAAI,EAAEJ,wBAAwB,EAAE,GAAG,CAAC,CAAC+G,EAAE,CAACnF,IAAI,EAAEoF,GAAG,CAAC;IACzE,OAAO,MAAM;MACT5G,sBAAsB,CAAC,IAAI,EAAEJ,wBAAwB,EAAE,GAAG,CAAC,CAACiH,cAAc,CAACrF,IAAI,EAAEoF,GAAG,CAAC;IACzF,CAAC;EACL;EACA,MAAMlB,IAAIA,CAAC5D,MAAM,EAAEC,MAAM,EAAE;IACvB,IAAI,CAAC,IAAI,CAACiB,WAAW,IAAI,CAAChD,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC,EAAE;MAC5E,MAAM,IAAI6C,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,MAAMkC,KAAK,GAAG,MAAM5E,sBAAsB,CAAC,IAAI,EAAEH,iBAAiB,EAAE,GAAG,CAAC;IACxE,MAAM,CAACyE,EAAE,EAAEwC,IAAI,CAAC,GAAG9G,sBAAsB,CAAC,IAAI,EAAEX,iBAAiB,EAAE,GAAG,CAAC,CAAC0H,UAAU,CAACjF,MAAM,EAAEC,MAAM,CAAC;IAClG,MAAMiF,MAAM,GAAG,IAAIrF,OAAO,CAAC,CAACC,OAAO,EAAEqF,MAAM,KAAK;MAC5CjH,sBAAsB,CAAC,IAAI,EAAEN,oBAAoB,EAAE,GAAG,CAAC,CAAC0B,GAAG,CAACkD,EAAE,EAAGP,QAAQ,IAAK;QAC1E,CAAC5D,OAAO,CAAC4D,QAAQ,CAAC,GAAGkD,MAAM,GAAGrF,OAAO,EAAEmC,QAAQ,CAAC;MACpD,CAAC,CAAC;MACF,IAAI;QACAa,KAAK,CAACE,WAAW,CAACgC,IAAI,CAAC;MAC3B,CAAC,CACD,OAAO1C,CAAC,EAAE;QACNnE,sBAAsB,CAAC,IAAI,EAAEJ,iBAAiB,EAAE,IAAI,EAAE,GAAG,CAAC;QAC1D,IAAI;UACA+E,KAAK,CAAC0B,MAAM,EAAE;QAClB,CAAC,CACD,OAAOI,CAAC,EAAE,CAAE;QACZ1G,sBAAsB,CAAC,IAAI,EAAEJ,wBAAwB,EAAE,GAAG,CAAC,CAACuG,IAAI,CAAC,OAAO,EAAE/B,CAAC,CAAC;MAChF;IACJ,CAAC,CAAC;IACF,IAAI;MACA,OAAO,MAAM4C,MAAM;IACvB,CAAC,SACO;MACJ;MACA;MACAhH,sBAAsB,CAAC,IAAI,EAAEN,oBAAoB,EAAE,GAAG,CAAC,CAACwH,MAAM,CAAC5C,EAAE,CAAC;IACtE;EACJ;EACA,MAAMzC,SAASA,CAACL,IAAI,EAAEM,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAE;IAC5C,IAAI,CAACrB,iCAAiC,CAAC8D,GAAG,CAAC3C,MAAM,CAAC,EAAE;MAChD,MAAM,IAAIY,KAAK,CAAE,iCAAgCZ,MAAO,EAAC,CAAC;IAC9D;IACA,MAAMwC,EAAE,GAAG,MAAM,IAAI,CAACoB,IAAI,CAAC5D,MAAM,EAAEC,MAAM,CAAC;IAC1C,MAAMwC,cAAc,GAAI,GAAE/C,IAAK,KAAI8C,EAAG,EAAC;IACvC,MAAMW,EAAE,GAAIlB,QAAQ,IAAK;MACrB,IAAIA,QAAQ,YAAYrB,KAAK,EAAE;QAC3BV,QAAQ,CAAC+B,QAAQ,EAAER,SAAS,CAAC;MACjC,CAAC,MACI;QACDvB,QAAQ,CAAC,IAAI,EAAE+B,QAAQ,CAAC;MAC5B;IACJ,CAAC;IACD,MAAMyB,iBAAiB,GAAG7E,iCAAiC,CAAC8C,GAAG,CAAC3B,MAAM,CAAC;IACvE,IAAI,CAAC0D,iBAAiB,EAAE;MACpB,MAAM,IAAI9C,KAAK,CAAC,kCAAkC,CAAC;IACvD;IACA1C,sBAAsB,CAAC,IAAI,EAAEP,8BAA8B,EAAE,GAAG,CAAC,CAAC2B,GAAG,CAACmD,cAAc,EAAE;MAAEvC,QAAQ;MAAEF,MAAM;MAAEC,MAAM;MAAEP;IAAK,CAAC,CAAC;IACzHxB,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC,CAAC4B,GAAG,CAACmD,cAAc,EAAE,CAACU,EAAE,EAAE;MAAEX,EAAE;MAAEkB;IAAkB,CAAC,CAAC,CAAC;IACjH,OAAOlB,EAAE;EACb;EACA6C,WAAWA,CAAC3F,IAAI,EAAEM,MAAM,EAAEwC,EAAE,EAAE;IAC1B,IAAI,CAAC,IAAI,CAACtB,WAAW,EAAE;MACnB,MAAM,IAAIN,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,MAAM6B,cAAc,GAAI,GAAE/C,IAAK,KAAI8C,EAAG,EAAC;IACvC,IAAI,CAACtE,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC,CAACiF,GAAG,CAACF,cAAc,CAAC,EAAE;MACnF,OAAO5C,OAAO,CAACsF,MAAM,CAAC,IAAIvE,KAAK,CAAE,sCAAqC6B,cAAe,EAAC,CAAC,CAAC;IAC5F;IACAvE,sBAAsB,CAAC,IAAI,EAAEP,8BAA8B,EAAE,GAAG,CAAC,CAACyH,MAAM,CAAC3C,cAAc,CAAC;IACxFvE,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC,CAAC0H,MAAM,CAAC3C,cAAc,CAAC;IACnF,OAAO,IAAI,CAACmB,IAAI,CAAC5D,MAAM,EAAE,CAACwC,EAAE,CAAC,CAAC;EAClC;AACJ;AACAlF,cAAc,GAAG,IAAI0B,OAAO,EAAE,EAAEzB,iBAAiB,GAAG,IAAIyB,OAAO,EAAE,EAAExB,gBAAgB,GAAG,IAAIwB,OAAO,EAAE,EAAEvB,yBAAyB,GAAG,IAAIuB,OAAO,EAAE,EAAEtB,yBAAyB,GAAG,IAAIsB,OAAO,EAAE,EAAErB,8BAA8B,GAAG,IAAIqB,OAAO,EAAE,EAAEpB,oBAAoB,GAAG,IAAIoB,OAAO,EAAE,EAAEnB,2BAA2B,GAAG,IAAImB,OAAO,EAAE,EAAElB,wBAAwB,GAAG,IAAIkB,OAAO,EAAE,EAAEjB,iBAAiB,GAAG,IAAIiB,OAAO,EAAE,EAAEhB,wBAAwB,GAAG,IAAIgB,OAAO,EAAE,EAAEf,uBAAuB,GAAG,IAAIe,OAAO,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}