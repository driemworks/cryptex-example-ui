{"ast":null,"code":"var _GenericExtrinsicPayloadV4_signOptions;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Enum, Struct } from '@polkadot/types-codec';\nimport { objectSpread } from '@polkadot/util';\nimport { sign } from '../util.js';\n/**\n * @name GenericExtrinsicPayloadV4\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is\n * variable length based on the contents included\n */\nexport class GenericExtrinsicPayloadV4 extends Struct {\n  constructor(registry, value) {\n    super(registry, objectSpread({\n      method: 'Bytes'\n    }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value);\n    _GenericExtrinsicPayloadV4_signOptions.set(this, void 0);\n    // Do detection for the type of extrinsic, in the case of MultiSignature\n    // this is an enum, in the case of AnySignature, this is a Hash only\n    // (which may be 64 or 65 bytes)\n    __classPrivateFieldSet(this, _GenericExtrinsicPayloadV4_signOptions, {\n      withType: registry.createTypeUnsafe('ExtrinsicSignature', []) instanceof Enum\n    }, \"f\");\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return super.inspect({\n      method: true\n    });\n  }\n  /**\n   * @description The block [[BlockHash]] the signature applies to (mortal/immortal)\n   */\n  get blockHash() {\n    return this.getT('blockHash');\n  }\n  /**\n   * @description The [[ExtrinsicEra]]\n   */\n  get era() {\n    return this.getT('era');\n  }\n  /**\n   * @description The genesis [[BlockHash]] the signature applies to (mortal/immortal)\n   */\n  get genesisHash() {\n    return this.getT('genesisHash');\n  }\n  /**\n   * @description The [[Bytes]] contained in the payload\n   */\n  get method() {\n    return this.getT('method');\n  }\n  /**\n   * @description The [[Index]]\n   */\n  get nonce() {\n    return this.getT('nonce');\n  }\n  /**\n   * @description The specVersion for this signature\n   */\n  get specVersion() {\n    return this.getT('specVersion');\n  }\n  /**\n   * @description The tip [[Balance]]\n   */\n  get tip() {\n    return this.getT('tip');\n  }\n  /**\n   * @description The transactionVersion for this signature\n   */\n  get transactionVersion() {\n    return this.getT('transactionVersion');\n  }\n  /**\n   * @description The (optional) asset id for this signature for chains that support transaction fees in assets\n   */\n  get assetId() {\n    return this.getT('assetId');\n  }\n  /**\n   * @description Sign the payload with the keypair\n   */\n  sign(signerPair) {\n    // NOTE The `toU8a({ method: true })` argument is absolutely critical, we\n    // don't want the method (Bytes) to have the length prefix included. This\n    // means that the data-as-signed is un-decodable, but is also doesn't need\n    // the extra information, only the pure data (and is not decoded) ...\n    // The same applies to V1..V3, if we have a V5, carry this comment\n    return sign(this.registry, signerPair, this.toU8a({\n      method: true\n    }), __classPrivateFieldGet(this, _GenericExtrinsicPayloadV4_signOptions, \"f\"));\n  }\n}\n_GenericExtrinsicPayloadV4_signOptions = new WeakMap();","map":{"version":3,"names":["_GenericExtrinsicPayloadV4_signOptions","__classPrivateFieldGet","__classPrivateFieldSet","Enum","Struct","objectSpread","sign","GenericExtrinsicPayloadV4","constructor","registry","value","method","getSignedExtensionTypes","getSignedExtensionExtra","set","withType","createTypeUnsafe","inspect","blockHash","getT","era","genesisHash","nonce","specVersion","tip","transactionVersion","assetId","signerPair","toU8a","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js"],"sourcesContent":["var _GenericExtrinsicPayloadV4_signOptions;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Enum, Struct } from '@polkadot/types-codec';\nimport { objectSpread } from '@polkadot/util';\nimport { sign } from '../util.js';\n/**\n * @name GenericExtrinsicPayloadV4\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is\n * variable length based on the contents included\n */\nexport class GenericExtrinsicPayloadV4 extends Struct {\n    constructor(registry, value) {\n        super(registry, objectSpread({ method: 'Bytes' }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value);\n        _GenericExtrinsicPayloadV4_signOptions.set(this, void 0);\n        // Do detection for the type of extrinsic, in the case of MultiSignature\n        // this is an enum, in the case of AnySignature, this is a Hash only\n        // (which may be 64 or 65 bytes)\n        __classPrivateFieldSet(this, _GenericExtrinsicPayloadV4_signOptions, {\n            withType: registry.createTypeUnsafe('ExtrinsicSignature', []) instanceof Enum\n        }, \"f\");\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return super.inspect({ method: true });\n    }\n    /**\n     * @description The block [[BlockHash]] the signature applies to (mortal/immortal)\n     */\n    get blockHash() {\n        return this.getT('blockHash');\n    }\n    /**\n     * @description The [[ExtrinsicEra]]\n     */\n    get era() {\n        return this.getT('era');\n    }\n    /**\n     * @description The genesis [[BlockHash]] the signature applies to (mortal/immortal)\n     */\n    get genesisHash() {\n        return this.getT('genesisHash');\n    }\n    /**\n     * @description The [[Bytes]] contained in the payload\n     */\n    get method() {\n        return this.getT('method');\n    }\n    /**\n     * @description The [[Index]]\n     */\n    get nonce() {\n        return this.getT('nonce');\n    }\n    /**\n     * @description The specVersion for this signature\n     */\n    get specVersion() {\n        return this.getT('specVersion');\n    }\n    /**\n     * @description The tip [[Balance]]\n     */\n    get tip() {\n        return this.getT('tip');\n    }\n    /**\n     * @description The transactionVersion for this signature\n     */\n    get transactionVersion() {\n        return this.getT('transactionVersion');\n    }\n    /**\n     * @description The (optional) asset id for this signature for chains that support transaction fees in assets\n     */\n    get assetId() {\n        return this.getT('assetId');\n    }\n    /**\n     * @description Sign the payload with the keypair\n     */\n    sign(signerPair) {\n        // NOTE The `toU8a({ method: true })` argument is absolutely critical, we\n        // don't want the method (Bytes) to have the length prefix included. This\n        // means that the data-as-signed is un-decodable, but is also doesn't need\n        // the extra information, only the pure data (and is not decoded) ...\n        // The same applies to V1..V3, if we have a V5, carry this comment\n        return sign(this.registry, signerPair, this.toU8a({ method: true }), __classPrivateFieldGet(this, _GenericExtrinsicPayloadV4_signOptions, \"f\"));\n    }\n}\n_GenericExtrinsicPayloadV4_signOptions = new WeakMap();\n"],"mappings":"AAAA,IAAIA,sCAAsC;AAC1C,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,OAAO;AACtE,SAASC,IAAI,EAAEC,MAAM,QAAQ,uBAAuB;AACpD,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,IAAI,QAAQ,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,yBAAyB,SAASH,MAAM,CAAC;EAClDI,WAAWA,CAACC,QAAQ,EAAEC,KAAK,EAAE;IACzB,KAAK,CAACD,QAAQ,EAAEJ,YAAY,CAAC;MAAEM,MAAM,EAAE;IAAQ,CAAC,EAAEF,QAAQ,CAACG,uBAAuB,EAAE,EAAEH,QAAQ,CAACI,uBAAuB,EAAE,CAAC,EAAEH,KAAK,CAAC;IACjIV,sCAAsC,CAACc,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACxD;IACA;IACA;IACAZ,sBAAsB,CAAC,IAAI,EAAEF,sCAAsC,EAAE;MACjEe,QAAQ,EAAEN,QAAQ,CAACO,gBAAgB,CAAC,oBAAoB,EAAE,EAAE,CAAC,YAAYb;IAC7E,CAAC,EAAE,GAAG,CAAC;EACX;EACA;AACJ;AACA;EACIc,OAAOA,CAAA,EAAG;IACN,OAAO,KAAK,CAACA,OAAO,CAAC;MAAEN,MAAM,EAAE;IAAK,CAAC,CAAC;EAC1C;EACA;AACJ;AACA;EACI,IAAIO,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,IAAI,CAAC,WAAW,CAAC;EACjC;EACA;AACJ;AACA;EACI,IAAIC,GAAGA,CAAA,EAAG;IACN,OAAO,IAAI,CAACD,IAAI,CAAC,KAAK,CAAC;EAC3B;EACA;AACJ;AACA;EACI,IAAIE,WAAWA,CAAA,EAAG;IACd,OAAO,IAAI,CAACF,IAAI,CAAC,aAAa,CAAC;EACnC;EACA;AACJ;AACA;EACI,IAAIR,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACQ,IAAI,CAAC,QAAQ,CAAC;EAC9B;EACA;AACJ;AACA;EACI,IAAIG,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACH,IAAI,CAAC,OAAO,CAAC;EAC7B;EACA;AACJ;AACA;EACI,IAAII,WAAWA,CAAA,EAAG;IACd,OAAO,IAAI,CAACJ,IAAI,CAAC,aAAa,CAAC;EACnC;EACA;AACJ;AACA;EACI,IAAIK,GAAGA,CAAA,EAAG;IACN,OAAO,IAAI,CAACL,IAAI,CAAC,KAAK,CAAC;EAC3B;EACA;AACJ;AACA;EACI,IAAIM,kBAAkBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAACN,IAAI,CAAC,oBAAoB,CAAC;EAC1C;EACA;AACJ;AACA;EACI,IAAIO,OAAOA,CAAA,EAAG;IACV,OAAO,IAAI,CAACP,IAAI,CAAC,SAAS,CAAC;EAC/B;EACA;AACJ;AACA;EACIb,IAAIA,CAACqB,UAAU,EAAE;IACb;IACA;IACA;IACA;IACA;IACA,OAAOrB,IAAI,CAAC,IAAI,CAACG,QAAQ,EAAEkB,UAAU,EAAE,IAAI,CAACC,KAAK,CAAC;MAAEjB,MAAM,EAAE;IAAK,CAAC,CAAC,EAAEV,sBAAsB,CAAC,IAAI,EAAED,sCAAsC,EAAE,GAAG,CAAC,CAAC;EACnJ;AACJ;AACAA,sCAAsC,GAAG,IAAI6B,OAAO,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}