{"ast":null,"code":"import { combineLatest, map, mergeMap, of, switchMap } from 'rxjs';\nimport { memo, unwrapBlockNumber } from '../util/index.js';\nexport function createBlockNumberDerive(fn) {\n  return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));\n}\n/** @internal */\nfunction getAuthorDetailsWithAt(header, queryAt) {\n  const validators = queryAt.session ? queryAt.session.validators() : of(null);\n  // nimbus consensus stores the session key of the block author in header logs\n  const {\n    logs: [log]\n  } = header.digest;\n  const loggedAuthor = log && (log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1] || log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1]);\n  if (loggedAuthor) {\n    // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key\n    if (queryAt.authorMapping && queryAt.authorMapping.mappingWithDeposit) {\n      return combineLatest([of(header), validators, queryAt.authorMapping.mappingWithDeposit(loggedAuthor).pipe(map(opt => opt.unwrapOr({\n        account: null\n      }).account))]);\n    }\n    // fall back to session and parachain staking pallets, if available (ie: manta, calamari), to map session (nimbus) key to author (collator) key\n    if (queryAt.parachainStaking && queryAt.parachainStaking.selectedCandidates && queryAt.session && queryAt.session.nextKeys && queryAt.session.nextKeys.multi) {\n      return combineLatest([of(header), validators, queryAt.parachainStaking.selectedCandidates().pipe(mergeMap(selectedCandidates => combineLatest([of(selectedCandidates), queryAt.session.nextKeys.multi(selectedCandidates).pipe(map(nextKeys => nextKeys.findIndex(option => option.unwrapOrDefault().nimbus.toHex() === loggedAuthor.toHex())))])), map(_ref => {\n        let [selectedCandidates, index] = _ref;\n        return selectedCandidates[index];\n      }))]);\n    }\n  }\n  // normal operation, non-mapping\n  return combineLatest([of(header), validators, of(null)]);\n}\nexport function getAuthorDetails(api, header, blockHash) {\n  // For on-chain state, we need to retrieve it as per the start\n  // of the block being constructed, i.e. session validators would\n  // be at the point of the block construction, not when all operations\n  // has been supplied.\n  //\n  // However for the first block (no parentHash available), we would\n  // just use the as-is\n  return api.queryAt(header.parentHash.isEmpty ? blockHash || header.hash : header.parentHash).pipe(switchMap(queryAt => getAuthorDetailsWithAt(header, queryAt)));\n}","map":{"version":3,"names":["combineLatest","map","mergeMap","of","switchMap","memo","unwrapBlockNumber","createBlockNumberDerive","fn","instanceId","api","pipe","getAuthorDetailsWithAt","header","queryAt","validators","session","logs","log","digest","loggedAuthor","isConsensus","asConsensus","isNimbus","isPreRuntime","asPreRuntime","authorMapping","mappingWithDeposit","opt","unwrapOr","account","parachainStaking","selectedCandidates","nextKeys","multi","findIndex","option","unwrapOrDefault","nimbus","toHex","_ref","index","getAuthorDetails","blockHash","parentHash","isEmpty","hash"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api-derive/chain/util.js"],"sourcesContent":["import { combineLatest, map, mergeMap, of, switchMap } from 'rxjs';\nimport { memo, unwrapBlockNumber } from '../util/index.js';\nexport function createBlockNumberDerive(fn) {\n    return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));\n}\n/** @internal */\nfunction getAuthorDetailsWithAt(header, queryAt) {\n    const validators = queryAt.session\n        ? queryAt.session.validators()\n        : of(null);\n    // nimbus consensus stores the session key of the block author in header logs\n    const { logs: [log] } = header.digest;\n    const loggedAuthor = (log && ((log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1]) ||\n        (log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1])));\n    if (loggedAuthor) {\n        // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key\n        if (queryAt.authorMapping && queryAt.authorMapping.mappingWithDeposit) {\n            return combineLatest([\n                of(header),\n                validators,\n                queryAt.authorMapping.mappingWithDeposit(loggedAuthor)\n                    .pipe(map((opt) => opt.unwrapOr({ account: null }).account))\n            ]);\n        }\n        // fall back to session and parachain staking pallets, if available (ie: manta, calamari), to map session (nimbus) key to author (collator) key\n        if (queryAt.parachainStaking && queryAt.parachainStaking.selectedCandidates && queryAt.session && queryAt.session.nextKeys && queryAt.session.nextKeys.multi) {\n            return combineLatest([\n                of(header),\n                validators,\n                queryAt.parachainStaking.selectedCandidates().pipe(mergeMap((selectedCandidates) => combineLatest([\n                    of(selectedCandidates),\n                    queryAt.session.nextKeys.multi(selectedCandidates).pipe(map((nextKeys) => nextKeys.findIndex((option) => option.unwrapOrDefault().nimbus.toHex() === loggedAuthor.toHex())))\n                ])), map(([selectedCandidates, index]) => selectedCandidates[index]))\n            ]);\n        }\n    }\n    // normal operation, non-mapping\n    return combineLatest([\n        of(header),\n        validators,\n        of(null)\n    ]);\n}\nexport function getAuthorDetails(api, header, blockHash) {\n    // For on-chain state, we need to retrieve it as per the start\n    // of the block being constructed, i.e. session validators would\n    // be at the point of the block construction, not when all operations\n    // has been supplied.\n    //\n    // However for the first block (no parentHash available), we would\n    // just use the as-is\n    return api.queryAt(header.parentHash.isEmpty\n        ? blockHash || header.hash\n        : header.parentHash).pipe(switchMap((queryAt) => getAuthorDetailsWithAt(header, queryAt)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}