{"ast":null,"code":"import { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { catchError, first, map, mergeMap, of, switchMap, tap } from 'rxjs';\nimport { isBn, isFunction, isNumber, isString, isU8a, objectSpread } from '@polkadot/util';\nimport { filterEvents, isKeyringPair } from '../util/index.js';\nimport { SubmittableResult } from './Result.js';\nconst identity = input => input;\nfunction makeEraOptions(api, registry, partialOptions, _ref) {\n  let {\n    header,\n    mortalLength,\n    nonce\n  } = _ref;\n  if (!header) {\n    if (partialOptions.era && !partialOptions.blockHash) {\n      throw new Error('Expected blockHash to be passed alongside non-immortal era options');\n    }\n    if (isNumber(partialOptions.era)) {\n      // since we have no header, it is immortal, remove any option overrides\n      // so we only supply the genesisHash and no era to the construction\n      delete partialOptions.era;\n      delete partialOptions.blockHash;\n    }\n    return makeSignOptions(api, partialOptions, {\n      nonce\n    });\n  }\n  return makeSignOptions(api, partialOptions, {\n    blockHash: header.hash,\n    era: registry.createTypeUnsafe('ExtrinsicEra', [{\n      current: header.number,\n      period: partialOptions.era || mortalLength\n    }]),\n    nonce\n  });\n}\nfunction makeSignAndSendOptions(partialOptions, statusCb) {\n  let options = {};\n  if (isFunction(partialOptions)) {\n    statusCb = partialOptions;\n  } else {\n    options = objectSpread({}, partialOptions);\n  }\n  return [options, statusCb];\n}\nfunction makeSignOptions(api, partialOptions, extras) {\n  return objectSpread({\n    blockHash: api.genesisHash,\n    genesisHash: api.genesisHash\n  }, partialOptions, extras, {\n    runtimeVersion: api.runtimeVersion,\n    signedExtensions: api.registry.signedExtensions,\n    version: api.extrinsicType\n  });\n}\nfunction optionsOrNonce() {\n  let partialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return isBn(partialOptions) || isNumber(partialOptions) ? {\n    nonce: partialOptions\n  } : partialOptions;\n}\nexport function createClass(_ref2) {\n  let {\n    api,\n    apiType,\n    blockHash,\n    decorateMethod\n  } = _ref2;\n  var _Submittable_ignoreStatusCb, _Submittable_transformResult, _Submittable_observeSign, _Submittable_observeStatus, _Submittable_observeSend, _Submittable_observeSubscribe, _Submittable_signViaSigner, _Submittable_updateSigner;\n  // an instance of the base extrinsic for us to extend\n  const ExtrinsicBase = api.registry.createClass('Extrinsic');\n  class Submittable extends ExtrinsicBase {\n    constructor(registry, extrinsic) {\n      super(registry, extrinsic, {\n        version: api.extrinsicType\n      });\n      _Submittable_ignoreStatusCb.set(this, void 0);\n      _Submittable_transformResult.set(this, identity);\n      _Submittable_observeSign.set(this, (account, partialOptions) => {\n        const address = isKeyringPair(account) ? account.address : account.toString();\n        const options = optionsOrNonce(partialOptions);\n        return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe(first(), mergeMap(async signingInfo => {\n          const eraOptions = makeEraOptions(api, this.registry, options, signingInfo);\n          let updateId = -1;\n          if (isKeyringPair(account)) {\n            this.sign(account, eraOptions);\n          } else {\n            updateId = await __classPrivateFieldGet(this, _Submittable_signViaSigner, \"f\").call(this, address, eraOptions, signingInfo.header);\n          }\n          return {\n            options: eraOptions,\n            updateId\n          };\n        }));\n      });\n      _Submittable_observeStatus.set(this, (txHash, status) => {\n        if (!status.isFinalized && !status.isInBlock) {\n          return of(__classPrivateFieldGet(this, _Submittable_transformResult, \"f\").call(this, new SubmittableResult({\n            status,\n            txHash\n          })));\n        }\n        const blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;\n        return api.derive.tx.events(blockHash).pipe(map(_ref3 => {\n          let {\n            block,\n            events\n          } = _ref3;\n          return __classPrivateFieldGet(this, _Submittable_transformResult, \"f\").call(this, new SubmittableResult({\n            ...filterEvents(txHash, block, events, status),\n            status,\n            txHash\n          }));\n        }), catchError(internalError => of(__classPrivateFieldGet(this, _Submittable_transformResult, \"f\").call(this, new SubmittableResult({\n          internalError,\n          status,\n          txHash\n        })))));\n      });\n      _Submittable_observeSend.set(this, info => {\n        return api.rpc.author.submitExtrinsic(this).pipe(tap(hash => {\n          __classPrivateFieldGet(this, _Submittable_updateSigner, \"f\").call(this, hash, info);\n        }));\n      });\n      _Submittable_observeSubscribe.set(this, info => {\n        const txHash = this.hash;\n        return api.rpc.author.submitAndWatchExtrinsic(this).pipe(switchMap(status => __classPrivateFieldGet(this, _Submittable_observeStatus, \"f\").call(this, txHash, status)), tap(status => {\n          __classPrivateFieldGet(this, _Submittable_updateSigner, \"f\").call(this, status, info);\n        }));\n      });\n      _Submittable_signViaSigner.set(this, async (address, options, header) => {\n        const signer = options.signer || api.signer;\n        if (!signer) {\n          throw new Error('No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n        }\n        const payload = this.registry.createTypeUnsafe('SignerPayload', [objectSpread({}, options, {\n          address,\n          blockNumber: header ? header.number : 0,\n          method: this.method\n        })]);\n        let result;\n        if (isFunction(signer.signPayload)) {\n          result = await signer.signPayload(payload.toPayload());\n        } else if (isFunction(signer.signRaw)) {\n          result = await signer.signRaw(payload.toRaw());\n        } else {\n          throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');\n        }\n        // Here we explicitly call `toPayload()` again instead of working with an object\n        // (reference) as passed to the signer. This means that we are sure that the\n        // payload data is not modified from our inputs, but the signer\n        super.addSignature(address, result.signature, payload.toPayload());\n        return result.id;\n      });\n      _Submittable_updateSigner.set(this, (status, info) => {\n        if (info && info.updateId !== -1) {\n          const {\n            options,\n            updateId\n          } = info;\n          const signer = options.signer || api.signer;\n          if (signer && isFunction(signer.update)) {\n            signer.update(updateId, status);\n          }\n        }\n      });\n      __classPrivateFieldSet(this, _Submittable_ignoreStatusCb, apiType === 'rxjs', \"f\");\n    }\n    get hasDryRun() {\n      return isFunction(api.rpc.system?.dryRun);\n    }\n    get hasPaymentInfo() {\n      return isFunction(api.call.transactionPaymentApi?.queryInfo);\n    }\n    // dry run an extrinsic\n    dryRun(account, optionsOrHash) {\n      if (!this.hasDryRun) {\n        throw new Error('The system.dryRun RPC call is not available in your environment');\n      }\n      if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod(() => api.rpc.system.dryRun(this.toHex(), blockHash || optionsOrHash));\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n      return decorateMethod(() => __classPrivateFieldGet(this, _Submittable_observeSign, \"f\").call(this, account, optionsOrHash).pipe(switchMap(() => api.rpc.system.dryRun(this.toHex()))))();\n    }\n    // calculate the payment info for this transaction (if signed and submitted)\n    paymentInfo(account, optionsOrHash) {\n      if (!this.hasPaymentInfo) {\n        throw new Error('The transactionPaymentApi.queryInfo runtime call is not available in your environment');\n      }\n      if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod(() => api.callAt(blockHash || optionsOrHash).pipe(switchMap(callAt => {\n          const u8a = this.toU8a();\n          return callAt.transactionPaymentApi.queryInfo(u8a, u8a.length);\n        })));\n      }\n      const [allOptions] = makeSignAndSendOptions(optionsOrHash);\n      const address = isKeyringPair(account) ? account.address : account.toString();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n      return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe(first(), switchMap(signingInfo => {\n        // setup our options (same way as in signAndSend)\n        const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo);\n        const signOptions = makeSignOptions(api, eraOptions, {});\n        const u8a = this.isSigned ? api.tx(this).signFake(address, signOptions).toU8a() : this.signFake(address, signOptions).toU8a();\n        return api.call.transactionPaymentApi.queryInfo(u8a, u8a.length);\n      })))();\n    }\n    // send implementation for both immediate Hash and statusCb variants\n    send(statusCb) {\n      const isSubscription = api.hasSubscriptions && (__classPrivateFieldGet(this, _Submittable_ignoreStatusCb, \"f\") || !!statusCb);\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n      return decorateMethod(isSubscription ? __classPrivateFieldGet(this, _Submittable_observeSubscribe, \"f\") : __classPrivateFieldGet(this, _Submittable_observeSend, \"f\"))(statusCb);\n    }\n    /**\n     * @description Signs a transaction, returning `this` to allow chaining. E.g.: `signAsync(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.\n     */\n    signAsync(account, partialOptions) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n      return decorateMethod(() => __classPrivateFieldGet(this, _Submittable_observeSign, \"f\").call(this, account, partialOptions).pipe(map(() => this)))();\n    }\n    // signAndSend implementation for all 3 cases above\n    signAndSend(account, partialOptions, optionalStatusCb) {\n      const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);\n      const isSubscription = api.hasSubscriptions && (__classPrivateFieldGet(this, _Submittable_ignoreStatusCb, \"f\") || !!statusCb);\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n      return decorateMethod(() => __classPrivateFieldGet(this, _Submittable_observeSign, \"f\").call(this, account, options).pipe(switchMap(info => isSubscription ? __classPrivateFieldGet(this, _Submittable_observeSubscribe, \"f\").call(this, info) : __classPrivateFieldGet(this, _Submittable_observeSend, \"f\").call(this, info))) // FIXME This is wrong, SubmittableResult is _not_ a codec\n      )(statusCb);\n    }\n    // adds a transform to the result, applied before result is returned\n    withResultTransform(transform) {\n      __classPrivateFieldSet(this, _Submittable_transformResult, transform, \"f\");\n      return this;\n    }\n  }\n  _Submittable_ignoreStatusCb = new WeakMap(), _Submittable_transformResult = new WeakMap(), _Submittable_observeSign = new WeakMap(), _Submittable_observeStatus = new WeakMap(), _Submittable_observeSend = new WeakMap(), _Submittable_observeSubscribe = new WeakMap(), _Submittable_signViaSigner = new WeakMap(), _Submittable_updateSigner = new WeakMap();\n  return Submittable;\n}","map":{"version":3,"names":["__classPrivateFieldGet","__classPrivateFieldSet","catchError","first","map","mergeMap","of","switchMap","tap","isBn","isFunction","isNumber","isString","isU8a","objectSpread","filterEvents","isKeyringPair","SubmittableResult","identity","input","makeEraOptions","api","registry","partialOptions","_ref","header","mortalLength","nonce","era","blockHash","Error","makeSignOptions","hash","createTypeUnsafe","current","number","period","makeSignAndSendOptions","statusCb","options","extras","genesisHash","runtimeVersion","signedExtensions","version","extrinsicType","optionsOrNonce","arguments","length","undefined","createClass","_ref2","apiType","decorateMethod","_Submittable_ignoreStatusCb","_Submittable_transformResult","_Submittable_observeSign","_Submittable_observeStatus","_Submittable_observeSend","_Submittable_observeSubscribe","_Submittable_signViaSigner","_Submittable_updateSigner","ExtrinsicBase","Submittable","constructor","extrinsic","set","account","address","toString","derive","tx","signingInfo","pipe","eraOptions","updateId","sign","call","txHash","status","isFinalized","isInBlock","asInBlock","asFinalized","events","_ref3","block","internalError","info","rpc","author","submitExtrinsic","submitAndWatchExtrinsic","signer","payload","blockNumber","method","result","signPayload","toPayload","signRaw","toRaw","addSignature","signature","id","update","hasDryRun","system","dryRun","hasPaymentInfo","transactionPaymentApi","queryInfo","optionsOrHash","toHex","paymentInfo","callAt","u8a","toU8a","allOptions","signOptions","isSigned","signFake","send","isSubscription","hasSubscriptions","signAsync","signAndSend","optionalStatusCb","withResultTransform","transform","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api/submittable/createClass.js"],"sourcesContent":["import { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { catchError, first, map, mergeMap, of, switchMap, tap } from 'rxjs';\nimport { isBn, isFunction, isNumber, isString, isU8a, objectSpread } from '@polkadot/util';\nimport { filterEvents, isKeyringPair } from '../util/index.js';\nimport { SubmittableResult } from './Result.js';\nconst identity = (input) => input;\nfunction makeEraOptions(api, registry, partialOptions, { header, mortalLength, nonce }) {\n    if (!header) {\n        if (partialOptions.era && !partialOptions.blockHash) {\n            throw new Error('Expected blockHash to be passed alongside non-immortal era options');\n        }\n        if (isNumber(partialOptions.era)) {\n            // since we have no header, it is immortal, remove any option overrides\n            // so we only supply the genesisHash and no era to the construction\n            delete partialOptions.era;\n            delete partialOptions.blockHash;\n        }\n        return makeSignOptions(api, partialOptions, { nonce });\n    }\n    return makeSignOptions(api, partialOptions, {\n        blockHash: header.hash,\n        era: registry.createTypeUnsafe('ExtrinsicEra', [{\n                current: header.number,\n                period: partialOptions.era || mortalLength\n            }]),\n        nonce\n    });\n}\nfunction makeSignAndSendOptions(partialOptions, statusCb) {\n    let options = {};\n    if (isFunction(partialOptions)) {\n        statusCb = partialOptions;\n    }\n    else {\n        options = objectSpread({}, partialOptions);\n    }\n    return [options, statusCb];\n}\nfunction makeSignOptions(api, partialOptions, extras) {\n    return objectSpread({ blockHash: api.genesisHash, genesisHash: api.genesisHash }, partialOptions, extras, { runtimeVersion: api.runtimeVersion, signedExtensions: api.registry.signedExtensions, version: api.extrinsicType });\n}\nfunction optionsOrNonce(partialOptions = {}) {\n    return isBn(partialOptions) || isNumber(partialOptions)\n        ? { nonce: partialOptions }\n        : partialOptions;\n}\nexport function createClass({ api, apiType, blockHash, decorateMethod }) {\n    var _Submittable_ignoreStatusCb, _Submittable_transformResult, _Submittable_observeSign, _Submittable_observeStatus, _Submittable_observeSend, _Submittable_observeSubscribe, _Submittable_signViaSigner, _Submittable_updateSigner;\n    // an instance of the base extrinsic for us to extend\n    const ExtrinsicBase = api.registry.createClass('Extrinsic');\n    class Submittable extends ExtrinsicBase {\n        constructor(registry, extrinsic) {\n            super(registry, extrinsic, { version: api.extrinsicType });\n            _Submittable_ignoreStatusCb.set(this, void 0);\n            _Submittable_transformResult.set(this, identity);\n            _Submittable_observeSign.set(this, (account, partialOptions) => {\n                const address = isKeyringPair(account) ? account.address : account.toString();\n                const options = optionsOrNonce(partialOptions);\n                return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe(first(), mergeMap(async (signingInfo) => {\n                    const eraOptions = makeEraOptions(api, this.registry, options, signingInfo);\n                    let updateId = -1;\n                    if (isKeyringPair(account)) {\n                        this.sign(account, eraOptions);\n                    }\n                    else {\n                        updateId = await __classPrivateFieldGet(this, _Submittable_signViaSigner, \"f\").call(this, address, eraOptions, signingInfo.header);\n                    }\n                    return { options: eraOptions, updateId };\n                }));\n            });\n            _Submittable_observeStatus.set(this, (txHash, status) => {\n                if (!status.isFinalized && !status.isInBlock) {\n                    return of(__classPrivateFieldGet(this, _Submittable_transformResult, \"f\").call(this, new SubmittableResult({\n                        status,\n                        txHash\n                    })));\n                }\n                const blockHash = status.isInBlock\n                    ? status.asInBlock\n                    : status.asFinalized;\n                return api.derive.tx.events(blockHash).pipe(map(({ block, events }) => __classPrivateFieldGet(this, _Submittable_transformResult, \"f\").call(this, new SubmittableResult({\n                    ...filterEvents(txHash, block, events, status),\n                    status,\n                    txHash\n                }))), catchError((internalError) => of(__classPrivateFieldGet(this, _Submittable_transformResult, \"f\").call(this, new SubmittableResult({\n                    internalError,\n                    status,\n                    txHash\n                })))));\n            });\n            _Submittable_observeSend.set(this, (info) => {\n                return api.rpc.author.submitExtrinsic(this).pipe(tap((hash) => {\n                    __classPrivateFieldGet(this, _Submittable_updateSigner, \"f\").call(this, hash, info);\n                }));\n            });\n            _Submittable_observeSubscribe.set(this, (info) => {\n                const txHash = this.hash;\n                return api.rpc.author.submitAndWatchExtrinsic(this).pipe(switchMap((status) => __classPrivateFieldGet(this, _Submittable_observeStatus, \"f\").call(this, txHash, status)), tap((status) => {\n                    __classPrivateFieldGet(this, _Submittable_updateSigner, \"f\").call(this, status, info);\n                }));\n            });\n            _Submittable_signViaSigner.set(this, async (address, options, header) => {\n                const signer = options.signer || api.signer;\n                if (!signer) {\n                    throw new Error('No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n                }\n                const payload = this.registry.createTypeUnsafe('SignerPayload', [objectSpread({}, options, {\n                        address,\n                        blockNumber: header ? header.number : 0,\n                        method: this.method\n                    })]);\n                let result;\n                if (isFunction(signer.signPayload)) {\n                    result = await signer.signPayload(payload.toPayload());\n                }\n                else if (isFunction(signer.signRaw)) {\n                    result = await signer.signRaw(payload.toRaw());\n                }\n                else {\n                    throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');\n                }\n                // Here we explicitly call `toPayload()` again instead of working with an object\n                // (reference) as passed to the signer. This means that we are sure that the\n                // payload data is not modified from our inputs, but the signer\n                super.addSignature(address, result.signature, payload.toPayload());\n                return result.id;\n            });\n            _Submittable_updateSigner.set(this, (status, info) => {\n                if (info && (info.updateId !== -1)) {\n                    const { options, updateId } = info;\n                    const signer = options.signer || api.signer;\n                    if (signer && isFunction(signer.update)) {\n                        signer.update(updateId, status);\n                    }\n                }\n            });\n            __classPrivateFieldSet(this, _Submittable_ignoreStatusCb, apiType === 'rxjs', \"f\");\n        }\n        get hasDryRun() {\n            return isFunction(api.rpc.system?.dryRun);\n        }\n        get hasPaymentInfo() {\n            return isFunction(api.call.transactionPaymentApi?.queryInfo);\n        }\n        // dry run an extrinsic\n        dryRun(account, optionsOrHash) {\n            if (!this.hasDryRun) {\n                throw new Error('The system.dryRun RPC call is not available in your environment');\n            }\n            if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return decorateMethod(() => api.rpc.system.dryRun(this.toHex(), blockHash || optionsOrHash));\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => __classPrivateFieldGet(this, _Submittable_observeSign, \"f\").call(this, account, optionsOrHash).pipe(switchMap(() => api.rpc.system.dryRun(this.toHex()))))();\n        }\n        // calculate the payment info for this transaction (if signed and submitted)\n        paymentInfo(account, optionsOrHash) {\n            if (!this.hasPaymentInfo) {\n                throw new Error('The transactionPaymentApi.queryInfo runtime call is not available in your environment');\n            }\n            if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return decorateMethod(() => api.callAt(blockHash || optionsOrHash).pipe(switchMap((callAt) => {\n                    const u8a = this.toU8a();\n                    return callAt.transactionPaymentApi.queryInfo(u8a, u8a.length);\n                })));\n            }\n            const [allOptions] = makeSignAndSendOptions(optionsOrHash);\n            const address = isKeyringPair(account) ? account.address : account.toString();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe(first(), switchMap((signingInfo) => {\n                // setup our options (same way as in signAndSend)\n                const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo);\n                const signOptions = makeSignOptions(api, eraOptions, {});\n                const u8a = this.isSigned\n                    ? api.tx(this).signFake(address, signOptions).toU8a()\n                    : this.signFake(address, signOptions).toU8a();\n                return api.call.transactionPaymentApi.queryInfo(u8a, u8a.length);\n            })))();\n        }\n        // send implementation for both immediate Hash and statusCb variants\n        send(statusCb) {\n            const isSubscription = api.hasSubscriptions && (__classPrivateFieldGet(this, _Submittable_ignoreStatusCb, \"f\") || !!statusCb);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(isSubscription\n                ? __classPrivateFieldGet(this, _Submittable_observeSubscribe, \"f\")\n                : __classPrivateFieldGet(this, _Submittable_observeSend, \"f\"))(statusCb);\n        }\n        /**\n         * @description Signs a transaction, returning `this` to allow chaining. E.g.: `signAsync(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.\n         */\n        signAsync(account, partialOptions) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => __classPrivateFieldGet(this, _Submittable_observeSign, \"f\").call(this, account, partialOptions).pipe(map(() => this)))();\n        }\n        // signAndSend implementation for all 3 cases above\n        signAndSend(account, partialOptions, optionalStatusCb) {\n            const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);\n            const isSubscription = api.hasSubscriptions && (__classPrivateFieldGet(this, _Submittable_ignoreStatusCb, \"f\") || !!statusCb);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => __classPrivateFieldGet(this, _Submittable_observeSign, \"f\").call(this, account, options).pipe(switchMap((info) => isSubscription\n                ? __classPrivateFieldGet(this, _Submittable_observeSubscribe, \"f\").call(this, info)\n                : __classPrivateFieldGet(this, _Submittable_observeSend, \"f\").call(this, info))) // FIXME This is wrong, SubmittableResult is _not_ a codec\n            )(statusCb);\n        }\n        // adds a transform to the result, applied before result is returned\n        withResultTransform(transform) {\n            __classPrivateFieldSet(this, _Submittable_transformResult, transform, \"f\");\n            return this;\n        }\n    }\n    _Submittable_ignoreStatusCb = new WeakMap(), _Submittable_transformResult = new WeakMap(), _Submittable_observeSign = new WeakMap(), _Submittable_observeStatus = new WeakMap(), _Submittable_observeSend = new WeakMap(), _Submittable_observeSubscribe = new WeakMap(), _Submittable_signViaSigner = new WeakMap(), _Submittable_updateSigner = new WeakMap();\n    return Submittable;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}