{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction parseRewards(api, stashId, _ref, exposures) {\n  let [erasPoints, erasPrefs, erasRewards] = _ref;\n  return exposures.map(_ref2 => {\n    let {\n      era,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators: eraValidators\n    } = _ref2;\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(_ref3 => {\n      let [validatorId, exposure] = _ref3;\n      const valPoints = allValPoints[validatorId] || BN_ZERO;\n      const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n      const expTotal = exposure.total?.unwrap() || BN_ZERO;\n      let avail = BN_ZERO;\n      let value;\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        const valCut = valComm.mul(avail).div(BN_BILLION);\n        let staked;\n        if (validatorId === stakerId) {\n          staked = exposure.own.unwrap();\n        } else {\n          const stakerExp = exposure.others.find(_ref4 => {\n            let {\n              who\n            } = _ref4;\n            return who.eq(stakerId);\n          });\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\nfunction allUniqValidators(rewards) {\n  return rewards.reduce((_ref5, rewards) => {\n    let [all, perStash] = _ref5;\n    const uniq = [];\n    perStash.push(uniq);\n    rewards.forEach(_ref6 => {\n      let {\n        validators\n      } = _ref6;\n      return Object.keys(validators).forEach(validatorId => {\n        if (!uniq.includes(validatorId)) {\n          uniq.push(validatorId);\n          if (!all.includes(validatorId)) {\n            all.push(validatorId);\n          }\n        }\n      });\n    });\n    return [all, perStash];\n  }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward) {\n  const rm = [];\n  Object.keys(reward.validators).forEach(validatorId => {\n    const index = validators.indexOf(validatorId);\n    if (index !== -1) {\n      const valLedger = queryValidators[index].stakingLedger;\n      if (valLedger?.claimedRewards.some(e => reward.era.eq(e))) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(validatorId => {\n    delete reward.validators[validatorId];\n  });\n}\nfunction filterRewards(eras, valInfo, _ref7) {\n  let {\n    rewards,\n    stakingLedger\n  } = _ref7;\n  const filter = eras.filter(e => !stakingLedger.claimedRewards.some(s => s.eq(e)));\n  const validators = valInfo.map(_ref8 => {\n    let [v] = _ref8;\n    return v;\n  });\n  const queryValidators = valInfo.map(_ref9 => {\n    let [, q] = _ref9;\n    return q;\n  });\n  return rewards.filter(_ref10 => {\n    let {\n      isEmpty\n    } = _ref10;\n    return !isEmpty;\n  }).filter(reward => {\n    if (!filter.some(e => reward.era.eq(e))) {\n      return false;\n    }\n    removeClaimed(validators, queryValidators, reward);\n    return true;\n  }).filter(_ref11 => {\n    let {\n      validators\n    } = _ref11;\n    return Object.keys(validators).length !== 0;\n  }).map(reward => objectSpread({}, reward, {\n    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])\n  }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, function (eras) {\n    let withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return combineLatest([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]);\n  });\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, function (accountIds, eras) {\n    let withActive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return combineLatest([api.derive.staking.queryMulti(accountIds, {\n      withLedger: true\n    }), api.derive.staking._stakerExposures(accountIds, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe(switchMap(_ref12 => {\n      let [queries, exposures, erasResult] = _ref12;\n      const allRewards = queries.map((_ref13, index) => {\n        let {\n          stakingLedger,\n          stashId\n        } = _ref13;\n        return !stashId || !stakingLedger ? [] : parseRewards(api, stashId, erasResult, exposures[index]);\n      });\n      if (withActive) {\n        return of(allRewards);\n      }\n      const [allValidators, stashValidators] = allUniqValidators(allRewards);\n      return api.derive.staking.queryMulti(allValidators, {\n        withLedger: true\n      }).pipe(map(queriedVals => queries.map((_ref14, index) => {\n        let {\n          stakingLedger\n        } = _ref14;\n        return filterRewards(eras, stashValidators[index].map(validatorId => [validatorId, queriedVals.find(q => q.accountId.eq(validatorId))]), {\n          rewards: allRewards[index],\n          stakingLedger\n        });\n      })));\n    }));\n  });\n}\nexport const stakerRewards = /*#__PURE__*/firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, function (accountIds) {\n    let withActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras)));\n  });\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","BN_BILLION","BN_ZERO","objectSpread","firstMemo","memo","parseRewards","api","stashId","_ref","exposures","erasPoints","erasPrefs","erasRewards","_ref2","era","isEmpty","isValidator","nominating","validators","eraValidators","eraPoints","allValPoints","find","p","eq","eraReward","r","registry","createType","allValPrefs","stakerId","toString","Object","entries","forEach","_ref3","validatorId","exposure","valPoints","valComm","commission","unwrap","expTotal","total","avail","value","isZero","mul","div","valCut","staked","own","stakerExp","others","_ref4","who","sub","imul","iadd","allUniqValidators","rewards","reduce","_ref5","all","perStash","uniq","push","_ref6","keys","includes","removeClaimed","queryValidators","reward","rm","index","indexOf","valLedger","stakingLedger","claimedRewards","some","e","filterRewards","eras","valInfo","_ref7","filter","s","_ref8","v","_ref9","q","_ref10","_ref11","length","nominators","n","_stakerRewardsEras","instanceId","withActive","arguments","undefined","derive","staking","_erasPoints","_erasPrefs","_erasRewards","_stakerRewards","accountIds","queryMulti","withLedger","_stakerExposures","pipe","_ref12","queries","erasResult","allRewards","_ref13","allValidators","stashValidators","queriedVals","_ref14","accountId","stakerRewards","erasHistoric","stakerRewardsMultiEras","stakerRewardsMulti"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api-derive/staking/stakerRewards.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {\n    return exposures.map(({ era, isEmpty, isValidator, nominating, validators: eraValidators }) => {\n        const { eraPoints, validators: allValPoints } = erasPoints.find((p) => p.era.eq(era)) || { eraPoints: BN_ZERO, validators: {} };\n        const { eraReward } = erasRewards.find((r) => r.era.eq(era)) || { eraReward: api.registry.createType('Balance') };\n        const { validators: allValPrefs } = erasPrefs.find((p) => p.era.eq(era)) || { validators: {} };\n        const validators = {};\n        const stakerId = stashId.toString();\n        Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n            const valPoints = allValPoints[validatorId] || BN_ZERO;\n            const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n            const expTotal = exposure.total?.unwrap() || BN_ZERO;\n            let avail = BN_ZERO;\n            let value;\n            if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n                avail = eraReward.mul(valPoints).div(eraPoints);\n                const valCut = valComm.mul(avail).div(BN_BILLION);\n                let staked;\n                if (validatorId === stakerId) {\n                    staked = exposure.own.unwrap();\n                }\n                else {\n                    const stakerExp = exposure.others.find(({ who }) => who.eq(stakerId));\n                    staked = stakerExp\n                        ? stakerExp.value.unwrap()\n                        : BN_ZERO;\n                }\n                value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n            }\n            validators[validatorId] = {\n                total: api.registry.createType('Balance', avail),\n                value: api.registry.createType('Balance', value)\n            };\n        });\n        return {\n            era,\n            eraReward,\n            isEmpty,\n            isValidator,\n            nominating,\n            validators\n        };\n    });\n}\nfunction allUniqValidators(rewards) {\n    return rewards.reduce(([all, perStash], rewards) => {\n        const uniq = [];\n        perStash.push(uniq);\n        rewards.forEach(({ validators }) => Object.keys(validators).forEach((validatorId) => {\n            if (!uniq.includes(validatorId)) {\n                uniq.push(validatorId);\n                if (!all.includes(validatorId)) {\n                    all.push(validatorId);\n                }\n            }\n        }));\n        return [all, perStash];\n    }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward) {\n    const rm = [];\n    Object.keys(reward.validators).forEach((validatorId) => {\n        const index = validators.indexOf(validatorId);\n        if (index !== -1) {\n            const valLedger = queryValidators[index].stakingLedger;\n            if (valLedger?.claimedRewards.some((e) => reward.era.eq(e))) {\n                rm.push(validatorId);\n            }\n        }\n    });\n    rm.forEach((validatorId) => {\n        delete reward.validators[validatorId];\n    });\n}\nfunction filterRewards(eras, valInfo, { rewards, stakingLedger }) {\n    const filter = eras.filter((e) => !stakingLedger.claimedRewards.some((s) => s.eq(e)));\n    const validators = valInfo.map(([v]) => v);\n    const queryValidators = valInfo.map(([, q]) => q);\n    return rewards\n        .filter(({ isEmpty }) => !isEmpty)\n        .filter((reward) => {\n        if (!filter.some((e) => reward.era.eq(e))) {\n            return false;\n        }\n        removeClaimed(validators, queryValidators, reward);\n        return true;\n    })\n        .filter(({ validators }) => Object.keys(validators).length !== 0)\n        .map((reward) => objectSpread({}, reward, {\n        nominators: reward.nominating.filter((n) => reward.validators[n.validatorId])\n    }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n    return memo(instanceId, (eras, withActive = false) => combineLatest([\n        api.derive.staking._erasPoints(eras, withActive),\n        api.derive.staking._erasPrefs(eras, withActive),\n        api.derive.staking._erasRewards(eras, withActive)\n    ]));\n}\nexport function _stakerRewards(instanceId, api) {\n    return memo(instanceId, (accountIds, eras, withActive = false) => combineLatest([\n        api.derive.staking.queryMulti(accountIds, { withLedger: true }),\n        api.derive.staking._stakerExposures(accountIds, eras, withActive),\n        api.derive.staking._stakerRewardsEras(eras, withActive)\n    ]).pipe(switchMap(([queries, exposures, erasResult]) => {\n        const allRewards = queries.map(({ stakingLedger, stashId }, index) => (!stashId || !stakingLedger)\n            ? []\n            : parseRewards(api, stashId, erasResult, exposures[index]));\n        if (withActive) {\n            return of(allRewards);\n        }\n        const [allValidators, stashValidators] = allUniqValidators(allRewards);\n        return api.derive.staking.queryMulti(allValidators, { withLedger: true }).pipe(map((queriedVals) => queries.map(({ stakingLedger }, index) => filterRewards(eras, stashValidators[index].map((validatorId) => [\n            validatorId,\n            queriedVals.find((q) => q.accountId.eq(validatorId))\n        ]), {\n            rewards: allRewards[index],\n            stakingLedger\n        }))));\n    })));\n}\nexport const stakerRewards = /*#__PURE__*/ firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n    return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length\n        ? api.derive.staking._stakerRewards(accountIds, eras, false)\n        : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n    return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}