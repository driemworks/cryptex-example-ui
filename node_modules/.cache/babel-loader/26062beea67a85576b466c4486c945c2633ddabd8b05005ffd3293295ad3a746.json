{"ast":null,"code":"var _Float_bitLength;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { floatToU8a, isHex, isU8a, u8aToFloat, u8aToHex, u8aToU8a } from '@polkadot/util';\n/**\n * @name Float\n * @description\n * A Codec wrapper for F32 & F64 values. You generally don't want to be using\n * f32/f64 in your runtime, operations on fixed points numbers are preferable. This class\n * was explicitly added since scale-codec has a flag that enables this and it is available\n * in some eth_* RPCs\n */\nexport class Float extends Number {\n  constructor(registry, value) {\n    let {\n      bitLength = 32\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(isU8a(value) || isHex(value) ? value.length === 0 ? 0 : u8aToFloat(u8aToU8a(value), {\n      bitLength\n    }) : value || 0);\n    _Float_bitLength.set(this, void 0);\n    __classPrivateFieldSet(this, _Float_bitLength, bitLength, \"f\");\n    this.encodedLength = bitLength / 8;\n    this.initialU8aLength = this.encodedLength;\n    this.registry = registry;\n  }\n  static with(bitLength) {\n    return class extends Float {\n      constructor(registry, value) {\n        super(registry, value, {\n          bitLength\n        });\n      }\n    };\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Returns true if the type wraps an empty/default all-0 value\n   */\n  get isEmpty() {\n    return this.valueOf() === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return this.valueOf() === Number(other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [this.toU8a()]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toString();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    // Not sure if this is actually a hex or a string value\n    // (would need to check against RPCs to see the result here)\n    return this.toHex();\n  }\n  /**\n   * @description Returns the number representation (Same as valueOf)\n   */\n  toNumber() {\n    return this.valueOf();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `f${__classPrivateFieldGet(this, _Float_bitLength, \"f\")}`;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a(_isBare) {\n    return floatToU8a(this, {\n      bitLength: __classPrivateFieldGet(this, _Float_bitLength, \"f\")\n    });\n  }\n}\n_Float_bitLength = new WeakMap();","map":{"version":3,"names":["_Float_bitLength","__classPrivateFieldGet","__classPrivateFieldSet","floatToU8a","isHex","isU8a","u8aToFloat","u8aToHex","u8aToU8a","Float","Number","constructor","registry","value","bitLength","arguments","length","undefined","set","encodedLength","initialU8aLength","with","hash","toU8a","isEmpty","valueOf","eq","other","inspect","outer","toHex","toHuman","toString","toJSON","toNumber","toPrimitive","toRawType","_isBare","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/native/Float.js"],"sourcesContent":["var _Float_bitLength;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { floatToU8a, isHex, isU8a, u8aToFloat, u8aToHex, u8aToU8a } from '@polkadot/util';\n/**\n * @name Float\n * @description\n * A Codec wrapper for F32 & F64 values. You generally don't want to be using\n * f32/f64 in your runtime, operations on fixed points numbers are preferable. This class\n * was explicitly added since scale-codec has a flag that enables this and it is available\n * in some eth_* RPCs\n */\nexport class Float extends Number {\n    constructor(registry, value, { bitLength = 32 } = {}) {\n        super(isU8a(value) || isHex(value)\n            ? value.length === 0\n                ? 0\n                : u8aToFloat(u8aToU8a(value), { bitLength })\n            : (value || 0));\n        _Float_bitLength.set(this, void 0);\n        __classPrivateFieldSet(this, _Float_bitLength, bitLength, \"f\");\n        this.encodedLength = bitLength / 8;\n        this.initialU8aLength = this.encodedLength;\n        this.registry = registry;\n    }\n    static with(bitLength) {\n        return class extends Float {\n            constructor(registry, value) {\n                super(registry, value, { bitLength });\n            }\n        };\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Returns true if the type wraps an empty/default all-0 value\n     */\n    get isEmpty() {\n        return this.valueOf() === 0;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return this.valueOf() === Number(other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toString();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        // Not sure if this is actually a hex or a string value\n        // (would need to check against RPCs to see the result here)\n        return this.toHex();\n    }\n    /**\n     * @description Returns the number representation (Same as valueOf)\n     */\n    toNumber() {\n        return this.valueOf();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toNumber();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `f${__classPrivateFieldGet(this, _Float_bitLength, \"f\")}`;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return floatToU8a(this, {\n            bitLength: __classPrivateFieldGet(this, _Float_bitLength, \"f\")\n        });\n    }\n}\n_Float_bitLength = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}