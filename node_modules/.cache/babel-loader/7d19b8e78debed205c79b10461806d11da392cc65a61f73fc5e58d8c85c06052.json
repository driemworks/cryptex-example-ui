{"ast":null,"code":"import { bnToBn, objectSpread } from '@polkadot/util';\nimport typesChain from './chain/index.js';\nimport typesSpec from './spec/index.js';\nimport upgrades from './upgrades/index.js';\n/**\n * @description Perform the callback function using the stringified spec/chain\n * @internal\n * */\nfunction withNames(chainName, specName, fn) {\n  return fn(chainName.toString(), specName.toString());\n}\n/**\n * @descriptionFflatten a VersionedType[] into a Record<string, string>\n * @internal\n * */\nfunction filterVersions() {\n  let versions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let specVersion = arguments.length > 1 ? arguments[1] : undefined;\n  return versions.filter(_ref => {\n    let {\n      minmax: [min, max]\n    } = _ref;\n    return (min === undefined || min === null || specVersion >= min) && (max === undefined || max === null || specVersion <= max);\n  }).reduce((result, _ref2) => {\n    let {\n      types\n    } = _ref2;\n    return objectSpread(result, types);\n  }, {});\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable signed extensions (ready for registration)\n */\nexport function getSpecExtensions(_ref3, chainName, specName) {\n  let {\n    knownTypes\n  } = _ref3;\n  return withNames(chainName, specName, (c, s) => objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.signedExtensions, knownTypes.typesBundle?.chain?.[c]?.signedExtensions));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable types (ready for registration)\n */\nexport function getSpecTypes(_ref4, chainName, specName, specVersion) {\n  let {\n    knownTypes\n  } = _ref4;\n  const _specVersion = bnToBn(specVersion).toNumber();\n  return withNames(chainName, specName, (c, s) =>\n  // The order here is always, based on -\n  //   - spec then chain\n  //   - typesBundle takes higher precedence\n  //   - types is the final catch-all override\n  objectSpread({}, filterVersions(typesSpec[s], _specVersion), filterVersions(typesChain[c], _specVersion), filterVersions(knownTypes.typesBundle?.spec?.[s]?.types, _specVersion), filterVersions(knownTypes.typesBundle?.chain?.[c]?.types, _specVersion), knownTypes.typesSpec?.[s], knownTypes.typesChain?.[c], knownTypes.types));\n}\n/**\n * @description Based on the chain or spec, return the hasher used\n */\nexport function getSpecHasher(_ref5, chainName, specName) {\n  let {\n    knownTypes\n  } = _ref5;\n  return withNames(chainName, specName, (c, s) => knownTypes.hasher || knownTypes.typesBundle?.chain?.[c]?.hasher || knownTypes.typesBundle?.spec?.[s]?.hasher || null);\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable rpc definitions (ready for registration)\n */\nexport function getSpecRpc(_ref6, chainName, specName) {\n  let {\n    knownTypes\n  } = _ref6;\n  return withNames(chainName, specName, (c, s) => objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.rpc, knownTypes.typesBundle?.chain?.[c]?.rpc));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable runtime definitions (ready for registration)\n */\nexport function getSpecRuntime(_ref7, chainName, specName) {\n  let {\n    knownTypes\n  } = _ref7;\n  return withNames(chainName, specName, (c, s) => objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.runtime, knownTypes.typesBundle?.chain?.[c]?.runtime));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable alias definitions (ready for registration)\n */\nexport function getSpecAlias(_ref8, chainName, specName) {\n  let {\n    knownTypes\n  } = _ref8;\n  return withNames(chainName, specName, (c, s) =>\n  // as per versions, first spec, then chain then finally non-versioned\n  objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.alias, knownTypes.typesBundle?.chain?.[c]?.alias, knownTypes.typesAlias));\n}\n/**\n * @description Returns a version record for known chains where upgrades are being tracked\n */\nexport function getUpgradeVersion(genesisHash, blockNumber) {\n  const known = upgrades.find(u => genesisHash.eq(u.genesisHash));\n  return known ? [known.versions.reduce((last, version) => {\n    return blockNumber.gt(version.blockNumber) ? version : last;\n  }, undefined), known.versions.find(version => blockNumber.lte(version.blockNumber))] : [undefined, undefined];\n}","map":{"version":3,"names":["bnToBn","objectSpread","typesChain","typesSpec","upgrades","withNames","chainName","specName","fn","toString","filterVersions","versions","arguments","length","undefined","specVersion","filter","_ref","minmax","min","max","reduce","result","_ref2","types","getSpecExtensions","_ref3","knownTypes","c","s","typesBundle","spec","signedExtensions","chain","getSpecTypes","_ref4","_specVersion","toNumber","getSpecHasher","_ref5","hasher","getSpecRpc","_ref6","rpc","getSpecRuntime","_ref7","runtime","getSpecAlias","_ref8","alias","typesAlias","getUpgradeVersion","genesisHash","blockNumber","known","find","u","eq","last","version","gt","lte"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-known/util.js"],"sourcesContent":["import { bnToBn, objectSpread } from '@polkadot/util';\nimport typesChain from './chain/index.js';\nimport typesSpec from './spec/index.js';\nimport upgrades from './upgrades/index.js';\n/**\n * @description Perform the callback function using the stringified spec/chain\n * @internal\n * */\nfunction withNames(chainName, specName, fn) {\n    return fn(chainName.toString(), specName.toString());\n}\n/**\n * @descriptionFflatten a VersionedType[] into a Record<string, string>\n * @internal\n * */\nfunction filterVersions(versions = [], specVersion) {\n    return versions\n        .filter(({ minmax: [min, max] }) => (min === undefined || min === null || specVersion >= min) &&\n        (max === undefined || max === null || specVersion <= max))\n        .reduce((result, { types }) => objectSpread(result, types), {});\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable signed extensions (ready for registration)\n */\nexport function getSpecExtensions({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.signedExtensions, knownTypes.typesBundle?.chain?.[c]?.signedExtensions));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable types (ready for registration)\n */\nexport function getSpecTypes({ knownTypes }, chainName, specName, specVersion) {\n    const _specVersion = bnToBn(specVersion).toNumber();\n    return withNames(chainName, specName, (c, s) => \n    // The order here is always, based on -\n    //   - spec then chain\n    //   - typesBundle takes higher precedence\n    //   - types is the final catch-all override\n    objectSpread({}, filterVersions(typesSpec[s], _specVersion), filterVersions(typesChain[c], _specVersion), filterVersions(knownTypes.typesBundle?.spec?.[s]?.types, _specVersion), filterVersions(knownTypes.typesBundle?.chain?.[c]?.types, _specVersion), knownTypes.typesSpec?.[s], knownTypes.typesChain?.[c], knownTypes.types));\n}\n/**\n * @description Based on the chain or spec, return the hasher used\n */\nexport function getSpecHasher({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => knownTypes.hasher ||\n        knownTypes.typesBundle?.chain?.[c]?.hasher ||\n        knownTypes.typesBundle?.spec?.[s]?.hasher ||\n        null);\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable rpc definitions (ready for registration)\n */\nexport function getSpecRpc({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.rpc, knownTypes.typesBundle?.chain?.[c]?.rpc));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable runtime definitions (ready for registration)\n */\nexport function getSpecRuntime({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.runtime, knownTypes.typesBundle?.chain?.[c]?.runtime));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable alias definitions (ready for registration)\n */\nexport function getSpecAlias({ knownTypes }, chainName, specName) {\n    return withNames(chainName, specName, (c, s) => \n    // as per versions, first spec, then chain then finally non-versioned\n    objectSpread({}, knownTypes.typesBundle?.spec?.[s]?.alias, knownTypes.typesBundle?.chain?.[c]?.alias, knownTypes.typesAlias));\n}\n/**\n * @description Returns a version record for known chains where upgrades are being tracked\n */\nexport function getUpgradeVersion(genesisHash, blockNumber) {\n    const known = upgrades.find((u) => genesisHash.eq(u.genesisHash));\n    return known\n        ? [\n            known.versions.reduce((last, version) => {\n                return blockNumber.gt(version.blockNumber)\n                    ? version\n                    : last;\n            }, undefined),\n            known.versions.find((version) => blockNumber.lte(version.blockNumber))\n        ]\n        : [undefined, undefined];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}