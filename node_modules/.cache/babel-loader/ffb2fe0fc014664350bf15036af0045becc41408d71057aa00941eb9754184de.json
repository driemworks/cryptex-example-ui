{"ast":null,"code":"var _VecFixed_Type;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { isU8a, u8aConcatStrict } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nimport { decodeVec } from './Vec.js';\nfunction noopSetDefinition(d) {\n  return d;\n}\n/**\n * @name VecFixed\n * @description\n * This manages codec arrays of a fixed length\n */\nexport class VecFixed extends AbstractArray {\n  constructor(registry, Type, length) {\n    let value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let {\n      definition,\n      setDefinition = noopSetDefinition\n    } = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    super(registry, length);\n    _VecFixed_Type.set(this, void 0);\n    __classPrivateFieldSet(this, _VecFixed_Type, definition || setDefinition(typeToConstructor(registry, Type)), \"f\");\n    this.initialU8aLength = (isU8a(value) ? decodeU8aVec(registry, this, value, 0, __classPrivateFieldGet(this, _VecFixed_Type, \"f\")) : decodeVec(registry, this, value, 0, __classPrivateFieldGet(this, _VecFixed_Type, \"f\")))[1];\n  }\n  static with(Type, length) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends VecFixed {\n      constructor(registry, value) {\n        super(registry, Type, length, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n  get Type() {\n    return new (__classPrivateFieldGet(this, _VecFixed_Type, \"f\"))(this.registry).toRawType();\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let total = 0;\n    for (let i = 0; i < this.length; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner()\n    };\n  }\n  toU8a() {\n    // we override, we don't add the length prefix for ourselves, and at the same time we\n    // ignore isBare on entries, since they should be properly encoded at all times\n    const encoded = this.toU8aInner();\n    return encoded.length ? u8aConcatStrict(encoded) : new Uint8Array([]);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `[${this.Type};${this.length}]`;\n  }\n}\n_VecFixed_Type = new WeakMap();","map":{"version":3,"names":["_VecFixed_Type","__classPrivateFieldGet","__classPrivateFieldSet","isU8a","u8aConcatStrict","AbstractArray","decodeU8aVec","typeToConstructor","decodeVec","noopSetDefinition","d","VecFixed","constructor","registry","Type","length","value","arguments","undefined","definition","setDefinition","set","initialU8aLength","with","toRawType","encodedLength","total","i","inspect","inner","inspectInner","toU8a","encoded","toU8aInner","Uint8Array","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/base/VecFixed.js"],"sourcesContent":["var _VecFixed_Type;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { isU8a, u8aConcatStrict } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nimport { decodeVec } from './Vec.js';\nfunction noopSetDefinition(d) {\n    return d;\n}\n/**\n * @name VecFixed\n * @description\n * This manages codec arrays of a fixed length\n */\nexport class VecFixed extends AbstractArray {\n    constructor(registry, Type, length, value = [], { definition, setDefinition = noopSetDefinition } = {}) {\n        super(registry, length);\n        _VecFixed_Type.set(this, void 0);\n        __classPrivateFieldSet(this, _VecFixed_Type, definition || setDefinition(typeToConstructor(registry, Type)), \"f\");\n        this.initialU8aLength = (isU8a(value)\n            ? decodeU8aVec(registry, this, value, 0, __classPrivateFieldGet(this, _VecFixed_Type, \"f\"))\n            : decodeVec(registry, this, value, 0, __classPrivateFieldGet(this, _VecFixed_Type, \"f\")))[1];\n    }\n    static with(Type, length) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends VecFixed {\n            constructor(registry, value) {\n                super(registry, Type, length, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The type for the items\n     */\n    get Type() {\n        return new (__classPrivateFieldGet(this, _VecFixed_Type, \"f\"))(this.registry).toRawType();\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (let i = 0; i < this.length; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner()\n        };\n    }\n    toU8a() {\n        // we override, we don't add the length prefix for ourselves, and at the same time we\n        // ignore isBare on entries, since they should be properly encoded at all times\n        const encoded = this.toU8aInner();\n        return encoded.length\n            ? u8aConcatStrict(encoded)\n            : new Uint8Array([]);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `[${this.Type};${this.length}]`;\n    }\n}\n_VecFixed_Type = new WeakMap();\n"],"mappings":"AAAA,IAAIA,cAAc;AAClB,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,OAAO;AACtE,SAASC,KAAK,EAAEC,eAAe,QAAQ,gBAAgB;AACvD,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,YAAY,EAAEC,iBAAiB,QAAQ,mBAAmB;AACnE,SAASC,SAAS,QAAQ,UAAU;AACpC,SAASC,iBAAiBA,CAACC,CAAC,EAAE;EAC1B,OAAOA,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,SAASN,aAAa,CAAC;EACxCO,WAAWA,CAACC,QAAQ,EAAEC,IAAI,EAAEC,MAAM,EAAsE;IAAA,IAApEC,KAAK,GAAAC,SAAA,CAAAF,MAAA,QAAAE,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;IAAA,IAAE;MAAEE,UAAU;MAAEC,aAAa,GAAGX;IAAkB,CAAC,GAAAQ,SAAA,CAAAF,MAAA,QAAAE,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IAClG,KAAK,CAACJ,QAAQ,EAAEE,MAAM,CAAC;IACvBf,cAAc,CAACqB,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAChCnB,sBAAsB,CAAC,IAAI,EAAEF,cAAc,EAAEmB,UAAU,IAAIC,aAAa,CAACb,iBAAiB,CAACM,QAAQ,EAAEC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC;IACjH,IAAI,CAACQ,gBAAgB,GAAG,CAACnB,KAAK,CAACa,KAAK,CAAC,GAC/BV,YAAY,CAACO,QAAQ,EAAE,IAAI,EAAEG,KAAK,EAAE,CAAC,EAAEf,sBAAsB,CAAC,IAAI,EAAED,cAAc,EAAE,GAAG,CAAC,CAAC,GACzFQ,SAAS,CAACK,QAAQ,EAAE,IAAI,EAAEG,KAAK,EAAE,CAAC,EAAEf,sBAAsB,CAAC,IAAI,EAAED,cAAc,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EACpG;EACA,OAAOuB,IAAIA,CAACT,IAAI,EAAEC,MAAM,EAAE;IACtB,IAAII,UAAU;IACd;IACA,MAAMC,aAAa,GAAIV,CAAC,IAAMS,UAAU,GAAGT,CAAE;IAC7C,OAAO,cAAcC,QAAQ,CAAC;MAC1BC,WAAWA,CAACC,QAAQ,EAAEG,KAAK,EAAE;QACzB,KAAK,CAACH,QAAQ,EAAEC,IAAI,EAAEC,MAAM,EAAEC,KAAK,EAAE;UAAEG,UAAU;UAAEC;QAAc,CAAC,CAAC;MACvE;IACJ,CAAC;EACL;EACA;AACJ;AACA;EACI,IAAIN,IAAIA,CAAA,EAAG;IACP,OAAO,KAAKb,sBAAsB,CAAC,IAAI,EAAED,cAAc,EAAE,GAAG,CAAC,EAAE,IAAI,CAACa,QAAQ,CAAC,CAACW,SAAS,EAAE;EAC7F;EACA;AACJ;AACA;EACI,IAAIC,aAAaA,CAAA,EAAG;IAChB,IAAIC,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACZ,MAAM,EAAEY,CAAC,EAAE,EAAE;MAClCD,KAAK,IAAI,IAAI,CAACC,CAAC,CAAC,CAACF,aAAa;IAClC;IACA,OAAOC,KAAK;EAChB;EACA;AACJ;AACA;EACIE,OAAOA,CAAA,EAAG;IACN,OAAO;MACHC,KAAK,EAAE,IAAI,CAACC,YAAY;IAC5B,CAAC;EACL;EACAC,KAAKA,CAAA,EAAG;IACJ;IACA;IACA,MAAMC,OAAO,GAAG,IAAI,CAACC,UAAU,EAAE;IACjC,OAAOD,OAAO,CAACjB,MAAM,GACfX,eAAe,CAAC4B,OAAO,CAAC,GACxB,IAAIE,UAAU,CAAC,EAAE,CAAC;EAC5B;EACA;AACJ;AACA;EACIV,SAASA,CAAA,EAAG;IACR,OAAQ,IAAG,IAAI,CAACV,IAAK,IAAG,IAAI,CAACC,MAAO,GAAE;EAC1C;AACJ;AACAf,cAAc,GAAG,IAAImC,OAAO,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}