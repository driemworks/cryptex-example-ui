{"ast":null,"code":"var _BTreeSet_ValClass;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8aLim, compactToU8a, isHex, isU8a, logger, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareSet, decodeU8aVec, sortSet, typeToConstructor } from '../utils/index.js';\nconst l = logger('BTreeSet');\n/** @internal */\nfunction decodeSetFromU8a(registry, ValClass, u8a) {\n  const output = new Set();\n  const [offset, count] = compactFromU8aLim(u8a);\n  const result = new Array(count);\n  const [decodedLength] = decodeU8aVec(registry, result, u8a, offset, ValClass);\n  for (let i = 0; i < count; i++) {\n    output.add(result[i]);\n  }\n  return [ValClass, output, decodedLength];\n}\n/** @internal */\nfunction decodeSetFromSet(registry, ValClass, value) {\n  const output = new Set();\n  value.forEach(val => {\n    try {\n      output.add(val instanceof ValClass ? val : new ValClass(registry, val));\n    } catch (error) {\n      l.error('Failed to decode key or value:', error.message);\n      throw error;\n    }\n  });\n  return [ValClass, output, 0];\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Set<any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonSet\n * @internal\n */\nfunction decodeSet(registry, valType, value) {\n  const ValClass = typeToConstructor(registry, valType);\n  if (!value) {\n    return [ValClass, new Set(), 0];\n  } else if (isU8a(value) || isHex(value)) {\n    return decodeSetFromU8a(registry, ValClass, u8aToU8a(value));\n  } else if (Array.isArray(value) || value instanceof Set) {\n    return decodeSetFromSet(registry, ValClass, value);\n  }\n  throw new Error('BTreeSet: cannot decode type');\n}\nexport class BTreeSet extends Set {\n  constructor(registry, valType, rawValue) {\n    const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);\n    super(sortSet(values));\n    _BTreeSet_ValClass.set(this, void 0);\n    this.registry = registry;\n    this.initialU8aLength = decodedLength;\n    __classPrivateFieldSet(this, _BTreeSet_ValClass, ValClass, \"f\");\n  }\n  static with(valType) {\n    return class extends BTreeSet {\n      constructor(registry, value) {\n        super(registry, valType, value);\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let len = compactToU8a(this.size).length;\n    for (const v of this.values()) {\n      len += v.encodedLength;\n    }\n    return len;\n  }\n  /**\n   * @description Returns a hash of the value\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.size === 0;\n  }\n  /**\n   * @description The actual set values as a string[]\n   */\n  get strings() {\n    return [...super.values()].map(v => v.toString());\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareSet(this, other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const inner = new Array();\n    for (const v of this.values()) {\n      inner.push(v.inspect());\n    }\n    return {\n      inner,\n      outer: [compactToU8a(this.size)]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended) {\n    const json = [];\n    for (const v of this.values()) {\n      json.push(v.toHuman(isExtended));\n    }\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const json = [];\n    for (const v of this.values()) {\n      json.push(v.toJSON());\n    }\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `BTreeSet<${this.registry.getClassName(__classPrivateFieldGet(this, _BTreeSet_ValClass, \"f\")) || new (__classPrivateFieldGet(this, _BTreeSet_ValClass, \"f\"))(this.registry).toRawType()}>`;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    const json = [];\n    for (const v of this.values()) {\n      json.push(v.toPrimitive());\n    }\n    return json;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = new Array();\n    if (!isBare) {\n      encoded.push(compactToU8a(this.size));\n    }\n    for (const v of this.values()) {\n      encoded.push(v.toU8a(isBare));\n    }\n    return u8aConcatStrict(encoded);\n  }\n}\n_BTreeSet_ValClass = new WeakMap();","map":{"version":3,"names":["_BTreeSet_ValClass","__classPrivateFieldGet","__classPrivateFieldSet","compactFromU8aLim","compactToU8a","isHex","isU8a","logger","stringify","u8aConcatStrict","u8aToHex","u8aToU8a","compareSet","decodeU8aVec","sortSet","typeToConstructor","l","decodeSetFromU8a","registry","ValClass","u8a","output","Set","offset","count","result","Array","decodedLength","i","add","decodeSetFromSet","value","forEach","val","error","message","decodeSet","valType","isArray","Error","BTreeSet","constructor","rawValue","values","set","initialU8aLength","with","encodedLength","len","size","length","v","hash","toU8a","isEmpty","strings","map","toString","eq","other","inspect","inner","push","outer","toHex","toHuman","isExtended","json","toJSON","toRawType","getClassName","toPrimitive","isBare","encoded","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/extended/BTreeSet.js"],"sourcesContent":["var _BTreeSet_ValClass;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8aLim, compactToU8a, isHex, isU8a, logger, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareSet, decodeU8aVec, sortSet, typeToConstructor } from '../utils/index.js';\nconst l = logger('BTreeSet');\n/** @internal */\nfunction decodeSetFromU8a(registry, ValClass, u8a) {\n    const output = new Set();\n    const [offset, count] = compactFromU8aLim(u8a);\n    const result = new Array(count);\n    const [decodedLength] = decodeU8aVec(registry, result, u8a, offset, ValClass);\n    for (let i = 0; i < count; i++) {\n        output.add(result[i]);\n    }\n    return [ValClass, output, decodedLength];\n}\n/** @internal */\nfunction decodeSetFromSet(registry, ValClass, value) {\n    const output = new Set();\n    value.forEach((val) => {\n        try {\n            output.add((val instanceof ValClass) ? val : new ValClass(registry, val));\n        }\n        catch (error) {\n            l.error('Failed to decode key or value:', error.message);\n            throw error;\n        }\n    });\n    return [ValClass, output, 0];\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Set<any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonSet\n * @internal\n */\nfunction decodeSet(registry, valType, value) {\n    const ValClass = typeToConstructor(registry, valType);\n    if (!value) {\n        return [ValClass, new Set(), 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        return decodeSetFromU8a(registry, ValClass, u8aToU8a(value));\n    }\n    else if (Array.isArray(value) || value instanceof Set) {\n        return decodeSetFromSet(registry, ValClass, value);\n    }\n    throw new Error('BTreeSet: cannot decode type');\n}\nexport class BTreeSet extends Set {\n    constructor(registry, valType, rawValue) {\n        const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);\n        super(sortSet(values));\n        _BTreeSet_ValClass.set(this, void 0);\n        this.registry = registry;\n        this.initialU8aLength = decodedLength;\n        __classPrivateFieldSet(this, _BTreeSet_ValClass, ValClass, \"f\");\n    }\n    static with(valType) {\n        return class extends BTreeSet {\n            constructor(registry, value) {\n                super(registry, valType, value);\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let len = compactToU8a(this.size).length;\n        for (const v of this.values()) {\n            len += v.encodedLength;\n        }\n        return len;\n    }\n    /**\n     * @description Returns a hash of the value\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * @description The actual set values as a string[]\n     */\n    get strings() {\n        return [...super.values()].map((v) => v.toString());\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareSet(this, other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const inner = new Array();\n        for (const v of this.values()) {\n            inner.push(v.inspect());\n        }\n        return {\n            inner,\n            outer: [compactToU8a(this.size)]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended) {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toHuman(isExtended));\n        }\n        return json;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toJSON());\n        }\n        return json;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `BTreeSet<${this.registry.getClassName(__classPrivateFieldGet(this, _BTreeSet_ValClass, \"f\")) || new (__classPrivateFieldGet(this, _BTreeSet_ValClass, \"f\"))(this.registry).toRawType()}>`;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toPrimitive());\n        }\n        return json;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = new Array();\n        if (!isBare) {\n            encoded.push(compactToU8a(this.size));\n        }\n        for (const v of this.values()) {\n            encoded.push(v.toU8a(isBare));\n        }\n        return u8aConcatStrict(encoded);\n    }\n}\n_BTreeSet_ValClass = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}