{"ast":null,"code":"import { isUndefined } from '@polkadot/util';\nfunction sig(_ref, _ref2, args) {\n  let {\n    lookup\n  } = _ref;\n  let {\n    method,\n    section\n  } = _ref2;\n  return `${section}.${method}(${args.map(a => lookup.getTypeDef(a).type).join(', ')})`;\n}\nexport function extractStorageArgs(registry, creator, _args) {\n  const args = _args.filter(a => !isUndefined(a));\n  if (creator.meta.type.isPlain) {\n    if (args.length !== 0) {\n      throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);\n    }\n  } else {\n    const {\n      hashers,\n      key\n    } = creator.meta.type.asMap;\n    const keys = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple.map(t => t);\n    if (args.length !== keys.length) {\n      throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);\n    }\n  }\n  // pass as tuple\n  return [creator, args];\n}","map":{"version":3,"names":["isUndefined","sig","_ref","_ref2","args","lookup","method","section","map","a","getTypeDef","type","join","extractStorageArgs","registry","creator","_args","filter","meta","isPlain","length","Error","hashers","key","asMap","keys","getSiType","def","asTuple","t"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api/util/validate.js"],"sourcesContent":["import { isUndefined } from '@polkadot/util';\nfunction sig({ lookup }, { method, section }, args) {\n    return `${section}.${method}(${args.map((a) => lookup.getTypeDef(a).type).join(', ')})`;\n}\nexport function extractStorageArgs(registry, creator, _args) {\n    const args = _args.filter((a) => !isUndefined(a));\n    if (creator.meta.type.isPlain) {\n        if (args.length !== 0) {\n            throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);\n        }\n    }\n    else {\n        const { hashers, key } = creator.meta.type.asMap;\n        const keys = hashers.length === 1\n            ? [key]\n            : registry.lookup.getSiType(key).def.asTuple.map((t) => t);\n        if (args.length !== keys.length) {\n            throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);\n        }\n    }\n    // pass as tuple\n    return [creator, args];\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,GAAGA,CAAAC,IAAA,EAAAC,KAAA,EAAkCC,IAAI,EAAE;EAAA,IAAvC;IAAEC;EAAO,CAAC,GAAAH,IAAA;EAAA,IAAE;IAAEI,MAAM;IAAEC;EAAQ,CAAC,GAAAJ,KAAA;EACxC,OAAQ,GAAEI,OAAQ,IAAGD,MAAO,IAAGF,IAAI,CAACI,GAAG,CAAEC,CAAC,IAAKJ,MAAM,CAACK,UAAU,CAACD,CAAC,CAAC,CAACE,IAAI,CAAC,CAACC,IAAI,CAAC,IAAI,CAAE,GAAE;AAC3F;AACA,OAAO,SAASC,kBAAkBA,CAACC,QAAQ,EAAEC,OAAO,EAAEC,KAAK,EAAE;EACzD,MAAMZ,IAAI,GAAGY,KAAK,CAACC,MAAM,CAAER,CAAC,IAAK,CAACT,WAAW,CAACS,CAAC,CAAC,CAAC;EACjD,IAAIM,OAAO,CAACG,IAAI,CAACP,IAAI,CAACQ,OAAO,EAAE;IAC3B,IAAIf,IAAI,CAACgB,MAAM,KAAK,CAAC,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAE,GAAEpB,GAAG,CAACa,QAAQ,EAAEC,OAAO,EAAE,EAAE,CAAE,iCAAgCX,IAAI,CAACgB,MAAO,QAAO,CAAC;IACtG;EACJ,CAAC,MACI;IACD,MAAM;MAAEE,OAAO;MAAEC;IAAI,CAAC,GAAGR,OAAO,CAACG,IAAI,CAACP,IAAI,CAACa,KAAK;IAChD,MAAMC,IAAI,GAAGH,OAAO,CAACF,MAAM,KAAK,CAAC,GAC3B,CAACG,GAAG,CAAC,GACLT,QAAQ,CAACT,MAAM,CAACqB,SAAS,CAACH,GAAG,CAAC,CAACI,GAAG,CAACC,OAAO,CAACpB,GAAG,CAAEqB,CAAC,IAAKA,CAAC,CAAC;IAC9D,IAAIzB,IAAI,CAACgB,MAAM,KAAKK,IAAI,CAACL,MAAM,EAAE;MAC7B,MAAM,IAAIC,KAAK,CAAE,GAAEpB,GAAG,CAACa,QAAQ,EAAEC,OAAO,EAAEU,IAAI,CAAE,wBAAuBA,IAAI,CAACL,MAAO,eAAchB,IAAI,CAACgB,MAAO,QAAO,CAAC;IACzH;EACJ;EACA;EACA,OAAO,CAACL,OAAO,EAAEX,IAAI,CAAC;AAC1B"},"metadata":{},"sourceType":"module","externalDependencies":[]}