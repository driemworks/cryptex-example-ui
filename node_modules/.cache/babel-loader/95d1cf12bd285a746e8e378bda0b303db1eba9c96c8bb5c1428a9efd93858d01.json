{"ast":null,"code":"import { U8aFixed } from '@polkadot/types-codec';\nimport { hexToU8a, isHex, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\n/** @internal */\nfunction decodeAccountId(value) {\n  if (isU8a(value) || Array.isArray(value)) {\n    return u8aToU8a(value);\n  } else if (!value) {\n    return new Uint8Array();\n  } else if (isHex(value)) {\n    return hexToU8a(value);\n  } else if (isString(value)) {\n    return decodeAddress(value.toString());\n  }\n  throw new Error(`Unknown type passed to AccountId constructor, found typeof ${typeof value}`);\n}\nclass BaseAccountId extends U8aFixed {\n  constructor(registry) {\n    let allowedBits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256 | 264;\n    let value = arguments.length > 2 ? arguments[2] : undefined;\n    const decoded = decodeAccountId(value);\n    const decodedBits = decoded.length * 8;\n    // Part of stream containing >= 32 bytes or a all empty (defaults)\n    if (decodedBits < allowedBits && decoded.some(b => b)) {\n      throw new Error(`Invalid AccountId provided, expected ${allowedBits >> 3} bytes, found ${decoded.length}`);\n    }\n    super(registry, decoded, allowedBits);\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return super.eq(decodeAccountId(other));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toJSON();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toJSON();\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return encodeAddress(this, this.registry.chainSS58);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'AccountId';\n  }\n}\n/**\n * @name GenericAccountId\n * @description\n * A wrapper around an AccountId/PublicKey representation. Since we are dealing with\n * underlying PublicKeys (32 bytes in length), we extend from U8aFixed which is\n * just a Uint8Array wrapper with a fixed length.\n */\nexport class GenericAccountId extends BaseAccountId {\n  constructor(registry, value) {\n    super(registry, 256, value);\n  }\n}\nexport class GenericAccountId33 extends BaseAccountId {\n  constructor(registry, value) {\n    super(registry, 264, value);\n  }\n}","map":{"version":3,"names":["U8aFixed","hexToU8a","isHex","isString","isU8a","u8aToU8a","decodeAddress","encodeAddress","decodeAccountId","value","Array","isArray","Uint8Array","toString","Error","BaseAccountId","constructor","registry","allowedBits","arguments","length","undefined","decoded","decodedBits","some","b","eq","other","toHuman","toJSON","toPrimitive","chainSS58","toRawType","GenericAccountId","GenericAccountId33"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/generic/AccountId.js"],"sourcesContent":["import { U8aFixed } from '@polkadot/types-codec';\nimport { hexToU8a, isHex, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\n/** @internal */\nfunction decodeAccountId(value) {\n    if (isU8a(value) || Array.isArray(value)) {\n        return u8aToU8a(value);\n    }\n    else if (!value) {\n        return new Uint8Array();\n    }\n    else if (isHex(value)) {\n        return hexToU8a(value);\n    }\n    else if (isString(value)) {\n        return decodeAddress(value.toString());\n    }\n    throw new Error(`Unknown type passed to AccountId constructor, found typeof ${typeof value}`);\n}\nclass BaseAccountId extends U8aFixed {\n    constructor(registry, allowedBits = 256 | 264, value) {\n        const decoded = decodeAccountId(value);\n        const decodedBits = decoded.length * 8;\n        // Part of stream containing >= 32 bytes or a all empty (defaults)\n        if (decodedBits < allowedBits && decoded.some((b) => b)) {\n            throw new Error(`Invalid AccountId provided, expected ${allowedBits >> 3} bytes, found ${decoded.length}`);\n        }\n        super(registry, decoded, allowedBits);\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return super.eq(decodeAccountId(other));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return encodeAddress(this, this.registry.chainSS58);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'AccountId';\n    }\n}\n/**\n * @name GenericAccountId\n * @description\n * A wrapper around an AccountId/PublicKey representation. Since we are dealing with\n * underlying PublicKeys (32 bytes in length), we extend from U8aFixed which is\n * just a Uint8Array wrapper with a fixed length.\n */\nexport class GenericAccountId extends BaseAccountId {\n    constructor(registry, value) {\n        super(registry, 256, value);\n    }\n}\nexport class GenericAccountId33 extends BaseAccountId {\n    constructor(registry, value) {\n        super(registry, 264, value);\n    }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,QAAQ,gBAAgB;AAC3E,SAASC,aAAa,EAAEC,aAAa,QAAQ,uBAAuB;AACpE;AACA,SAASC,eAAeA,CAACC,KAAK,EAAE;EAC5B,IAAIL,KAAK,CAACK,KAAK,CAAC,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACtC,OAAOJ,QAAQ,CAACI,KAAK,CAAC;EAC1B,CAAC,MACI,IAAI,CAACA,KAAK,EAAE;IACb,OAAO,IAAIG,UAAU,EAAE;EAC3B,CAAC,MACI,IAAIV,KAAK,CAACO,KAAK,CAAC,EAAE;IACnB,OAAOR,QAAQ,CAACQ,KAAK,CAAC;EAC1B,CAAC,MACI,IAAIN,QAAQ,CAACM,KAAK,CAAC,EAAE;IACtB,OAAOH,aAAa,CAACG,KAAK,CAACI,QAAQ,EAAE,CAAC;EAC1C;EACA,MAAM,IAAIC,KAAK,CAAE,8DAA6D,OAAOL,KAAM,EAAC,CAAC;AACjG;AACA,MAAMM,aAAa,SAASf,QAAQ,CAAC;EACjCgB,WAAWA,CAACC,QAAQ,EAAkC;IAAA,IAAhCC,WAAW,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,GAAG,GAAG,GAAG;IAAA,IAAEV,KAAK,GAAAU,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAChD,MAAMC,OAAO,GAAGd,eAAe,CAACC,KAAK,CAAC;IACtC,MAAMc,WAAW,GAAGD,OAAO,CAACF,MAAM,GAAG,CAAC;IACtC;IACA,IAAIG,WAAW,GAAGL,WAAW,IAAII,OAAO,CAACE,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAAC,EAAE;MACrD,MAAM,IAAIX,KAAK,CAAE,wCAAuCI,WAAW,IAAI,CAAE,iBAAgBI,OAAO,CAACF,MAAO,EAAC,CAAC;IAC9G;IACA,KAAK,CAACH,QAAQ,EAAEK,OAAO,EAAEJ,WAAW,CAAC;EACzC;EACA;AACJ;AACA;EACIQ,EAAEA,CAACC,KAAK,EAAE;IACN,OAAO,KAAK,CAACD,EAAE,CAAClB,eAAe,CAACmB,KAAK,CAAC,CAAC;EAC3C;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACC,MAAM,EAAE;EACxB;EACA;AACJ;AACA;EACIA,MAAMA,CAAA,EAAG;IACL,OAAO,IAAI,CAAChB,QAAQ,EAAE;EAC1B;EACA;AACJ;AACA;EACIiB,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACD,MAAM,EAAE;EACxB;EACA;AACJ;AACA;EACIhB,QAAQA,CAAA,EAAG;IACP,OAAON,aAAa,CAAC,IAAI,EAAE,IAAI,CAACU,QAAQ,CAACc,SAAS,CAAC;EACvD;EACA;AACJ;AACA;EACIC,SAASA,CAAA,EAAG;IACR,OAAO,WAAW;EACtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,SAASlB,aAAa,CAAC;EAChDC,WAAWA,CAACC,QAAQ,EAAER,KAAK,EAAE;IACzB,KAAK,CAACQ,QAAQ,EAAE,GAAG,EAAER,KAAK,CAAC;EAC/B;AACJ;AACA,OAAO,MAAMyB,kBAAkB,SAASnB,aAAa,CAAC;EAClDC,WAAWA,CAACC,QAAQ,EAAER,KAAK,EAAE;IACzB,KAAK,CAACQ,QAAQ,EAAE,GAAG,EAAER,KAAK,CAAC;EAC/B;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}