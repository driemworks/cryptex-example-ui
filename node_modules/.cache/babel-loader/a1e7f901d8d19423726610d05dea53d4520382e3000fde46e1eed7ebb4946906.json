{"ast":null,"code":"var _PortableRegistry_instances, _PortableRegistry_alias, _PortableRegistry_lookups, _PortableRegistry_names, _PortableRegistry_params, _PortableRegistry_typeDefs, _PortableRegistry_types, _PortableRegistry_createSiDef, _PortableRegistry_getLookupId, _PortableRegistry_extract, _PortableRegistry_extractArray, _PortableRegistry_extractBitSequence, _PortableRegistry_extractCompact, _PortableRegistry_extractComposite, _PortableRegistry_extractCompositeSet, _PortableRegistry_extractFields, _PortableRegistry_extractFieldsAlias, _PortableRegistry_extractHistoric, _PortableRegistry_extractPrimitive, _PortableRegistry_extractAliasPath, _PortableRegistry_extractSequence, _PortableRegistry_extractTuple, _PortableRegistry_extractVariant, _PortableRegistry_extractVariantEnum;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { sanitize, Struct } from '@polkadot/types-codec';\nimport { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';\nimport { assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';\nconst l = logger('PortableRegistry');\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n};\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  Str: 'Text'\n};\nconst PATHS_ALIAS = splitNamespace([\n// full matching on exact names...\n// these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress',\n// ethereum overrides (Frontier, Moonbeam, Polkadot claims)\n'fp_account::AccountId20', 'account::AccountId20', 'polkadot_runtime_common::claims::EthereumAddress',\n// weights 2 is a structure, however for 1.5. with a single field it\n// should be flatenned (can appear in Compact<Weight> extrinsics)\n'frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight',\n// wildcard matching in place...\n// these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy\n'*_democracy::vote::Vote', '*_conviction_voting::vote::Vote', '*_identity::types::Data',\n// these are opaque Vec<u8> wrappers\n'sp_core::OpaqueMetadata', 'sp_core::OpaquePeerId', 'sp_core::offchain::OpaqueMultiaddr',\n// shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*',\n// runtime\n'*_runtime::RuntimeCall', '*_runtime::RuntimeEvent',\n// ink!\n'ink::env::types::*', 'ink::primitives::types::*', 'ink_env::types::*', 'ink_primitives::types::*']);\nconst PATHS_SET = splitNamespace(['pallet_identity::types::BitFlags']);\nconst BITVEC_NS_LSB = ['bitvec::order::Lsb0', 'BitOrderLsb0'];\nconst BITVEC_NS_MSB = ['bitvec::order::Msb0', 'BitOrderMsb0'];\nconst BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedBTreeSet', 'BoundedVec', 'Box', 'BTreeMap', 'BTreeSet', 'Cow', 'Option', 'Range', 'RangeInclusive', 'Result', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque'];\nconst RESERVED = [\n// JS reserved words\n'entries', 'keys', 'new', 'size',\n// exposed by all Codec objects\n'hash', 'registry'];\nconst PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];\n/** @internal Converts a Text[] into string[] (used as part of definitions) */\nfunction sanitizeDocs(docs) {\n  const result = new Array(docs.length);\n  for (let i = 0; i < docs.length; i++) {\n    result[i] = docs[i].toString();\n  }\n  return result;\n}\n/** @internal Split a namespace with :: into individual parts */\nfunction splitNamespace(values) {\n  const result = new Array(values.length);\n  for (let i = 0; i < values.length; i++) {\n    result[i] = values[i].split('::');\n  }\n  return result;\n}\n/** @internal Match a namespace based on parts (alongside wildcards) */\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    if (a === '*' || a === b) {\n      return true;\n    }\n    if (a.includes('*') && a.includes('_') && b.includes('_')) {\n      let suba = a.split('_');\n      let subb = b.split('_');\n      // match initial *'s to multiples if we have a match for the other\n      if (suba[0] === '*') {\n        const indexOf = subb.indexOf(suba[1]);\n        if (indexOf !== -1) {\n          suba = suba.slice(1);\n          subb = subb.slice(indexOf);\n        }\n      }\n      // check for * matches at the end, adjust accordingly\n      if (suba.length === 2 && suba[1] === '*' && suba[0] === subb[0]) {\n        return true;\n      }\n      return matchParts(suba, subb);\n    }\n    return false;\n  });\n}\n/** @internal check if the path matches the PATHS_ALIAS (with wildcards) */\nfunction getAliasPath(_ref) {\n  let {\n    def,\n    path\n  } = _ref;\n  // specific logic for weights - we override when non-complex struct\n  // (as applied in Weight 1.5 where we also have `Compact<{ refTime: u64 }>)\n  if (['frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight'].includes(path.join('::'))) {\n    return !def.isComposite || def.asComposite.fields.length === 1 ? 'WeightV1' : null;\n  }\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PATHS_ALIAS.some(a => matchParts(a, path)) ? path[path.length - 1].toString() : null;\n}\n/** @internal Converts a type name into a JS-API compatible name */\nfunction extractNameFlat(portable, lookupIndex, params, path) {\n  let isInternal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  const count = path.length;\n  // if we have no path or determined as a wrapper, we just skip it\n  if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {\n    return null;\n  }\n  const camels = new Array(count);\n  const lowers = new Array(count);\n  // initially just create arrays of the camelCase and lowercase path\n  // parts - we will check these to extract the final values. While\n  // we have 2 loops here, we also don't do the same operation twice\n  for (let i = 0; i < count; i++) {\n    const c = stringPascalCase(isInternal ? path[i].replace('pallet_', '') : path[i]);\n    const l = c.toLowerCase();\n    camels[i] = c;\n    lowers[i] = l;\n  }\n  let name = '';\n  for (let i = 0; i < count; i++) {\n    const l = lowers[i];\n    // Remove ::{generic, misc, pallet, traits, types}::\n    if (i !== 1 || !PATH_RM_INDEX_1.includes(l)) {\n      // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n      // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n      if (l !== lowers[i + 1]) {\n        name += camels[i];\n      }\n    }\n  }\n  // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin\n  if (camels[1] === 'RawOrigin' && count === 2 && params.length === 2 && params[1].type.isSome) {\n    const instanceType = portable[params[1].type.unwrap().toNumber()];\n    if (instanceType.type.path.length === 2) {\n      name = `${name}${instanceType.type.path[1].toString()}`;\n    }\n  }\n  return {\n    lookupIndex,\n    name,\n    params\n  };\n}\n/** @internal Alias for extractNameFlat with PortableType as a last parameter */\nfunction extractName(portable, lookupIndex, _ref2) {\n  let {\n    type: {\n      params,\n      path\n    }\n  } = _ref2;\n  return extractNameFlat(portable, lookupIndex, params, path);\n}\n/** @internal Check for dupes from a specific index onwards */\nfunction nextDupeMatches(name, startAt, names) {\n  const result = [names[startAt]];\n  for (let i = startAt + 1; i < names.length; i++) {\n    const v = names[i];\n    if (v.name === name) {\n      result.push(v);\n    }\n  }\n  return result;\n}\n/** @internal Checks to see if a type is a full duplicate (with all params matching) */\nfunction rewriteDupes(input, rewrite) {\n  const count = input.length;\n  for (let i = 0; i < count; i++) {\n    const a = input[i];\n    for (let j = i + 1; j < count; j++) {\n      const b = input[j];\n      // if the indexes are not the same and the names match, we have a dupe\n      if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {\n        return false;\n      }\n    }\n  }\n  // add all the adjusted values to the rewite map\n  for (let i = 0; i < count; i++) {\n    const p = input[i];\n    rewrite[p.lookupIndex] = p.name;\n  }\n  return true;\n}\n/** @internal Find duplicates and adjust the names based on parameters */\nfunction removeDupeNames(lookup, portable, names) {\n  const rewrite = {};\n  return names.map((original, startAt) => {\n    const {\n      lookupIndex,\n      name,\n      params\n    } = original;\n    if (!name) {\n      // the name is empty (this is not expected, but have a failsafe)\n      return null;\n    } else if (rewrite[lookupIndex]) {\n      // we have already rewritten this one, we can skip it\n      return original;\n    }\n    // those where the name is matching starting from this index\n    const allSame = nextDupeMatches(name, startAt, names);\n    // we only have one, so all ok\n    if (allSame.length === 1) {\n      return original;\n    }\n    // are there param differences between matching names\n    const anyDiff = allSame.some(o => params.length !== o.params.length || params.some((p, index) => !p.name.eq(o.params[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));\n    // everything matches, we can combine these\n    if (!anyDiff) {\n      return original;\n    }\n    // TODO We probably want to attach all the indexes with differences,\n    // not just the first\n    // find the first parameter that yields differences\n    const paramIdx = params.findIndex((_ref3, index) => {\n      let {\n        type\n      } = _ref3;\n      return allSame.every((_ref4, aIndex) => {\n        let {\n          params\n        } = _ref4;\n        return params[index].type.isSome && (aIndex === 0 || !params[index].type.eq(type));\n      });\n    });\n    // No param found that is different\n    if (paramIdx === -1) {\n      return original;\n    }\n    // see if using the param type helps\n    const adjusted = new Array(allSame.length);\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < allSame.length; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      // if it is not a primitive and it doesn't have a path, we really cannot\n      // do anything at this point\n      if (!def.isPrimitive && !path.length) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: def.isPrimitive ? `${name}${def.asPrimitive.toString()}` : `${name}${path[path.length - 1].toString()}`\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    // TODO This is duplicated from the section just above...\n    // ... we certainly need a better solution here\n    //\n    // Last-ditch effort to use the full type path - ugly\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < allSame.length; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      const flat = extractNameFlat(portable, lookupIndex, params, path, true);\n      if (def.isPrimitive || !flat) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: `${name}${flat.name}`\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    return null;\n  }).filter(n => !!n).map(_ref5 => {\n    let {\n      lookupIndex,\n      name,\n      params\n    } = _ref5;\n    return {\n      lookupIndex,\n      name: rewrite[lookupIndex] || name,\n      params\n    };\n  });\n}\n/** @internal Detect on-chain types (AccountId/Signature) as set as the default */\nfunction registerTypes(lookup, lookups, names, params) {\n  // Register the types we extracted\n  lookup.registry.register(lookups);\n  // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [addrParam,, sigParam] = params.SpRuntimeUncheckedExtrinsic;\n    const siAddress = lookup.getSiType(addrParam.type.unwrap());\n    const siSignature = lookup.getSiType(sigParam.type.unwrap());\n    const nsSignature = siSignature.path.join('::');\n    let nsAccountId = siAddress.path.join('::');\n    const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';\n    // With multiaddress, we check the first type param again\n    if (isMultiAddress) {\n      // AccountId, AccountIndex\n      const [idParam] = siAddress.params;\n      nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join('::');\n    }\n    lookup.registry.register({\n      AccountId: ['sp_core::crypto::AccountId32'].includes(nsAccountId) ? 'AccountId32' : ['account::AccountId20', 'primitive_types::H160'].includes(nsAccountId) ? 'AccountId20' : 'AccountId32',\n      Address: isMultiAddress ? 'MultiAddress' : 'AccountId',\n      ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature) ? 'MultiSignature' : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'\n    });\n  }\n}\n/**\n * @internal Extracts aliases based on what we know the runtime config looks like in a\n * Substrate chain. Specifically we want to have access to the Call and Event params\n **/\nfunction extractAliases(params, isContract) {\n  const hasParams = Object.keys(params).some(k => !k.startsWith('Pallet'));\n  const alias = {};\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [, {\n      type\n    }] = params.SpRuntimeUncheckedExtrinsic;\n    alias[type.unwrap().toNumber()] = 'Call';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');\n  }\n  if (params.FrameSystemEventRecord) {\n    // Event, Topic\n    const [{\n      type\n    }] = params.FrameSystemEventRecord;\n    alias[type.unwrap().toNumber()] = 'Event';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');\n  }\n  return alias;\n}\n/** @internal Extracts all the intreresting type information for this registry */\nfunction extractTypeInfo(lookup, portable) {\n  const nameInfo = [];\n  const types = {};\n  const porCount = portable.length;\n  for (let i = 0; i < porCount; i++) {\n    const type = portable[i];\n    const lookupIndex = type.id.toNumber();\n    const extracted = extractName(portable, lookupIndex, portable[i]);\n    if (extracted) {\n      nameInfo.push(extracted);\n    }\n    types[lookupIndex] = type;\n  }\n  const lookups = {};\n  const names = {};\n  const params = {};\n  const dedup = removeDupeNames(lookup, portable, nameInfo);\n  const dedupCount = dedup.length;\n  for (let i = 0; i < dedupCount; i++) {\n    const {\n      lookupIndex,\n      name,\n      params: p\n    } = dedup[i];\n    names[lookupIndex] = name;\n    lookups[name] = lookup.registry.createLookupType(lookupIndex);\n    params[name] = p;\n  }\n  return {\n    lookups,\n    names,\n    params,\n    types\n  };\n}\nexport class PortableRegistry extends Struct {\n  constructor(registry, value, isContract) {\n    // const timeStart = performance.now()\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    _PortableRegistry_instances.add(this);\n    _PortableRegistry_alias.set(this, void 0);\n    _PortableRegistry_lookups.set(this, void 0);\n    _PortableRegistry_names.set(this, void 0);\n    _PortableRegistry_params.set(this, void 0);\n    _PortableRegistry_typeDefs.set(this, {});\n    _PortableRegistry_types.set(this, void 0);\n    const {\n      lookups,\n      names,\n      params,\n      types\n    } = extractTypeInfo(this, this.types);\n    __classPrivateFieldSet(this, _PortableRegistry_alias, extractAliases(params, isContract), \"f\");\n    __classPrivateFieldSet(this, _PortableRegistry_lookups, lookups, \"f\");\n    __classPrivateFieldSet(this, _PortableRegistry_names, names, \"f\");\n    __classPrivateFieldSet(this, _PortableRegistry_params, params, \"f\");\n    __classPrivateFieldSet(this, _PortableRegistry_types, types, \"f\");\n    // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)\n  }\n  /**\n   * @description Returns all the available type names for this chain\n   **/\n  get names() {\n    return Object.values(__classPrivateFieldGet(this, _PortableRegistry_names, \"f\")).sort();\n  }\n  /**\n   * @description The types of the registry\n   */\n  get types() {\n    return this.getT('types');\n  }\n  /**\n   * @description Register all available types into the registry (generally for internal usage)\n   */\n  register() {\n    registerTypes(this, __classPrivateFieldGet(this, _PortableRegistry_lookups, \"f\"), __classPrivateFieldGet(this, _PortableRegistry_names, \"f\"), __classPrivateFieldGet(this, _PortableRegistry_params, \"f\"));\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n  getName(lookupId) {\n    return __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[__classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_getLookupId).call(this, lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n  getSiType(lookupId) {\n    // NOTE catch-22 - this may already be used as part of the constructor, so\n    // ensure that we have actually initialized it correctly\n    const found = (__classPrivateFieldGet(this, _PortableRegistry_types, \"f\") || this.types)[__classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_getLookupId).call(this, lookupId)];\n    if (!found) {\n      throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    }\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n  getTypeDef(lookupId) {\n    const lookupIndex = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_getLookupId).call(this, lookupId);\n    if (!__classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex]) {\n      const lookupName = __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex];\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      };\n      // Set named items since we will get into circular lookups along the way\n      if (lookupName) {\n        __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex] = empty;\n      }\n      const extracted = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extract).call(this, this.getSiType(lookupId), lookupIndex);\n      // For non-named items, we only set this right at the end\n      if (!lookupName) {\n        __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex] = empty;\n      }\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex][k] = extracted[k];\n        }\n      });\n      // don't set lookupName on lower-level, we want to always direct to the type\n      if (extracted.info === TypeDefInfo.Plain) {\n        __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex].lookupNameRoot = __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex].lookupName;\n        delete __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex].lookupName;\n      }\n    }\n    return __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex];\n  }\n  /**\n   * @description For a specific field, perform adjustments to not have built-in conflicts\n   */\n  sanitizeField(name) {\n    let nameField = null;\n    let nameOrig = null;\n    if (name.isSome) {\n      nameField = stringCamelCase(name.unwrap());\n      if (nameField.includes('#')) {\n        nameOrig = nameField;\n        nameField = nameOrig.replace(/#/g, '_');\n      } else if (RESERVED.includes(nameField)) {\n        nameOrig = nameField;\n        nameField = `${nameField}_`;\n      }\n    }\n    return [nameField, nameOrig];\n  }\n}\n_PortableRegistry_alias = new WeakMap(), _PortableRegistry_lookups = new WeakMap(), _PortableRegistry_names = new WeakMap(), _PortableRegistry_params = new WeakMap(), _PortableRegistry_typeDefs = new WeakMap(), _PortableRegistry_types = new WeakMap(), _PortableRegistry_instances = new WeakSet(), _PortableRegistry_createSiDef = function _PortableRegistry_createSiDef(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber();\n  // Setup for a lookup on complex types\n  return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}, _PortableRegistry_getLookupId = function _PortableRegistry_getLookupId(lookupId) {\n  if (isString(lookupId)) {\n    if (!this.registry.isLookupType(lookupId)) {\n      throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    }\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n  return lookupId.toNumber();\n}, _PortableRegistry_extract = function _PortableRegistry_extract(type, lookupIndex) {\n  const namespace = type.path.join('::');\n  let typeDef;\n  const aliasType = __classPrivateFieldGet(this, _PortableRegistry_alias, \"f\")[lookupIndex] || getAliasPath(type);\n  try {\n    if (aliasType) {\n      typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractAliasPath).call(this, lookupIndex, aliasType);\n    } else {\n      switch (type.def.type) {\n        case 'Array':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractArray).call(this, lookupIndex, type.def.asArray);\n          break;\n        case 'BitSequence':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractBitSequence).call(this, lookupIndex, type.def.asBitSequence);\n          break;\n        case 'Compact':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractCompact).call(this, lookupIndex, type.def.asCompact);\n          break;\n        case 'Composite':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractComposite).call(this, lookupIndex, type, type.def.asComposite);\n          break;\n        case 'HistoricMetaCompat':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractHistoric).call(this, lookupIndex, type.def.asHistoricMetaCompat);\n          break;\n        case 'Primitive':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractPrimitive).call(this, lookupIndex, type);\n          break;\n        case 'Sequence':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractSequence).call(this, lookupIndex, type.def.asSequence);\n          break;\n        case 'Tuple':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractTuple).call(this, lookupIndex, type.def.asTuple);\n          break;\n        case 'Variant':\n          typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractVariant).call(this, lookupIndex, type, type.def.asVariant);\n          break;\n        default:\n          assertUnreachable(type.def.type);\n      }\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n  return objectSpread({\n    docs: sanitizeDocs(type.docs),\n    namespace\n  }, typeDef);\n}, _PortableRegistry_extractArray = function _PortableRegistry_extractArray(_, _ref6) {\n  let {\n    len,\n    type\n  } = _ref6;\n  const length = len.toNumber();\n  if (length > 2048) {\n    throw new Error('Only support for [Type; <length>], where length <= 2048');\n  }\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length,\n    sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type)\n  });\n}, _PortableRegistry_extractBitSequence = function _PortableRegistry_extractBitSequence(_, _ref7) {\n  let {\n    bitOrderType,\n    bitStoreType\n  } = _ref7;\n  // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine\n  // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly\n  const a = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, bitOrderType);\n  const b = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, bitStoreType);\n  const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || '') ? [a, b] : [b, a];\n  if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {\n    throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  } else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== 'u8') {\n    throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  }\n  const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);\n  if (!isLsb) {\n    // TODO To remove this limitation, we need to pass an extra info flag\n    // through to the TypeDef (Here we could potentially re-use something\n    // like index (???) to indicate and ensure we use it to pass to the\n    // BitVec constructor - which does handle this type)\n    //\n    // See https://github.com/polkadot-js/api/issues/5588\n    // throw new Error(`Only LSB BitVec is currently supported, found ${bitOrder.namespace}`);\n  }\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}, _PortableRegistry_extractCompact = function _PortableRegistry_extractCompact(_, _ref8) {\n  let {\n    type\n  } = _ref8;\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type)\n  });\n}, _PortableRegistry_extractComposite = function _PortableRegistry_extractComposite(lookupIndex, _ref9, _ref10) {\n  let {\n    params,\n    path\n  } = _ref9;\n  let {\n    fields\n  } = _ref10;\n  if (path.length) {\n    const pathFirst = path[0].toString();\n    const pathLast = path[path.length - 1].toString();\n    if (path.length === 1 && pathFirst === 'BTreeMap') {\n      if (params.length !== 2) {\n        throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);\n      }\n      return withTypeString(this.registry, {\n        info: TypeDefInfo.BTreeMap,\n        sub: params.map(_ref11 => {\n          let {\n            type\n          } = _ref11;\n          return __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type.unwrap());\n        })\n      });\n    } else if (path.length === 1 && pathFirst === 'BTreeSet') {\n      if (params.length !== 1) {\n        throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);\n      }\n      return withTypeString(this.registry, {\n        info: TypeDefInfo.BTreeSet,\n        sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap())\n      });\n    } else if (['Range', 'RangeInclusive'].includes(pathFirst)) {\n      if (params.length !== 1) {\n        throw new Error(`Range requires 1 parameter, found ${params.length}`);\n      }\n      return withTypeString(this.registry, {\n        info: pathFirst === 'Range' ? TypeDefInfo.Range : TypeDefInfo.RangeInclusive,\n        sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap()),\n        type: pathFirst\n      });\n    } else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {\n      if (params.length !== 1) {\n        throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);\n      }\n      return withTypeString(this.registry, {\n        info: pathLast === 'WrapperKeepOpaque' ? TypeDefInfo.WrapperKeepOpaque : TypeDefInfo.WrapperOpaque,\n        sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap()),\n        type: pathLast\n      });\n    }\n  }\n  return PATHS_SET.some(p => matchParts(p, path)) ? __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractCompositeSet).call(this, lookupIndex, params, fields) : __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractFields).call(this, lookupIndex, fields);\n}, _PortableRegistry_extractCompositeSet = function _PortableRegistry_extractCompositeSet(_, params, fields) {\n  if (params.length !== 1 || fields.length !== 1) {\n    throw new Error('Set handling expects param/field as single entries');\n  }\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(_ref12 => {\n      let {\n        index,\n        name\n      } = _ref12;\n      return {\n        // This will be an issue > 2^53 - 1 ... don't have those (yet)\n        index: index.toNumber(),\n        info: TypeDefInfo.Plain,\n        name: name.toString(),\n        type: 'Null'\n      };\n    })\n  });\n}, _PortableRegistry_extractFields = function _PortableRegistry_extractFields(lookupIndex, fields) {\n  let isStruct = true;\n  let isTuple = true;\n  for (let f = 0; f < fields.length; f++) {\n    const {\n      name\n    } = fields[f];\n    isStruct = isStruct && name.isSome;\n    isTuple = isTuple && name.isNone;\n  }\n  if (!isTuple && !isStruct) {\n    throw new Error('Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n  }\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, fields[0].type);\n    return objectSpread({}, typeDef, lookupIndex === -1 ? null : {\n      lookupIndex,\n      lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    }, fields[0].typeName.isSome ? {\n      typeName: sanitize(fields[0].typeName.unwrap())\n    } : null);\n  }\n  const [sub, alias] = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractFieldsAlias).call(this, fields);\n  return withTypeString(this.registry, objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct,\n    sub\n  }, alias.size ? {\n    alias\n  } : null, lookupIndex === -1 ? null : {\n    lookupIndex,\n    lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex]\n  }));\n}, _PortableRegistry_extractFieldsAlias = function _PortableRegistry_extractFieldsAlias(fields) {\n  const alias = new Map();\n  const sub = new Array(fields.length);\n  for (let i = 0; i < fields.length; i++) {\n    const {\n      docs,\n      name,\n      type,\n      typeName\n    } = fields[i];\n    const typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type);\n    if (name.isNone) {\n      sub[i] = typeDef;\n    } else {\n      const [nameField, nameOrig] = this.sanitizeField(name);\n      if (nameField && nameOrig) {\n        alias.set(nameField, nameOrig);\n      }\n      sub[i] = objectSpread({\n        docs: sanitizeDocs(docs),\n        name: nameField\n      }, typeDef, typeName.isSome ? {\n        typeName: sanitize(typeName.unwrap())\n      } : null);\n    }\n  }\n  return [sub, alias];\n}, _PortableRegistry_extractHistoric = function _PortableRegistry_extractHistoric(_, type) {\n  return objectSpread({\n    displayName: type.toString(),\n    isFromSi: true\n  }, getTypeDef(type));\n}, _PortableRegistry_extractPrimitive = function _PortableRegistry_extractPrimitive(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}, _PortableRegistry_extractAliasPath = function _PortableRegistry_extractAliasPath(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}, _PortableRegistry_extractSequence = function _PortableRegistry_extractSequence(lookupIndex, _ref13) {\n  let {\n    type\n  } = _ref13;\n  const sub = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type);\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n    sub\n  });\n}, _PortableRegistry_extractTuple = function _PortableRegistry_extractTuple(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n  const sub = ids.map(t => __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, t));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n    sub\n  });\n}, _PortableRegistry_extractVariant = function _PortableRegistry_extractVariant(lookupIndex, _ref14, _ref15) {\n  let {\n    params,\n    path\n  } = _ref14;\n  let {\n    variants\n  } = _ref15;\n  if (path.length) {\n    const specialVariant = path[0].toString();\n    if (specialVariant === 'Option') {\n      if (params.length !== 1) {\n        throw new Error(`Option requires 1 parameter, found ${params.length}`);\n      }\n      // NOTE This is opt-in (unhandled), not by default\n      // if (sub.type === 'bool') {\n      //   return withTypeString(this.registry, {\n      //     info: TypeDefInfo.Plain,\n      //     type: 'OptionBool'\n      //   });\n      // }\n      return withTypeString(this.registry, {\n        info: TypeDefInfo.Option,\n        sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap())\n      });\n    } else if (specialVariant === 'Result') {\n      if (params.length !== 2) {\n        throw new Error(`Result requires 2 parameters, found ${params.length}`);\n      }\n      return withTypeString(this.registry, {\n        info: TypeDefInfo.Result,\n        sub: params.map((_ref16, index) => {\n          let {\n            type\n          } = _ref16;\n          return objectSpread({\n            name: ['Ok', 'Error'][index]\n          }, __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type.unwrap()));\n        })\n      });\n    }\n  }\n  if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n  return __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractVariantEnum).call(this, lookupIndex, variants);\n}, _PortableRegistry_extractVariantEnum = function _PortableRegistry_extractVariantEnum(lookupIndex, variants) {\n  const sub = [];\n  // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n  variants.slice().sort((a, b) => a.index.cmp(b.index)).forEach(_ref17 => {\n    let {\n      fields,\n      index: bnIndex,\n      name\n    } = _ref17;\n    const index = bnIndex.toNumber();\n    while (sub.length !== index) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `__Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n    sub.push(objectSpread(__classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractFields).call(this, -1, fields), {\n      index,\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n    sub\n  });\n};","map":{"version":3,"names":["_PortableRegistry_instances","_PortableRegistry_alias","_PortableRegistry_lookups","_PortableRegistry_names","_PortableRegistry_params","_PortableRegistry_typeDefs","_PortableRegistry_types","_PortableRegistry_createSiDef","_PortableRegistry_getLookupId","_PortableRegistry_extract","_PortableRegistry_extractArray","_PortableRegistry_extractBitSequence","_PortableRegistry_extractCompact","_PortableRegistry_extractComposite","_PortableRegistry_extractCompositeSet","_PortableRegistry_extractFields","_PortableRegistry_extractFieldsAlias","_PortableRegistry_extractHistoric","_PortableRegistry_extractPrimitive","_PortableRegistry_extractAliasPath","_PortableRegistry_extractSequence","_PortableRegistry_extractTuple","_PortableRegistry_extractVariant","_PortableRegistry_extractVariantEnum","__classPrivateFieldGet","__classPrivateFieldSet","sanitize","Struct","getTypeDef","TypeDefInfo","withTypeString","assertUnreachable","isNumber","isString","logger","objectSpread","stringCamelCase","stringify","stringPascalCase","l","TYPE_UNWRAP","toNumber","PRIMITIVE_ALIAS","Char","Str","PATHS_ALIAS","splitNamespace","PATHS_SET","BITVEC_NS_LSB","BITVEC_NS_MSB","BITVEC_NS","WRAPPERS","RESERVED","PATH_RM_INDEX_1","sanitizeDocs","docs","result","Array","length","i","toString","values","split","matchParts","first","second","every","a","index","b","includes","suba","subb","indexOf","slice","getAliasPath","_ref","def","path","join","isComposite","asComposite","fields","some","extractNameFlat","portable","lookupIndex","params","isInternal","arguments","undefined","count","camels","lowers","c","replace","toLowerCase","name","type","isSome","instanceType","unwrap","extractName","_ref2","nextDupeMatches","startAt","names","v","push","rewriteDupes","input","rewrite","j","p","removeDupeNames","lookup","map","original","allSame","anyDiff","o","eq","unwrapOr","paramIdx","findIndex","_ref3","_ref4","aIndex","adjusted","getSiType","isPrimitive","asPrimitive","flat","filter","n","_ref5","registerTypes","lookups","registry","register","SpRuntimeUncheckedExtrinsic","addrParam","sigParam","siAddress","siSignature","nsSignature","nsAccountId","isMultiAddress","idParam","AccountId","Address","ExtrinsicSignature","extractAliases","isContract","hasParams","Object","keys","k","startsWith","alias","warn","FrameSystemEventRecord","extractTypeInfo","nameInfo","types","porCount","id","extracted","dedup","dedupCount","createLookupType","PortableRegistry","constructor","value","add","set","sort","getT","getName","lookupId","call","found","Error","lookupName","empty","info","DoNotConstruct","forEach","Plain","lookupNameRoot","sanitizeField","nameField","nameOrig","WeakMap","WeakSet","typeDef","Enum","Si","isLookupType","parseInt","namespace","aliasType","asArray","asBitSequence","asCompact","asHistoricMetaCompat","asSequence","asTuple","asVariant","error","message","_","_ref6","len","VecFixed","sub","_ref7","bitOrderType","bitStoreType","bitOrder","bitStore","isLsb","_ref8","Compact","_ref9","_ref10","pathFirst","pathLast","BTreeMap","_ref11","BTreeSet","Range","RangeInclusive","WrapperKeepOpaque","WrapperOpaque","Set","createTypeUnsafe","bitLength","variants","_ref12","isStruct","isTuple","f","isNone","Null","typeName","Tuple","size","Map","displayName","isFromSi","typeStr","_ref13","Vec","ids","t","_ref14","_ref15","specialVariant","Option","Result","_ref16","cmp","_ref17","bnIndex"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/metadata/PortableRegistry/PortableRegistry.js"],"sourcesContent":["var _PortableRegistry_instances, _PortableRegistry_alias, _PortableRegistry_lookups, _PortableRegistry_names, _PortableRegistry_params, _PortableRegistry_typeDefs, _PortableRegistry_types, _PortableRegistry_createSiDef, _PortableRegistry_getLookupId, _PortableRegistry_extract, _PortableRegistry_extractArray, _PortableRegistry_extractBitSequence, _PortableRegistry_extractCompact, _PortableRegistry_extractComposite, _PortableRegistry_extractCompositeSet, _PortableRegistry_extractFields, _PortableRegistry_extractFieldsAlias, _PortableRegistry_extractHistoric, _PortableRegistry_extractPrimitive, _PortableRegistry_extractAliasPath, _PortableRegistry_extractSequence, _PortableRegistry_extractTuple, _PortableRegistry_extractVariant, _PortableRegistry_extractVariantEnum;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { sanitize, Struct } from '@polkadot/types-codec';\nimport { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';\nimport { assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';\nconst l = logger('PortableRegistry');\nconst TYPE_UNWRAP = { toNumber: () => -1 };\nconst PRIMITIVE_ALIAS = {\n    Char: 'u32',\n    Str: 'Text'\n};\nconst PATHS_ALIAS = splitNamespace([\n    // full matching on exact names...\n    // these are well-known types with additional encoding\n    'sp_core::crypto::AccountId32',\n    'sp_runtime::generic::era::Era',\n    'sp_runtime::multiaddress::MultiAddress',\n    // ethereum overrides (Frontier, Moonbeam, Polkadot claims)\n    'fp_account::AccountId20',\n    'account::AccountId20',\n    'polkadot_runtime_common::claims::EthereumAddress',\n    // weights 2 is a structure, however for 1.5. with a single field it\n    // should be flatenned (can appear in Compact<Weight> extrinsics)\n    'frame_support::weights::weight_v2::Weight',\n    'sp_weights::weight_v2::Weight',\n    // wildcard matching in place...\n    // these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy\n    '*_democracy::vote::Vote',\n    '*_conviction_voting::vote::Vote',\n    '*_identity::types::Data',\n    // these are opaque Vec<u8> wrappers\n    'sp_core::OpaqueMetadata',\n    'sp_core::OpaquePeerId',\n    'sp_core::offchain::OpaqueMultiaddr',\n    // shorten some well-known types\n    'primitive_types::*',\n    'sp_arithmetic::per_things::*',\n    // runtime\n    '*_runtime::RuntimeCall',\n    '*_runtime::RuntimeEvent',\n    // ink!\n    'ink::env::types::*',\n    'ink::primitives::types::*',\n    'ink_env::types::*',\n    'ink_primitives::types::*'\n]);\nconst PATHS_SET = splitNamespace([\n    'pallet_identity::types::BitFlags'\n]);\nconst BITVEC_NS_LSB = ['bitvec::order::Lsb0', 'BitOrderLsb0'];\nconst BITVEC_NS_MSB = ['bitvec::order::Msb0', 'BitOrderMsb0'];\nconst BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedBTreeSet', 'BoundedVec', 'Box', 'BTreeMap', 'BTreeSet', 'Cow', 'Option', 'Range', 'RangeInclusive', 'Result', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque'];\nconst RESERVED = [\n    // JS reserved words\n    'entries', 'keys', 'new', 'size',\n    // exposed by all Codec objects\n    'hash', 'registry'\n];\nconst PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];\n/** @internal Converts a Text[] into string[] (used as part of definitions) */\nfunction sanitizeDocs(docs) {\n    const result = new Array(docs.length);\n    for (let i = 0; i < docs.length; i++) {\n        result[i] = docs[i].toString();\n    }\n    return result;\n}\n/** @internal Split a namespace with :: into individual parts */\nfunction splitNamespace(values) {\n    const result = new Array(values.length);\n    for (let i = 0; i < values.length; i++) {\n        result[i] = values[i].split('::');\n    }\n    return result;\n}\n/** @internal Match a namespace based on parts (alongside wildcards) */\nfunction matchParts(first, second) {\n    return first.length === second.length && first.every((a, index) => {\n        const b = second[index].toString();\n        if ((a === '*') || (a === b)) {\n            return true;\n        }\n        if (a.includes('*') && a.includes('_') && b.includes('_')) {\n            let suba = a.split('_');\n            let subb = b.split('_');\n            // match initial *'s to multiples if we have a match for the other\n            if (suba[0] === '*') {\n                const indexOf = subb.indexOf(suba[1]);\n                if (indexOf !== -1) {\n                    suba = suba.slice(1);\n                    subb = subb.slice(indexOf);\n                }\n            }\n            // check for * matches at the end, adjust accordingly\n            if ((suba.length === 2) && (suba[1] === '*') && (suba[0] === subb[0])) {\n                return true;\n            }\n            return matchParts(suba, subb);\n        }\n        return false;\n    });\n}\n/** @internal check if the path matches the PATHS_ALIAS (with wildcards) */\nfunction getAliasPath({ def, path }) {\n    // specific logic for weights - we override when non-complex struct\n    // (as applied in Weight 1.5 where we also have `Compact<{ refTime: u64 }>)\n    if (['frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight'].includes(path.join('::'))) {\n        return !def.isComposite || def.asComposite.fields.length === 1\n            ? 'WeightV1'\n            : null;\n    }\n    // TODO We need to handle ink! Balance in some way\n    return path.length && PATHS_ALIAS.some((a) => matchParts(a, path))\n        ? path[path.length - 1].toString()\n        : null;\n}\n/** @internal Converts a type name into a JS-API compatible name */\nfunction extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {\n    const count = path.length;\n    // if we have no path or determined as a wrapper, we just skip it\n    if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {\n        return null;\n    }\n    const camels = new Array(count);\n    const lowers = new Array(count);\n    // initially just create arrays of the camelCase and lowercase path\n    // parts - we will check these to extract the final values. While\n    // we have 2 loops here, we also don't do the same operation twice\n    for (let i = 0; i < count; i++) {\n        const c = stringPascalCase(isInternal\n            ? path[i].replace('pallet_', '')\n            : path[i]);\n        const l = c.toLowerCase();\n        camels[i] = c;\n        lowers[i] = l;\n    }\n    let name = '';\n    for (let i = 0; i < count; i++) {\n        const l = lowers[i];\n        // Remove ::{generic, misc, pallet, traits, types}::\n        if (i !== 1 || !PATH_RM_INDEX_1.includes(l)) {\n            // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n            // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n            if (l !== lowers[i + 1]) {\n                name += camels[i];\n            }\n        }\n    }\n    // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin\n    if (camels[1] === 'RawOrigin' && count === 2 && params.length === 2 && params[1].type.isSome) {\n        const instanceType = portable[params[1].type.unwrap().toNumber()];\n        if (instanceType.type.path.length === 2) {\n            name = `${name}${instanceType.type.path[1].toString()}`;\n        }\n    }\n    return { lookupIndex, name, params };\n}\n/** @internal Alias for extractNameFlat with PortableType as a last parameter */\nfunction extractName(portable, lookupIndex, { type: { params, path } }) {\n    return extractNameFlat(portable, lookupIndex, params, path);\n}\n/** @internal Check for dupes from a specific index onwards */\nfunction nextDupeMatches(name, startAt, names) {\n    const result = [names[startAt]];\n    for (let i = startAt + 1; i < names.length; i++) {\n        const v = names[i];\n        if (v.name === name) {\n            result.push(v);\n        }\n    }\n    return result;\n}\n/** @internal Checks to see if a type is a full duplicate (with all params matching) */\nfunction rewriteDupes(input, rewrite) {\n    const count = input.length;\n    for (let i = 0; i < count; i++) {\n        const a = input[i];\n        for (let j = i + 1; j < count; j++) {\n            const b = input[j];\n            // if the indexes are not the same and the names match, we have a dupe\n            if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {\n                return false;\n            }\n        }\n    }\n    // add all the adjusted values to the rewite map\n    for (let i = 0; i < count; i++) {\n        const p = input[i];\n        rewrite[p.lookupIndex] = p.name;\n    }\n    return true;\n}\n/** @internal Find duplicates and adjust the names based on parameters */\nfunction removeDupeNames(lookup, portable, names) {\n    const rewrite = {};\n    return names\n        .map((original, startAt) => {\n        const { lookupIndex, name, params } = original;\n        if (!name) {\n            // the name is empty (this is not expected, but have a failsafe)\n            return null;\n        }\n        else if (rewrite[lookupIndex]) {\n            // we have already rewritten this one, we can skip it\n            return original;\n        }\n        // those where the name is matching starting from this index\n        const allSame = nextDupeMatches(name, startAt, names);\n        // we only have one, so all ok\n        if (allSame.length === 1) {\n            return original;\n        }\n        // are there param differences between matching names\n        const anyDiff = allSame.some((o) => params.length !== o.params.length ||\n            params.some((p, index) => !p.name.eq(o.params[index].name) ||\n                p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));\n        // everything matches, we can combine these\n        if (!anyDiff) {\n            return original;\n        }\n        // TODO We probably want to attach all the indexes with differences,\n        // not just the first\n        // find the first parameter that yields differences\n        const paramIdx = params.findIndex(({ type }, index) => allSame.every(({ params }, aIndex) => params[index].type.isSome && (aIndex === 0 ||\n            !params[index].type.eq(type))));\n        // No param found that is different\n        if (paramIdx === -1) {\n            return original;\n        }\n        // see if using the param type helps\n        const adjusted = new Array(allSame.length);\n        // loop through all, specifically checking that index where the\n        // first param yields differences\n        for (let i = 0; i < allSame.length; i++) {\n            const { lookupIndex, name, params } = allSame[i];\n            const { def, path } = lookup.getSiType(params[paramIdx].type.unwrap());\n            // if it is not a primitive and it doesn't have a path, we really cannot\n            // do anything at this point\n            if (!def.isPrimitive && !path.length) {\n                return null;\n            }\n            adjusted[i] = {\n                lookupIndex,\n                name: def.isPrimitive\n                    ? `${name}${def.asPrimitive.toString()}`\n                    : `${name}${path[path.length - 1].toString()}`\n            };\n        }\n        // check to see if the adjusted names have no issues\n        if (rewriteDupes(adjusted, rewrite)) {\n            return original;\n        }\n        // TODO This is duplicated from the section just above...\n        // ... we certainly need a better solution here\n        //\n        // Last-ditch effort to use the full type path - ugly\n        // loop through all, specifically checking that index where the\n        // first param yields differences\n        for (let i = 0; i < allSame.length; i++) {\n            const { lookupIndex, name, params } = allSame[i];\n            const { def, path } = lookup.getSiType(params[paramIdx].type.unwrap());\n            const flat = extractNameFlat(portable, lookupIndex, params, path, true);\n            if (def.isPrimitive || !flat) {\n                return null;\n            }\n            adjusted[i] = {\n                lookupIndex,\n                name: `${name}${flat.name}`\n            };\n        }\n        // check to see if the adjusted names have no issues\n        if (rewriteDupes(adjusted, rewrite)) {\n            return original;\n        }\n        return null;\n    })\n        .filter((n) => !!n)\n        .map(({ lookupIndex, name, params }) => ({\n        lookupIndex,\n        name: rewrite[lookupIndex] || name,\n        params\n    }));\n}\n/** @internal Detect on-chain types (AccountId/Signature) as set as the default */\nfunction registerTypes(lookup, lookups, names, params) {\n    // Register the types we extracted\n    lookup.registry.register(lookups);\n    // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic\n    if (params.SpRuntimeUncheckedExtrinsic) {\n        // Address, Call, Signature, Extra\n        const [addrParam, , sigParam] = params.SpRuntimeUncheckedExtrinsic;\n        const siAddress = lookup.getSiType(addrParam.type.unwrap());\n        const siSignature = lookup.getSiType(sigParam.type.unwrap());\n        const nsSignature = siSignature.path.join('::');\n        let nsAccountId = siAddress.path.join('::');\n        const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';\n        // With multiaddress, we check the first type param again\n        if (isMultiAddress) {\n            // AccountId, AccountIndex\n            const [idParam] = siAddress.params;\n            nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join('::');\n        }\n        lookup.registry.register({\n            AccountId: ['sp_core::crypto::AccountId32'].includes(nsAccountId)\n                ? 'AccountId32'\n                : ['account::AccountId20', 'primitive_types::H160'].includes(nsAccountId)\n                    ? 'AccountId20'\n                    : 'AccountId32',\n            Address: isMultiAddress\n                ? 'MultiAddress'\n                : 'AccountId',\n            ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature)\n                ? 'MultiSignature'\n                : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'\n        });\n    }\n}\n/**\n * @internal Extracts aliases based on what we know the runtime config looks like in a\n * Substrate chain. Specifically we want to have access to the Call and Event params\n **/\nfunction extractAliases(params, isContract) {\n    const hasParams = Object.keys(params).some((k) => !k.startsWith('Pallet'));\n    const alias = {};\n    if (params.SpRuntimeUncheckedExtrinsic) {\n        // Address, Call, Signature, Extra\n        const [, { type }] = params.SpRuntimeUncheckedExtrinsic;\n        alias[type.unwrap().toNumber()] = 'Call';\n    }\n    else if (hasParams && !isContract) {\n        l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');\n    }\n    if (params.FrameSystemEventRecord) {\n        // Event, Topic\n        const [{ type }] = params.FrameSystemEventRecord;\n        alias[type.unwrap().toNumber()] = 'Event';\n    }\n    else if (hasParams && !isContract) {\n        l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');\n    }\n    return alias;\n}\n/** @internal Extracts all the intreresting type information for this registry */\nfunction extractTypeInfo(lookup, portable) {\n    const nameInfo = [];\n    const types = {};\n    const porCount = portable.length;\n    for (let i = 0; i < porCount; i++) {\n        const type = portable[i];\n        const lookupIndex = type.id.toNumber();\n        const extracted = extractName(portable, lookupIndex, portable[i]);\n        if (extracted) {\n            nameInfo.push(extracted);\n        }\n        types[lookupIndex] = type;\n    }\n    const lookups = {};\n    const names = {};\n    const params = {};\n    const dedup = removeDupeNames(lookup, portable, nameInfo);\n    const dedupCount = dedup.length;\n    for (let i = 0; i < dedupCount; i++) {\n        const { lookupIndex, name, params: p } = dedup[i];\n        names[lookupIndex] = name;\n        lookups[name] = lookup.registry.createLookupType(lookupIndex);\n        params[name] = p;\n    }\n    return { lookups, names, params, types };\n}\nexport class PortableRegistry extends Struct {\n    constructor(registry, value, isContract) {\n        // const timeStart = performance.now()\n        super(registry, {\n            types: 'Vec<PortableType>'\n        }, value);\n        _PortableRegistry_instances.add(this);\n        _PortableRegistry_alias.set(this, void 0);\n        _PortableRegistry_lookups.set(this, void 0);\n        _PortableRegistry_names.set(this, void 0);\n        _PortableRegistry_params.set(this, void 0);\n        _PortableRegistry_typeDefs.set(this, {});\n        _PortableRegistry_types.set(this, void 0);\n        const { lookups, names, params, types } = extractTypeInfo(this, this.types);\n        __classPrivateFieldSet(this, _PortableRegistry_alias, extractAliases(params, isContract), \"f\");\n        __classPrivateFieldSet(this, _PortableRegistry_lookups, lookups, \"f\");\n        __classPrivateFieldSet(this, _PortableRegistry_names, names, \"f\");\n        __classPrivateFieldSet(this, _PortableRegistry_params, params, \"f\");\n        __classPrivateFieldSet(this, _PortableRegistry_types, types, \"f\");\n        // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)\n    }\n    /**\n     * @description Returns all the available type names for this chain\n     **/\n    get names() {\n        return Object.values(__classPrivateFieldGet(this, _PortableRegistry_names, \"f\")).sort();\n    }\n    /**\n     * @description The types of the registry\n     */\n    get types() {\n        return this.getT('types');\n    }\n    /**\n     * @description Register all available types into the registry (generally for internal usage)\n     */\n    register() {\n        registerTypes(this, __classPrivateFieldGet(this, _PortableRegistry_lookups, \"f\"), __classPrivateFieldGet(this, _PortableRegistry_names, \"f\"), __classPrivateFieldGet(this, _PortableRegistry_params, \"f\"));\n    }\n    /**\n     * @description Returns the name for a specific lookup\n     */\n    getName(lookupId) {\n        return __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[__classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_getLookupId).call(this, lookupId)];\n    }\n    /**\n     * @description Finds a specific type in the registry\n     */\n    getSiType(lookupId) {\n        // NOTE catch-22 - this may already be used as part of the constructor, so\n        // ensure that we have actually initialized it correctly\n        const found = (__classPrivateFieldGet(this, _PortableRegistry_types, \"f\") || this.types)[__classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_getLookupId).call(this, lookupId)];\n        if (!found) {\n            throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n        }\n        return found.type;\n    }\n    /**\n     * @description Lookup the type definition for the index\n     */\n    getTypeDef(lookupId) {\n        const lookupIndex = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_getLookupId).call(this, lookupId);\n        if (!__classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex]) {\n            const lookupName = __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex];\n            const empty = {\n                info: TypeDefInfo.DoNotConstruct,\n                lookupIndex,\n                lookupName,\n                type: this.registry.createLookupType(lookupIndex)\n            };\n            // Set named items since we will get into circular lookups along the way\n            if (lookupName) {\n                __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex] = empty;\n            }\n            const extracted = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extract).call(this, this.getSiType(lookupId), lookupIndex);\n            // For non-named items, we only set this right at the end\n            if (!lookupName) {\n                __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex] = empty;\n            }\n            Object.keys(extracted).forEach((k) => {\n                if (k !== 'lookupName' || extracted[k]) {\n                    // these are safe since we are looking through the keys as set\n                    __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex][k] = extracted[k];\n                }\n            });\n            // don't set lookupName on lower-level, we want to always direct to the type\n            if (extracted.info === TypeDefInfo.Plain) {\n                __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex].lookupNameRoot = __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex].lookupName;\n                delete __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex].lookupName;\n            }\n        }\n        return __classPrivateFieldGet(this, _PortableRegistry_typeDefs, \"f\")[lookupIndex];\n    }\n    /**\n     * @description For a specific field, perform adjustments to not have built-in conflicts\n     */\n    sanitizeField(name) {\n        let nameField = null;\n        let nameOrig = null;\n        if (name.isSome) {\n            nameField = stringCamelCase(name.unwrap());\n            if (nameField.includes('#')) {\n                nameOrig = nameField;\n                nameField = nameOrig.replace(/#/g, '_');\n            }\n            else if (RESERVED.includes(nameField)) {\n                nameOrig = nameField;\n                nameField = `${nameField}_`;\n            }\n        }\n        return [nameField, nameOrig];\n    }\n}\n_PortableRegistry_alias = new WeakMap(), _PortableRegistry_lookups = new WeakMap(), _PortableRegistry_names = new WeakMap(), _PortableRegistry_params = new WeakMap(), _PortableRegistry_typeDefs = new WeakMap(), _PortableRegistry_types = new WeakMap(), _PortableRegistry_instances = new WeakSet(), _PortableRegistry_createSiDef = function _PortableRegistry_createSiDef(lookupId) {\n    const typeDef = this.getTypeDef(lookupId);\n    const lookupIndex = lookupId.toNumber();\n    // Setup for a lookup on complex types\n    return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName\n        ? {\n            docs: typeDef.docs,\n            info: TypeDefInfo.Si,\n            lookupIndex,\n            lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n            type: this.registry.createLookupType(lookupId)\n        }\n        : typeDef;\n}, _PortableRegistry_getLookupId = function _PortableRegistry_getLookupId(lookupId) {\n    if (isString(lookupId)) {\n        if (!this.registry.isLookupType(lookupId)) {\n            throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n        }\n        return parseInt(lookupId.replace('Lookup', ''), 10);\n    }\n    else if (isNumber(lookupId)) {\n        return lookupId;\n    }\n    return lookupId.toNumber();\n}, _PortableRegistry_extract = function _PortableRegistry_extract(type, lookupIndex) {\n    const namespace = type.path.join('::');\n    let typeDef;\n    const aliasType = __classPrivateFieldGet(this, _PortableRegistry_alias, \"f\")[lookupIndex] || getAliasPath(type);\n    try {\n        if (aliasType) {\n            typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractAliasPath).call(this, lookupIndex, aliasType);\n        }\n        else {\n            switch (type.def.type) {\n                case 'Array':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractArray).call(this, lookupIndex, type.def.asArray);\n                    break;\n                case 'BitSequence':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractBitSequence).call(this, lookupIndex, type.def.asBitSequence);\n                    break;\n                case 'Compact':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractCompact).call(this, lookupIndex, type.def.asCompact);\n                    break;\n                case 'Composite':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractComposite).call(this, lookupIndex, type, type.def.asComposite);\n                    break;\n                case 'HistoricMetaCompat':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractHistoric).call(this, lookupIndex, type.def.asHistoricMetaCompat);\n                    break;\n                case 'Primitive':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractPrimitive).call(this, lookupIndex, type);\n                    break;\n                case 'Sequence':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractSequence).call(this, lookupIndex, type.def.asSequence);\n                    break;\n                case 'Tuple':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractTuple).call(this, lookupIndex, type.def.asTuple);\n                    break;\n                case 'Variant':\n                    typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractVariant).call(this, lookupIndex, type, type.def.asVariant);\n                    break;\n                default: assertUnreachable(type.def.type);\n            }\n        }\n    }\n    catch (error) {\n        throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n    }\n    return objectSpread({\n        docs: sanitizeDocs(type.docs),\n        namespace\n    }, typeDef);\n}, _PortableRegistry_extractArray = function _PortableRegistry_extractArray(_, { len, type }) {\n    const length = len.toNumber();\n    if (length > 2048) {\n        throw new Error('Only support for [Type; <length>], where length <= 2048');\n    }\n    return withTypeString(this.registry, {\n        info: TypeDefInfo.VecFixed,\n        length,\n        sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type)\n    });\n}, _PortableRegistry_extractBitSequence = function _PortableRegistry_extractBitSequence(_, { bitOrderType, bitStoreType }) {\n    // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine\n    // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly\n    const a = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, bitOrderType);\n    const b = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, bitStoreType);\n    const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || '')\n        ? [a, b]\n        : [b, a];\n    if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {\n        throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n    }\n    else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== 'u8') {\n        throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);\n    }\n    const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);\n    if (!isLsb) {\n        // TODO To remove this limitation, we need to pass an extra info flag\n        // through to the TypeDef (Here we could potentially re-use something\n        // like index (???) to indicate and ensure we use it to pass to the\n        // BitVec constructor - which does handle this type)\n        //\n        // See https://github.com/polkadot-js/api/issues/5588\n        // throw new Error(`Only LSB BitVec is currently supported, found ${bitOrder.namespace}`);\n    }\n    return {\n        info: TypeDefInfo.Plain,\n        type: 'BitVec'\n    };\n}, _PortableRegistry_extractCompact = function _PortableRegistry_extractCompact(_, { type }) {\n    return withTypeString(this.registry, {\n        info: TypeDefInfo.Compact,\n        sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type)\n    });\n}, _PortableRegistry_extractComposite = function _PortableRegistry_extractComposite(lookupIndex, { params, path }, { fields }) {\n    if (path.length) {\n        const pathFirst = path[0].toString();\n        const pathLast = path[path.length - 1].toString();\n        if (path.length === 1 && pathFirst === 'BTreeMap') {\n            if (params.length !== 2) {\n                throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);\n            }\n            return withTypeString(this.registry, {\n                info: TypeDefInfo.BTreeMap,\n                sub: params.map(({ type }) => __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type.unwrap()))\n            });\n        }\n        else if (path.length === 1 && pathFirst === 'BTreeSet') {\n            if (params.length !== 1) {\n                throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);\n            }\n            return withTypeString(this.registry, {\n                info: TypeDefInfo.BTreeSet,\n                sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap())\n            });\n        }\n        else if (['Range', 'RangeInclusive'].includes(pathFirst)) {\n            if (params.length !== 1) {\n                throw new Error(`Range requires 1 parameter, found ${params.length}`);\n            }\n            return withTypeString(this.registry, {\n                info: pathFirst === 'Range'\n                    ? TypeDefInfo.Range\n                    : TypeDefInfo.RangeInclusive,\n                sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap()),\n                type: pathFirst\n            });\n        }\n        else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {\n            if (params.length !== 1) {\n                throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);\n            }\n            return withTypeString(this.registry, {\n                info: pathLast === 'WrapperKeepOpaque'\n                    ? TypeDefInfo.WrapperKeepOpaque\n                    : TypeDefInfo.WrapperOpaque,\n                sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap()),\n                type: pathLast\n            });\n        }\n    }\n    return PATHS_SET.some((p) => matchParts(p, path))\n        ? __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractCompositeSet).call(this, lookupIndex, params, fields)\n        : __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractFields).call(this, lookupIndex, fields);\n}, _PortableRegistry_extractCompositeSet = function _PortableRegistry_extractCompositeSet(_, params, fields) {\n    if (params.length !== 1 || fields.length !== 1) {\n        throw new Error('Set handling expects param/field as single entries');\n    }\n    return withTypeString(this.registry, {\n        info: TypeDefInfo.Set,\n        length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),\n        sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({ index, name }) => ({\n            // This will be an issue > 2^53 - 1 ... don't have those (yet)\n            index: index.toNumber(),\n            info: TypeDefInfo.Plain,\n            name: name.toString(),\n            type: 'Null'\n        }))\n    });\n}, _PortableRegistry_extractFields = function _PortableRegistry_extractFields(lookupIndex, fields) {\n    let isStruct = true;\n    let isTuple = true;\n    for (let f = 0; f < fields.length; f++) {\n        const { name } = fields[f];\n        isStruct = isStruct && name.isSome;\n        isTuple = isTuple && name.isNone;\n    }\n    if (!isTuple && !isStruct) {\n        throw new Error('Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n    }\n    if (fields.length === 0) {\n        return {\n            info: TypeDefInfo.Null,\n            type: 'Null'\n        };\n    }\n    else if (isTuple && fields.length === 1) {\n        const typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, fields[0].type);\n        return objectSpread({}, typeDef, lookupIndex === -1\n            ? null\n            : {\n                lookupIndex,\n                lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n                lookupNameRoot: typeDef.lookupName\n            }, fields[0].typeName.isSome\n            ? { typeName: sanitize(fields[0].typeName.unwrap()) }\n            : null);\n    }\n    const [sub, alias] = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractFieldsAlias).call(this, fields);\n    return withTypeString(this.registry, objectSpread({\n        info: isTuple // Tuple check first\n            ? TypeDefInfo.Tuple\n            : TypeDefInfo.Struct,\n        sub\n    }, alias.size\n        ? { alias }\n        : null, lookupIndex === -1\n        ? null\n        : {\n            lookupIndex,\n            lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex]\n        }));\n}, _PortableRegistry_extractFieldsAlias = function _PortableRegistry_extractFieldsAlias(fields) {\n    const alias = new Map();\n    const sub = new Array(fields.length);\n    for (let i = 0; i < fields.length; i++) {\n        const { docs, name, type, typeName } = fields[i];\n        const typeDef = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type);\n        if (name.isNone) {\n            sub[i] = typeDef;\n        }\n        else {\n            const [nameField, nameOrig] = this.sanitizeField(name);\n            if (nameField && nameOrig) {\n                alias.set(nameField, nameOrig);\n            }\n            sub[i] = objectSpread({\n                docs: sanitizeDocs(docs),\n                name: nameField\n            }, typeDef, typeName.isSome\n                ? { typeName: sanitize(typeName.unwrap()) }\n                : null);\n        }\n    }\n    return [sub, alias];\n}, _PortableRegistry_extractHistoric = function _PortableRegistry_extractHistoric(_, type) {\n    return objectSpread({\n        displayName: type.toString(),\n        isFromSi: true\n    }, getTypeDef(type));\n}, _PortableRegistry_extractPrimitive = function _PortableRegistry_extractPrimitive(_, type) {\n    const typeStr = type.def.asPrimitive.type.toString();\n    return {\n        info: TypeDefInfo.Plain,\n        type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n    };\n}, _PortableRegistry_extractAliasPath = function _PortableRegistry_extractAliasPath(_, type) {\n    return {\n        info: TypeDefInfo.Plain,\n        type\n    };\n}, _PortableRegistry_extractSequence = function _PortableRegistry_extractSequence(lookupIndex, { type }) {\n    const sub = __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type);\n    if (sub.type === 'u8') {\n        return {\n            info: TypeDefInfo.Plain,\n            type: 'Bytes'\n        };\n    }\n    return withTypeString(this.registry, {\n        info: TypeDefInfo.Vec,\n        lookupIndex,\n        lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n        sub\n    });\n}, _PortableRegistry_extractTuple = function _PortableRegistry_extractTuple(lookupIndex, ids) {\n    if (ids.length === 0) {\n        return {\n            info: TypeDefInfo.Null,\n            type: 'Null'\n        };\n    }\n    else if (ids.length === 1) {\n        return this.getTypeDef(ids[0]);\n    }\n    const sub = ids.map((t) => __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, t));\n    return withTypeString(this.registry, {\n        info: TypeDefInfo.Tuple,\n        lookupIndex,\n        lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n        sub\n    });\n}, _PortableRegistry_extractVariant = function _PortableRegistry_extractVariant(lookupIndex, { params, path }, { variants }) {\n    if (path.length) {\n        const specialVariant = path[0].toString();\n        if (specialVariant === 'Option') {\n            if (params.length !== 1) {\n                throw new Error(`Option requires 1 parameter, found ${params.length}`);\n            }\n            // NOTE This is opt-in (unhandled), not by default\n            // if (sub.type === 'bool') {\n            //   return withTypeString(this.registry, {\n            //     info: TypeDefInfo.Plain,\n            //     type: 'OptionBool'\n            //   });\n            // }\n            return withTypeString(this.registry, {\n                info: TypeDefInfo.Option,\n                sub: __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, params[0].type.unwrap())\n            });\n        }\n        else if (specialVariant === 'Result') {\n            if (params.length !== 2) {\n                throw new Error(`Result requires 2 parameters, found ${params.length}`);\n            }\n            return withTypeString(this.registry, {\n                info: TypeDefInfo.Result,\n                sub: params.map(({ type }, index) => objectSpread({\n                    name: ['Ok', 'Error'][index]\n                }, __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_createSiDef).call(this, type.unwrap())))\n            });\n        }\n    }\n    if (variants.length === 0) {\n        return {\n            info: TypeDefInfo.Null,\n            type: 'Null'\n        };\n    }\n    return __classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractVariantEnum).call(this, lookupIndex, variants);\n}, _PortableRegistry_extractVariantEnum = function _PortableRegistry_extractVariantEnum(lookupIndex, variants) {\n    const sub = [];\n    // we may get entries out of order, arrange them first before creating with gaps filled\n    // NOTE: Since we mutate, use a copy of the array as an input\n    variants\n        .slice()\n        .sort((a, b) => a.index.cmp(b.index))\n        .forEach(({ fields, index: bnIndex, name }) => {\n        const index = bnIndex.toNumber();\n        while (sub.length !== index) {\n            sub.push({\n                index: sub.length,\n                info: TypeDefInfo.Null,\n                name: `__Unused${sub.length}`,\n                type: 'Null'\n            });\n        }\n        sub.push(objectSpread(__classPrivateFieldGet(this, _PortableRegistry_instances, \"m\", _PortableRegistry_extractFields).call(this, -1, fields), {\n            index,\n            name: name.toString()\n        }));\n    });\n    return withTypeString(this.registry, {\n        info: TypeDefInfo.Enum,\n        lookupIndex,\n        lookupName: __classPrivateFieldGet(this, _PortableRegistry_names, \"f\")[lookupIndex],\n        sub\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}