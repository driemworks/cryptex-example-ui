{"ast":null,"code":"import { u8aToHex } from '@polkadot/util';\n/** @internal */\nfunction formatFailure(registry, fn, _result, _ref, u8a, i, count, Type, key) {\n  let {\n    message\n  } = _ref;\n  let type = '';\n  try {\n    type = `: ${new Type(registry).toRawType()}`;\n  } catch {\n    // ignore\n  }\n  // This is extra debugging info (we most-probably want this in in some way, shape or form,\n  // but at this point not quite sure how to include and format it (it can be quite massive)\n  // console.error(JSON.stringify(result, null, 2));\n  return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}…${key ? ` on ${key}` : ''} (index ${i + 1}/${count})${type}:: ${message}`;\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, _ref2) {\n  let [Types, keys] = _ref2;\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, _ref3) {\n  let [Types, keys] = _ref3;\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = [keys[i], value];\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n  const count = result.length;\n  let offset = startAt;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Type(registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n  }\n  return [offset, offset - startAt];\n}","map":{"version":3,"names":["u8aToHex","formatFailure","registry","fn","_result","_ref","u8a","i","count","Type","key","message","type","toRawType","subarray","decodeU8a","result","_ref2","Types","keys","length","offset","value","initialU8aLength","encodedLength","error","Error","decodeU8aStruct","_ref3","decodeU8aVec","startAt"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/utils/decodeU8a.js"],"sourcesContent":["import { u8aToHex } from '@polkadot/util';\n/** @internal */\nfunction formatFailure(registry, fn, _result, { message }, u8a, i, count, Type, key) {\n    let type = '';\n    try {\n        type = `: ${new Type(registry).toRawType()}`;\n    }\n    catch {\n        // ignore\n    }\n    // This is extra debugging info (we most-probably want this in in some way, shape or form,\n    // but at this point not quite sure how to include and format it (it can be quite massive)\n    // console.error(JSON.stringify(result, null, 2));\n    return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}…${key ? ` on ${key}` : ''} (index ${i + 1}/${count})${type}:: ${message}`;\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = [keys[i], value];\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n    const count = result.length;\n    let offset = startAt;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Type(registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n    }\n    return [offset, offset - startAt];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}