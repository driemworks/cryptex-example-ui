{"ast":null,"code":"import { stringCamelCase } from '@polkadot/util';\nimport { getAliasTypes } from '../../interfaces/alias.js';\nimport { knownOrigins } from '../../interfaces/runtime/definitions.js';\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Creates a compatible type mapping\n * @internal\n **/\nfunction compatType(specs, _type) {\n  const type = _type.toString();\n  const index = specs.findIndex(_ref => {\n    let {\n      def\n    } = _ref;\n    return def.HistoricMetaCompat === type;\n  });\n  if (index !== -1) {\n    return index;\n  }\n  return specs.push({\n    def: {\n      HistoricMetaCompat: type\n    }\n  }) - 1;\n}\nfunction compatTypes(specs) {\n  for (let i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {\n    compatType(specs, i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);\n  }\n}\nfunction makeTupleType(specs, entries) {\n  return specs.push({\n    def: {\n      Tuple: entries\n    }\n  }) - 1;\n}\nfunction makeVariantType(modName, variantType, specs, variants) {\n  return specs.push({\n    def: {\n      Variant: {\n        variants\n      }\n    },\n    path: [`pallet_${modName.toString()}`, 'pallet', variantType]\n  }) - 1;\n}\n/**\n * @internal\n * generate & register the OriginCaller type\n **/\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, _ref2) => {\n        let [name, index] = _ref2;\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n        result[name] = knownOrigins[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/**\n * Find and apply the correct type override\n * @internal\n **/\nfunction setTypeOverride(sectionTypes, types) {\n  types.forEach(type => {\n    const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n    if (override) {\n      type.setOverride(sectionTypes[override]);\n    } else {\n      // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n      const orig = type.toString();\n      const alias = Object.entries(sectionTypes).reduce((result, _ref3) => {\n        let [src, dst] = _ref3;\n        return BOXES.reduce((result, _ref4) => {\n          let [a, z] = _ref4;\n          return result.replace(`${a}${src}${z}`, `${a}${dst}${z}`);\n        }, result);\n      }, orig);\n      if (orig !== alias) {\n        type.setOverride(alias);\n      }\n    }\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertCalls(specs, registry, modName, calls, sectionTypes) {\n  const variants = calls.map((_ref5, index) => {\n    let {\n      args,\n      docs,\n      name\n    } = _ref5;\n    setTypeOverride(sectionTypes, args.map(_ref6 => {\n      let {\n        type\n      } = _ref6;\n      return type;\n    }));\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: args.map(_ref7 => {\n        let {\n          name,\n          type\n        } = _ref7;\n        return registry.createTypeUnsafe('SiField', [{\n          name,\n          type: compatType(specs, type)\n        }]);\n      }),\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletCallMetadataV14', [{\n    type: makeVariantType(modName, 'Call', specs, variants)\n  }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertConstants(specs, registry, constants, sectionTypes) {\n  return constants.map(_ref8 => {\n    let {\n      docs,\n      name,\n      type,\n      value\n    } = _ref8;\n    setTypeOverride(sectionTypes, [type]);\n    return registry.createTypeUnsafe('PalletConstantMetadataV14', [{\n      docs,\n      name,\n      type: compatType(specs, type),\n      value\n    }]);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertErrors(specs, registry, modName, errors, _sectionTypes) {\n  const variants = errors.map((_ref9, index) => {\n    let {\n      docs,\n      name\n    } = _ref9;\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: [],\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletErrorMetadataV14', [{\n    type: makeVariantType(modName, 'Error', specs, variants)\n  }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertEvents(specs, registry, modName, events, sectionTypes) {\n  const variants = events.map((_ref10, index) => {\n    let {\n      args,\n      docs,\n      name\n    } = _ref10;\n    setTypeOverride(sectionTypes, args);\n    return registry.createTypeUnsafe('SiVariant', [{\n      docs,\n      fields: args.map(t => registry.createTypeUnsafe('SiField', [{\n        type: compatType(specs, t)\n      }])),\n      index,\n      name\n    }]);\n  });\n  return registry.createTypeUnsafe('PalletEventMetadataV14', [{\n    type: makeVariantType(modName, 'Event', specs, variants)\n  }]);\n}\nfunction createMapEntry(specs, registry, sectionTypes, _ref11) {\n  let {\n    hashers,\n    isLinked,\n    isOptional,\n    keys,\n    value\n  } = _ref11;\n  setTypeOverride(sectionTypes, [value, ...(Array.isArray(keys) ? keys : [keys])]);\n  return registry.createTypeUnsafe('StorageEntryTypeV14', [{\n    Map: {\n      hashers,\n      key: hashers.length === 1 ? compatType(specs, keys[0]) : makeTupleType(specs, keys.map(t => compatType(specs, t))),\n      value: isLinked\n      // For previous-generation linked-map support, the actual storage result\n      // is a Tuple with the value and the Linkage (Option appears in teh value-part only)\n      ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys[0].toString()}>)`) : compatType(specs, value)\n    }\n  }]);\n}\n/**\n * Apply module-specific storage type overrides (always part of toV14)\n * @internal\n **/\nfunction convertStorage(specs, registry, _ref12, sectionTypes) {\n  let {\n    items,\n    prefix\n  } = _ref12;\n  return registry.createTypeUnsafe('PalletStorageMetadataV14', [{\n    items: items.map(_ref13 => {\n      let {\n        docs,\n        fallback,\n        modifier,\n        name,\n        type\n      } = _ref13;\n      let entryType;\n      if (type.isPlain) {\n        const plain = type.asPlain;\n        setTypeOverride(sectionTypes, [plain]);\n        entryType = registry.createTypeUnsafe('StorageEntryTypeV14', [{\n          Plain: compatType(specs, plain)\n        }]);\n      } else if (type.isMap) {\n        const map = type.asMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: [map.hasher],\n          isLinked: map.linked.isTrue,\n          isOptional: modifier.isOptional,\n          keys: [map.key],\n          value: map.value\n        });\n      } else if (type.isDoubleMap) {\n        const dm = type.asDoubleMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: [dm.hasher, dm.key2Hasher],\n          isLinked: false,\n          isOptional: modifier.isOptional,\n          keys: [dm.key1, dm.key2],\n          value: dm.value\n        });\n      } else {\n        const nm = type.asNMap;\n        entryType = createMapEntry(specs, registry, sectionTypes, {\n          hashers: nm.hashers,\n          isLinked: false,\n          isOptional: modifier.isOptional,\n          keys: nm.keyVec,\n          value: nm.value\n        });\n      }\n      return registry.createTypeUnsafe('StorageEntryMetadataV14', [{\n        docs,\n        fallback,\n        modifier,\n        name,\n        type: entryType\n      }]);\n    }),\n    prefix\n  }]);\n}\n/** @internal */\nfunction convertExtrinsic(registry, _ref14) {\n  let {\n    signedExtensions,\n    version\n  } = _ref14;\n  return registry.createTypeUnsafe('ExtrinsicMetadataV14', [{\n    signedExtensions: signedExtensions.map(identifier => ({\n      identifier,\n      type: 0 // we don't map the fields at all\n    })),\n\n    type: 0,\n    version\n  }]);\n}\n/** @internal */\nfunction createPallet(specs, registry, mod, _ref15) {\n  let {\n    calls,\n    constants,\n    errors,\n    events,\n    storage\n  } = _ref15;\n  const sectionTypes = getAliasTypes(registry, stringCamelCase(mod.name));\n  return registry.createTypeUnsafe('PalletMetadataV14', [{\n    calls: calls && convertCalls(specs, registry, mod.name, calls, sectionTypes),\n    constants: convertConstants(specs, registry, constants, sectionTypes),\n    errors: errors && convertErrors(specs, registry, mod.name, errors, sectionTypes),\n    events: events && convertEvents(specs, registry, mod.name, events, sectionTypes),\n    index: mod.index,\n    name: mod.name,\n    storage: storage && convertStorage(specs, registry, storage, sectionTypes)\n  }]);\n}\n/**\n * Convert the Metadata to v14\n * @internal\n **/\nexport function toV14(registry, v13, metaVersion) {\n  const specs = [];\n  // position 0 always has Null, additionally add internal defaults\n  compatTypes(specs, 'Null', 'u8', 'u16', 'u32', 'u64');\n  registerOriginCaller(registry, v13.modules, metaVersion);\n  const extrinsic = convertExtrinsic(registry, v13.extrinsic);\n  const pallets = v13.modules.map(mod => createPallet(specs, registry, mod, {\n    calls: mod.calls.unwrapOr(null),\n    constants: mod.constants,\n    errors: mod.errors.length ? mod.errors : null,\n    events: mod.events.unwrapOr(null),\n    storage: mod.storage.unwrapOr(null)\n  }));\n  return registry.createTypeUnsafe('MetadataV14', [{\n    extrinsic,\n    lookup: {\n      types: specs.map((type, id) => registry.createTypeUnsafe('PortableType', [{\n        id,\n        type\n      }]))\n    },\n    pallets\n  }]);\n}","map":{"version":3,"names":["stringCamelCase","getAliasTypes","knownOrigins","BOXES","compatType","specs","_type","type","toString","index","findIndex","_ref","def","HistoricMetaCompat","push","compatTypes","i","arguments","length","undefined","makeTupleType","entries","Tuple","makeVariantType","modName","variantType","variants","Variant","path","registerOriginCaller","registry","modules","metaVersion","register","OriginCaller","_enum","map","mod","name","toNumber","sort","a","b","reduce","result","_ref2","Object","keys","setTypeOverride","sectionTypes","types","forEach","override","find","aliased","eq","setOverride","orig","alias","_ref3","src","dst","_ref4","z","replace","convertCalls","calls","_ref5","args","docs","_ref6","createTypeUnsafe","fields","_ref7","convertConstants","constants","_ref8","value","convertErrors","errors","_sectionTypes","_ref9","convertEvents","events","_ref10","t","createMapEntry","_ref11","hashers","isLinked","isOptional","Array","isArray","Map","key","convertStorage","_ref12","items","prefix","_ref13","fallback","modifier","entryType","isPlain","plain","asPlain","Plain","isMap","asMap","hasher","linked","isTrue","isDoubleMap","dm","asDoubleMap","key2Hasher","key1","key2","nm","asNMap","keyVec","convertExtrinsic","_ref14","signedExtensions","version","identifier","createPallet","_ref15","storage","toV14","v13","extrinsic","pallets","unwrapOr","lookup","id"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/metadata/v13/toV14.js"],"sourcesContent":["import { stringCamelCase } from '@polkadot/util';\nimport { getAliasTypes } from '../../interfaces/alias.js';\nimport { knownOrigins } from '../../interfaces/runtime/definitions.js';\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Creates a compatible type mapping\n * @internal\n **/\nfunction compatType(specs, _type) {\n    const type = _type.toString();\n    const index = specs.findIndex(({ def }) => def.HistoricMetaCompat === type);\n    if (index !== -1) {\n        return index;\n    }\n    return specs.push({\n        def: {\n            HistoricMetaCompat: type\n        }\n    }) - 1;\n}\nfunction compatTypes(specs, ...types) {\n    for (let i = 0; i < types.length; i++) {\n        compatType(specs, types[i]);\n    }\n}\nfunction makeTupleType(specs, entries) {\n    return specs.push({\n        def: {\n            Tuple: entries\n        }\n    }) - 1;\n}\nfunction makeVariantType(modName, variantType, specs, variants) {\n    return specs.push({\n        def: {\n            Variant: { variants }\n        },\n        path: [`pallet_${modName.toString()}`, 'pallet', variantType]\n    }) - 1;\n}\n/**\n * @internal\n * generate & register the OriginCaller type\n **/\nfunction registerOriginCaller(registry, modules, metaVersion) {\n    registry.register({\n        OriginCaller: {\n            _enum: modules\n                .map((mod, index) => [\n                mod.name.toString(),\n                metaVersion >= 12\n                    ? mod.index.toNumber()\n                    : index\n            ])\n                .sort((a, b) => a[1] - b[1])\n                .reduce((result, [name, index]) => {\n                for (let i = Object.keys(result).length; i < index; i++) {\n                    result[`Empty${i}`] = 'Null';\n                }\n                result[name] = knownOrigins[name] || 'Null';\n                return result;\n            }, {})\n        }\n    });\n}\n/**\n * Find and apply the correct type override\n * @internal\n **/\nfunction setTypeOverride(sectionTypes, types) {\n    types.forEach((type) => {\n        const override = Object.keys(sectionTypes).find((aliased) => type.eq(aliased));\n        if (override) {\n            type.setOverride(sectionTypes[override]);\n        }\n        else {\n            // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n            const orig = type.toString();\n            const alias = Object\n                .entries(sectionTypes)\n                .reduce((result, [src, dst]) => BOXES.reduce((result, [a, z]) => result.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);\n            if (orig !== alias) {\n                type.setOverride(alias);\n            }\n        }\n    });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertCalls(specs, registry, modName, calls, sectionTypes) {\n    const variants = calls.map(({ args, docs, name }, index) => {\n        setTypeOverride(sectionTypes, args.map(({ type }) => type));\n        return registry.createTypeUnsafe('SiVariant', [{\n                docs,\n                fields: args.map(({ name, type }) => registry.createTypeUnsafe('SiField', [{ name, type: compatType(specs, type) }])),\n                index,\n                name\n            }]);\n    });\n    return registry.createTypeUnsafe('PalletCallMetadataV14', [{\n            type: makeVariantType(modName, 'Call', specs, variants)\n        }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertConstants(specs, registry, constants, sectionTypes) {\n    return constants.map(({ docs, name, type, value }) => {\n        setTypeOverride(sectionTypes, [type]);\n        return registry.createTypeUnsafe('PalletConstantMetadataV14', [{\n                docs,\n                name,\n                type: compatType(specs, type),\n                value\n            }]);\n    });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n */\nfunction convertErrors(specs, registry, modName, errors, _sectionTypes) {\n    const variants = errors.map(({ docs, name }, index) => registry.createTypeUnsafe('SiVariant', [{\n            docs,\n            fields: [],\n            index,\n            name\n        }]));\n    return registry.createTypeUnsafe('PalletErrorMetadataV14', [{\n            type: makeVariantType(modName, 'Error', specs, variants)\n        }]);\n}\n/**\n * Apply module-specific type overrides (always be done as part of toV14)\n * @internal\n **/\nfunction convertEvents(specs, registry, modName, events, sectionTypes) {\n    const variants = events.map(({ args, docs, name }, index) => {\n        setTypeOverride(sectionTypes, args);\n        return registry.createTypeUnsafe('SiVariant', [{\n                docs,\n                fields: args.map((t) => registry.createTypeUnsafe('SiField', [{ type: compatType(specs, t) }])),\n                index,\n                name\n            }]);\n    });\n    return registry.createTypeUnsafe('PalletEventMetadataV14', [{\n            type: makeVariantType(modName, 'Event', specs, variants)\n        }]);\n}\nfunction createMapEntry(specs, registry, sectionTypes, { hashers, isLinked, isOptional, keys, value }) {\n    setTypeOverride(sectionTypes, [value, ...(Array.isArray(keys) ? keys : [keys])]);\n    return registry.createTypeUnsafe('StorageEntryTypeV14', [{\n            Map: {\n                hashers,\n                key: hashers.length === 1\n                    ? compatType(specs, keys[0])\n                    : makeTupleType(specs, keys.map((t) => compatType(specs, t))),\n                value: isLinked\n                    // For previous-generation linked-map support, the actual storage result\n                    // is a Tuple with the value and the Linkage (Option appears in teh value-part only)\n                    ? compatType(specs, `(${isOptional ? `Option<${value.toString()}>` : value.toString()}, Linkage<${keys[0].toString()}>)`)\n                    : compatType(specs, value)\n            }\n        }]);\n}\n/**\n * Apply module-specific storage type overrides (always part of toV14)\n * @internal\n **/\nfunction convertStorage(specs, registry, { items, prefix }, sectionTypes) {\n    return registry.createTypeUnsafe('PalletStorageMetadataV14', [{\n            items: items.map(({ docs, fallback, modifier, name, type }) => {\n                let entryType;\n                if (type.isPlain) {\n                    const plain = type.asPlain;\n                    setTypeOverride(sectionTypes, [plain]);\n                    entryType = registry.createTypeUnsafe('StorageEntryTypeV14', [{\n                            Plain: compatType(specs, plain)\n                        }]);\n                }\n                else if (type.isMap) {\n                    const map = type.asMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: [map.hasher],\n                        isLinked: map.linked.isTrue,\n                        isOptional: modifier.isOptional,\n                        keys: [map.key],\n                        value: map.value\n                    });\n                }\n                else if (type.isDoubleMap) {\n                    const dm = type.asDoubleMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: [dm.hasher, dm.key2Hasher],\n                        isLinked: false,\n                        isOptional: modifier.isOptional,\n                        keys: [dm.key1, dm.key2],\n                        value: dm.value\n                    });\n                }\n                else {\n                    const nm = type.asNMap;\n                    entryType = createMapEntry(specs, registry, sectionTypes, {\n                        hashers: nm.hashers,\n                        isLinked: false,\n                        isOptional: modifier.isOptional,\n                        keys: nm.keyVec,\n                        value: nm.value\n                    });\n                }\n                return registry.createTypeUnsafe('StorageEntryMetadataV14', [{\n                        docs,\n                        fallback,\n                        modifier,\n                        name,\n                        type: entryType\n                    }]);\n            }),\n            prefix\n        }]);\n}\n/** @internal */\nfunction convertExtrinsic(registry, { signedExtensions, version }) {\n    return registry.createTypeUnsafe('ExtrinsicMetadataV14', [{\n            signedExtensions: signedExtensions.map((identifier) => ({\n                identifier,\n                type: 0 // we don't map the fields at all\n            })),\n            type: 0,\n            version\n        }]);\n}\n/** @internal */\nfunction createPallet(specs, registry, mod, { calls, constants, errors, events, storage }) {\n    const sectionTypes = getAliasTypes(registry, stringCamelCase(mod.name));\n    return registry.createTypeUnsafe('PalletMetadataV14', [{\n            calls: calls && convertCalls(specs, registry, mod.name, calls, sectionTypes),\n            constants: convertConstants(specs, registry, constants, sectionTypes),\n            errors: errors && convertErrors(specs, registry, mod.name, errors, sectionTypes),\n            events: events && convertEvents(specs, registry, mod.name, events, sectionTypes),\n            index: mod.index,\n            name: mod.name,\n            storage: storage && convertStorage(specs, registry, storage, sectionTypes)\n        }]);\n}\n/**\n * Convert the Metadata to v14\n * @internal\n **/\nexport function toV14(registry, v13, metaVersion) {\n    const specs = [];\n    // position 0 always has Null, additionally add internal defaults\n    compatTypes(specs, 'Null', 'u8', 'u16', 'u32', 'u64');\n    registerOriginCaller(registry, v13.modules, metaVersion);\n    const extrinsic = convertExtrinsic(registry, v13.extrinsic);\n    const pallets = v13.modules.map((mod) => createPallet(specs, registry, mod, {\n        calls: mod.calls.unwrapOr(null),\n        constants: mod.constants,\n        errors: mod.errors.length ? mod.errors : null,\n        events: mod.events.unwrapOr(null),\n        storage: mod.storage.unwrapOr(null)\n    }));\n    return registry.createTypeUnsafe('MetadataV14', [{\n            extrinsic,\n            lookup: {\n                types: specs.map((type, id) => registry.createTypeUnsafe('PortableType', [{ id, type }]))\n            },\n            pallets\n        }]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}