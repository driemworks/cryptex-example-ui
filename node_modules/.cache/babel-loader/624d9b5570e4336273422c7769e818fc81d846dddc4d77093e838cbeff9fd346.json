{"ast":null,"code":"import { Option } from '@polkadot/types-codec';\nimport { isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClassUnsafe } from './class.js';\nfunction checkInstance(created, matcher) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  const isOk =\n  // full match, all ok\n  u8aEq(u8a, matcher) ||\n  // on a length-prefixed type, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length ||\n  // when the created is empty and matcher is also empty, let it slide...\n  created.isEmpty && matcher.every(v => !v);\n  if (!isOk) {\n    throw new Error(`${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n  }\n}\nfunction checkPedantic(created, _ref) {\n  let [value] = _ref;\n  if (isU8a(value)) {\n    checkInstance(created, value);\n  } else if (isHex(value)) {\n    checkInstance(created, u8aToU8a(value));\n  }\n}\nfunction initType(registry, Type) {\n  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let {\n    blockHash,\n    isFallback,\n    isOptional,\n    isPedantic\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const created = new (isOptional ? Option.with(Type) : Type)(registry, ...params);\n  isPedantic && checkPedantic(created, params);\n  if (blockHash) {\n    created.createdAtHash = createTypeUnsafe(registry, 'BlockHash', [blockHash]);\n  }\n  if (isFallback) {\n    created.isStorageFallback = true;\n  }\n  return created;\n}\nexport function createTypeUnsafe(registry, type) {\n  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let Clazz = null;\n  let firstError = null;\n  try {\n    Clazz = createClassUnsafe(registry, type);\n    return initType(registry, Clazz, params, options);\n  } catch (error) {\n    firstError = new Error(`createType(${type}):: ${error.message}`);\n  }\n  if (Clazz && Clazz.__fallbackType) {\n    try {\n      Clazz = createClassUnsafe(registry, Clazz.__fallbackType);\n      return initType(registry, Clazz, params, options);\n    } catch {\n      // swallow, we will throw the first error again\n    }\n  }\n  throw firstError;\n}","map":{"version":3,"names":["Option","isHex","isU8a","u8aEq","u8aToHex","u8aToU8a","createClassUnsafe","checkInstance","created","matcher","u8a","toU8a","rawType","toRawType","isOk","includes","length","isEmpty","every","v","Error","checkPedantic","_ref","value","initType","registry","Type","params","arguments","undefined","blockHash","isFallback","isOptional","isPedantic","with","createdAtHash","createTypeUnsafe","isStorageFallback","type","options","Clazz","firstError","error","message","__fallbackType"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-create/create/type.js"],"sourcesContent":["import { Option } from '@polkadot/types-codec';\nimport { isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClassUnsafe } from './class.js';\nfunction checkInstance(created, matcher) {\n    const u8a = created.toU8a();\n    const rawType = created.toRawType();\n    const isOk = (\n    // full match, all ok\n    u8aEq(u8a, matcher) ||\n        (\n        // on a length-prefixed type, just check the actual length\n        ['Bytes', 'Text', 'Type'].includes(rawType) &&\n            matcher.length === created.length) ||\n        (\n        // when the created is empty and matcher is also empty, let it slide...\n        created.isEmpty &&\n            matcher.every((v) => !v)));\n    if (!isOk) {\n        throw new Error(`${rawType}:: Decoded input doesn't match input, received ${u8aToHex(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n    }\n}\nfunction checkPedantic(created, [value]) {\n    if (isU8a(value)) {\n        checkInstance(created, value);\n    }\n    else if (isHex(value)) {\n        checkInstance(created, u8aToU8a(value));\n    }\n}\nfunction initType(registry, Type, params = [], { blockHash, isFallback, isOptional, isPedantic } = {}) {\n    const created = new (isOptional\n        ? Option.with(Type)\n        : Type)(registry, ...params);\n    isPedantic && checkPedantic(created, params);\n    if (blockHash) {\n        created.createdAtHash = createTypeUnsafe(registry, 'BlockHash', [blockHash]);\n    }\n    if (isFallback) {\n        created.isStorageFallback = true;\n    }\n    return created;\n}\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n    let Clazz = null;\n    let firstError = null;\n    try {\n        Clazz = createClassUnsafe(registry, type);\n        return initType(registry, Clazz, params, options);\n    }\n    catch (error) {\n        firstError = new Error(`createType(${type}):: ${error.message}`);\n    }\n    if (Clazz && Clazz.__fallbackType) {\n        try {\n            Clazz = createClassUnsafe(registry, Clazz.__fallbackType);\n            return initType(registry, Clazz, params, options);\n        }\n        catch {\n            // swallow, we will throw the first error again\n        }\n    }\n    throw firstError;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}