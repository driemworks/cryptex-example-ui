{"ast":null,"code":"/**\n * @name u8aToNumber\n * @summary Creates a number from a Uint8Array object.\n */\nexport function u8aToNumber(value) {\n  let {\n    isNegative = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const count = value.length;\n  if (isNegative) {\n    let result = 0;\n    switch (count) {\n      case 0:\n        return 0;\n      case 1:\n        result = value[0] ^ 255;\n        break;\n      case 2:\n        result = value[0] + (value[1] << 8) ^ 65535;\n        break;\n      case 3:\n        result = value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215;\n        break;\n      case 4:\n        // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n        // 32-bit, in the case where the top-most bit is set this yields a negative value\n        result = value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295;\n        break;\n      case 5:\n        result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 0xff) * 4294967296;\n        break;\n      case 6:\n        result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296;\n        break;\n      default:\n        throw new Error('Value more than 48-bits cannot be reliably converted');\n    }\n    return result * -1 - 1;\n  }\n  switch (count) {\n    case 0:\n      return 0;\n    case 1:\n      return value[0];\n    case 2:\n      return value[0] + (value[1] << 8);\n    case 3:\n      return value[0] + (value[1] << 8) + (value[2] << 16);\n    case 4:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216;\n    case 5:\n      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216;\n    case 6:\n      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216;\n    default:\n      throw new Error('Value more than 48-bits cannot be reliably converted');\n  }\n}","map":{"version":3,"names":["u8aToNumber","value","isNegative","arguments","length","undefined","count","result","Error"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/util/u8a/toNumber.js"],"sourcesContent":["/**\n * @name u8aToNumber\n * @summary Creates a number from a Uint8Array object.\n */\nexport function u8aToNumber(value, { isNegative = false } = {}) {\n    const count = value.length;\n    if (isNegative) {\n        let result = 0;\n        switch (count) {\n            case 0:\n                return 0;\n            case 1:\n                result = value[0] ^ 255;\n                break;\n            case 2:\n                result = (value[0] + (value[1] << 8)) ^ 65535;\n                break;\n            case 3:\n                result = (value[0] + (value[1] << 8) + (value[2] << 16)) ^ 16777215;\n                break;\n            case 4:\n                // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n                // 32-bit, in the case where the top-most bit is set this yields a negative value\n                result = (value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295;\n                break;\n            case 5:\n                result = ((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + ((value[4] ^ 0xff) * 4294967296);\n                break;\n            case 6:\n                result = ((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + (((value[4] + (value[5] << 8)) ^ 65535) * 4294967296);\n                break;\n            default:\n                throw new Error('Value more than 48-bits cannot be reliably converted');\n        }\n        return (result * -1) - 1;\n    }\n    switch (count) {\n        case 0:\n            return 0;\n        case 1:\n            return value[0];\n        case 2:\n            return value[0] + (value[1] << 8);\n        case 3:\n            return value[0] + (value[1] << 8) + (value[2] << 16);\n        case 4:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216);\n        case 5:\n            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8)) * 16777216);\n        case 6:\n            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);\n        default:\n            throw new Error('Value more than 48-bits cannot be reliably converted');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}