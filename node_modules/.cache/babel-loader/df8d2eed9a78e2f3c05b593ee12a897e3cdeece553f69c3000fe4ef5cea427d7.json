{"ast":null,"code":"import { Raw } from '@polkadot/types-codec';\nimport { compactAddLength, compactStripLength, isUndefined, objectSpread, stringCamelCase, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getSiName } from '../../util/index.js';\nimport { getHasher } from './getHasher.js';\nexport const NO_RAW_ARGS = {\n  args: [],\n  hashers: [],\n  keys: []\n};\n/** @internal */\nfunction filterDefined(a) {\n  return !isUndefined(a);\n}\n/** @internal */\nfunction assertArgs(_ref, _ref2) {\n  let {\n    method,\n    section\n  } = _ref;\n  let {\n    args,\n    keys\n  } = _ref2;\n  if (!Array.isArray(args)) {\n    throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments`);\n  } else if (args.filter(filterDefined).length !== keys.length) {\n    throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`);\n  }\n}\n/** @internal */\nexport function createKeyRawParts(registry, itemFn, _ref3) {\n  let {\n    args,\n    hashers,\n    keys\n  } = _ref3;\n  const extra = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    extra[i] = getHasher(hashers[i])(registry.createTypeUnsafe(registry.createLookupType(keys[i]), [args[i]]).toU8a());\n  }\n  return [[xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128)], extra];\n}\n/** @internal */\nexport function createKeyInspect(registry, itemFn, args) {\n  assertArgs(itemFn, args);\n  const {\n    meta\n  } = itemFn;\n  const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n  let types = [];\n  if (meta.type.isMap) {\n    const {\n      hashers,\n      key\n    } = meta.type.asMap;\n    types = hashers.length === 1 ? [`${hashers[0].type}(${getSiName(registry.lookup, key)})`] : registry.lookup.getSiType(key).def.asTuple.map((k, i) => `${hashers[i].type}(${getSiName(registry.lookup, k)})`);\n  }\n  const names = ['module', 'method'].concat(...args.args.map((_, i) => types[i]));\n  return {\n    inner: prefix.concat(...extra).map((v, i) => ({\n      name: names[i],\n      outer: [v]\n    }))\n  };\n}\n/** @internal */\nexport function createKeyRaw(registry, itemFn, args) {\n  const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n  return u8aConcat(...prefix, ...extra);\n}\n/** @internal */\nfunction createKey(registry, itemFn, args) {\n  assertArgs(itemFn, args);\n  // always add the length prefix (underlying it is Bytes)\n  return compactAddLength(createKeyRaw(registry, itemFn, args));\n}\n/** @internal */\nfunction createStorageInspect(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  return function () {\n    if (type.isPlain) {\n      return options.skipHashing ? {\n        inner: [],\n        name: 'wellKnown',\n        outer: [u8aToU8a(options.key)]\n      } : createKeyInspect(registry, itemFn, NO_RAW_ARGS);\n    }\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return hashers.length === 1 ? createKeyInspect(registry, itemFn, {\n      args,\n      hashers,\n      keys: [key]\n    }) : createKeyInspect(registry, itemFn, {\n      args,\n      hashers,\n      keys: registry.lookup.getSiType(key).def.asTuple\n    });\n  };\n}\n/** @internal */\nfunction createStorageFn(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  let cacheKey = null;\n  // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n  return function () {\n    if (type.isPlain) {\n      if (!cacheKey) {\n        cacheKey = options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, NO_RAW_ARGS);\n      }\n      return cacheKey;\n    }\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return hashers.length === 1 ? createKey(registry, itemFn, {\n      args,\n      hashers,\n      keys: [key]\n    }) : createKey(registry, itemFn, {\n      args,\n      hashers,\n      keys: registry.lookup.getSiType(key).def.asTuple\n    });\n  };\n}\n/** @internal */\nfunction createWithMeta(registry, itemFn, options) {\n  const {\n    meta,\n    method,\n    prefix,\n    section\n  } = itemFn;\n  const storageFn = createStorageFn(registry, itemFn, options);\n  storageFn.inspect = createStorageInspect(registry, itemFn, options);\n  storageFn.meta = meta;\n  storageFn.method = stringCamelCase(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section;\n  // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n  storageFn.toJSON = () => objectSpread({\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  }, meta.toJSON());\n  return storageFn;\n}\n/** @internal */\nfunction extendHeadMeta(registry, _ref4, _ref5, iterFn) {\n  let {\n    meta: {\n      docs,\n      name,\n      type\n    },\n    section\n  } = _ref4;\n  let {\n    method\n  } = _ref5;\n  // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n  const meta = registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n    docs,\n    fallback: registry.createTypeUnsafe('Bytes', []),\n    modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', [1]),\n    name,\n    type: registry.createTypeUnsafe('StorageEntryTypeLatest', [type.asMap.key, 0])\n  }]);\n  iterFn.meta = meta;\n  const fn = function () {\n    return registry.createTypeUnsafe('StorageKey', [iterFn(...arguments), {\n      method,\n      section\n    }]);\n  };\n  fn.meta = meta;\n  return fn;\n}\n/** @internal */\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    if (args.length && (type.isPlain || args.length >= type.asMap.hashers.length)) {\n      throw new Error(`Iteration of ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n    }\n    if (args.length) {\n      if (type.isMap) {\n        const {\n          hashers,\n          key\n        } = type.asMap;\n        const keysVec = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;\n        return new Raw(registry, createKeyRaw(registry, itemFn, {\n          args,\n          hashers: hashers.slice(0, args.length),\n          keys: keysVec.slice(0, args.length)\n        }));\n      }\n    }\n    return new Raw(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));\n  });\n  return storageFn;\n}\n/** @internal */\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const storageFn = createWithMeta(registry, itemFn, options);\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n  storageFn.keyPrefix = function () {\n    return storageFn.iterKey && storageFn.iterKey(...arguments) || compactStripLength(storageFn())[1];\n  };\n  return storageFn;\n}","map":{"version":3,"names":["Raw","compactAddLength","compactStripLength","isUndefined","objectSpread","stringCamelCase","u8aConcat","u8aToU8a","xxhashAsU8a","getSiName","getHasher","NO_RAW_ARGS","args","hashers","keys","filterDefined","a","assertArgs","_ref","_ref2","method","section","Array","isArray","Error","length","filter","join","createKeyRawParts","registry","itemFn","_ref3","extra","i","createTypeUnsafe","createLookupType","toU8a","prefix","createKeyInspect","meta","types","type","isMap","key","asMap","lookup","getSiType","def","asTuple","map","k","names","concat","_","inner","v","name","outer","createKeyRaw","createKey","createStorageInspect","options","isPlain","skipHashing","_len","arguments","_key","createStorageFn","cacheKey","_len2","_key2","createWithMeta","storageFn","inspect","toJSON","storage","extendHeadMeta","_ref4","_ref5","iterFn","docs","fallback","modifier","fn","extendPrefixedMap","iterKey","_len3","_key3","keysVec","slice","createFunction","keyPrefix"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/metadata/decorate/storage/createFunction.js"],"sourcesContent":["import { Raw } from '@polkadot/types-codec';\nimport { compactAddLength, compactStripLength, isUndefined, objectSpread, stringCamelCase, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getSiName } from '../../util/index.js';\nimport { getHasher } from './getHasher.js';\nexport const NO_RAW_ARGS = {\n    args: [],\n    hashers: [],\n    keys: []\n};\n/** @internal */\nfunction filterDefined(a) {\n    return !isUndefined(a);\n}\n/** @internal */\nfunction assertArgs({ method, section }, { args, keys }) {\n    if (!Array.isArray(args)) {\n        throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments`);\n    }\n    else if (args.filter(filterDefined).length !== keys.length) {\n        throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`);\n    }\n}\n/** @internal */\nexport function createKeyRawParts(registry, itemFn, { args, hashers, keys }) {\n    const extra = new Array(keys.length);\n    for (let i = 0; i < keys.length; i++) {\n        extra[i] = getHasher(hashers[i])(registry.createTypeUnsafe(registry.createLookupType(keys[i]), [args[i]]).toU8a());\n    }\n    return [\n        [\n            xxhashAsU8a(itemFn.prefix, 128),\n            xxhashAsU8a(itemFn.method, 128)\n        ],\n        extra\n    ];\n}\n/** @internal */\nexport function createKeyInspect(registry, itemFn, args) {\n    assertArgs(itemFn, args);\n    const { meta } = itemFn;\n    const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n    let types = [];\n    if (meta.type.isMap) {\n        const { hashers, key } = meta.type.asMap;\n        types = hashers.length === 1\n            ? [`${hashers[0].type}(${getSiName(registry.lookup, key)})`]\n            : registry.lookup.getSiType(key).def.asTuple.map((k, i) => `${hashers[i].type}(${getSiName(registry.lookup, k)})`);\n    }\n    const names = ['module', 'method'].concat(...args.args.map((_, i) => types[i]));\n    return {\n        inner: prefix\n            .concat(...extra)\n            .map((v, i) => ({ name: names[i], outer: [v] }))\n    };\n}\n/** @internal */\nexport function createKeyRaw(registry, itemFn, args) {\n    const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n    return u8aConcat(...prefix, ...extra);\n}\n/** @internal */\nfunction createKey(registry, itemFn, args) {\n    assertArgs(itemFn, args);\n    // always add the length prefix (underlying it is Bytes)\n    return compactAddLength(createKeyRaw(registry, itemFn, args));\n}\n/** @internal */\nfunction createStorageInspect(registry, itemFn, options) {\n    const { meta: { type } } = itemFn;\n    return (...args) => {\n        if (type.isPlain) {\n            return options.skipHashing\n                ? { inner: [], name: 'wellKnown', outer: [u8aToU8a(options.key)] }\n                : createKeyInspect(registry, itemFn, NO_RAW_ARGS);\n        }\n        const { hashers, key } = type.asMap;\n        return hashers.length === 1\n            ? createKeyInspect(registry, itemFn, { args, hashers, keys: [key] })\n            : createKeyInspect(registry, itemFn, { args, hashers, keys: registry.lookup.getSiType(key).def.asTuple });\n    };\n}\n/** @internal */\nfunction createStorageFn(registry, itemFn, options) {\n    const { meta: { type } } = itemFn;\n    let cacheKey = null;\n    // Can only have zero or one argument:\n    //   - storage.system.account(address)\n    //   - storage.timestamp.blockPeriod()\n    // For higher-map queries the params are passed in as an tuple, [key1, key2]\n    return (...args) => {\n        if (type.isPlain) {\n            if (!cacheKey) {\n                cacheKey = options.skipHashing\n                    ? compactAddLength(u8aToU8a(options.key))\n                    : createKey(registry, itemFn, NO_RAW_ARGS);\n            }\n            return cacheKey;\n        }\n        const { hashers, key } = type.asMap;\n        return hashers.length === 1\n            ? createKey(registry, itemFn, { args, hashers, keys: [key] })\n            : createKey(registry, itemFn, { args, hashers, keys: registry.lookup.getSiType(key).def.asTuple });\n    };\n}\n/** @internal */\nfunction createWithMeta(registry, itemFn, options) {\n    const { meta, method, prefix, section } = itemFn;\n    const storageFn = createStorageFn(registry, itemFn, options);\n    storageFn.inspect = createStorageInspect(registry, itemFn, options);\n    storageFn.meta = meta;\n    storageFn.method = stringCamelCase(method);\n    storageFn.prefix = prefix;\n    storageFn.section = section;\n    // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n    // instances (e.g. collective) will not work since it is only matched on param meta\n    storageFn.toJSON = () => objectSpread({ storage: { method, prefix, section } }, meta.toJSON());\n    return storageFn;\n}\n/** @internal */\nfunction extendHeadMeta(registry, { meta: { docs, name, type }, section }, { method }, iterFn) {\n    // metadata with a fallback value using the type of the key, the normal\n    // meta fallback only applies to actual entry values, create one for head\n    const meta = registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n            docs,\n            fallback: registry.createTypeUnsafe('Bytes', []),\n            modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', [1]),\n            name,\n            type: registry.createTypeUnsafe('StorageEntryTypeLatest', [type.asMap.key, 0])\n        }]);\n    iterFn.meta = meta;\n    const fn = (...args) => registry.createTypeUnsafe('StorageKey', [iterFn(...args), { method, section }]);\n    fn.meta = meta;\n    return fn;\n}\n/** @internal */\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n    const { meta: { type }, method, section } = itemFn;\n    storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n        if (args.length && (type.isPlain || (args.length >= type.asMap.hashers.length))) {\n            throw new Error(`Iteration of ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n        }\n        if (args.length) {\n            if (type.isMap) {\n                const { hashers, key } = type.asMap;\n                const keysVec = hashers.length === 1\n                    ? [key]\n                    : registry.lookup.getSiType(key).def.asTuple;\n                return new Raw(registry, createKeyRaw(registry, itemFn, { args, hashers: hashers.slice(0, args.length), keys: keysVec.slice(0, args.length) }));\n            }\n        }\n        return new Raw(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));\n    });\n    return storageFn;\n}\n/** @internal */\nexport function createFunction(registry, itemFn, options) {\n    const { meta: { type } } = itemFn;\n    const storageFn = createWithMeta(registry, itemFn, options);\n    if (type.isMap) {\n        extendPrefixedMap(registry, itemFn, storageFn);\n    }\n    storageFn.keyPrefix = (...args) => (storageFn.iterKey && storageFn.iterKey(...args)) ||\n        compactStripLength(storageFn())[1];\n    return storageFn;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}