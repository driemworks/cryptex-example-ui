{"ast":null,"code":"var _Tuple_Types;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { isFunction, isHex, isString, isU8a, stringify, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8a, mapToTypeMap, typeToConstructor } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n  return d;\n}\n/** @internal */\nfunction decodeTuple(registry, result, value, Classes) {\n  if (Array.isArray(value)) {\n    const Types = Classes[0];\n    for (let i = 0; i < Types.length; i++) {\n      try {\n        const entry = value?.[i];\n        result[i] = entry instanceof Types[i] ? entry : new Types[i](registry, entry);\n      } catch (error) {\n        throw new Error(`Tuple: failed on ${i}:: ${error.message}`);\n      }\n    }\n    return [result, 0];\n  } else if (isHex(value)) {\n    return decodeU8a(registry, result, u8aToU8a(value), Classes);\n  } else if (!value || !result.length) {\n    const Types = Classes[0];\n    for (let i = 0; i < Types.length; i++) {\n      result[i] = new Types[i](registry);\n    }\n    return [result, 0];\n  }\n  throw new Error(`Expected array input to Tuple decoding, found ${typeof value}: ${stringify(value)}`);\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\nexport class Tuple extends AbstractArray {\n  constructor(registry, Types, value) {\n    let {\n      definition,\n      setDefinition = noopSetDefinition\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const Classes = definition || setDefinition(Array.isArray(Types) ? [Types.map(t => typeToConstructor(registry, t)), []] : isFunction(Types) || isString(Types) ? [[typeToConstructor(registry, Types)], []] : mapToTypeMap(registry, Types));\n    super(registry, Classes[0].length);\n    _Tuple_Types.set(this, void 0);\n    this.initialU8aLength = (isU8a(value) ? decodeU8a(registry, this, value, Classes) : decodeTuple(registry, this, value, Classes))[1];\n    __classPrivateFieldSet(this, _Tuple_Types, Classes, \"f\");\n  }\n  static with(Types) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Tuple {\n      constructor(registry, value) {\n        super(registry, Types, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let total = 0;\n    for (let i = 0; i < this.length; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description The types definition of the tuple\n   */\n  get Types() {\n    return __classPrivateFieldGet(this, _Tuple_Types, \"f\")[1].length ? __classPrivateFieldGet(this, _Tuple_Types, \"f\")[1] : __classPrivateFieldGet(this, _Tuple_Types, \"f\")[0].map(T => new T(this.registry).toRawType());\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner()\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    const types = __classPrivateFieldGet(this, _Tuple_Types, \"f\")[0].map(T => this.registry.getClassName(T) || new T(this.registry).toRawType());\n    return `(${types.join(',')})`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    // Overwrite the default toString representation of Array.\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return u8aConcatStrict(this.toU8aInner(isBare));\n  }\n}\n_Tuple_Types = new WeakMap();","map":{"version":3,"names":["_Tuple_Types","__classPrivateFieldGet","__classPrivateFieldSet","isFunction","isHex","isString","isU8a","stringify","u8aConcatStrict","u8aToU8a","AbstractArray","decodeU8a","mapToTypeMap","typeToConstructor","noopSetDefinition","d","decodeTuple","registry","result","value","Classes","Array","isArray","Types","i","length","entry","error","Error","message","Tuple","constructor","definition","setDefinition","arguments","undefined","map","t","set","initialU8aLength","with","encodedLength","total","T","toRawType","inspect","inner","inspectInner","types","getClassName","join","toString","toJSON","toU8a","isBare","toU8aInner","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/base/Tuple.js"],"sourcesContent":["var _Tuple_Types;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { isFunction, isHex, isString, isU8a, stringify, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8a, mapToTypeMap, typeToConstructor } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n    return d;\n}\n/** @internal */\nfunction decodeTuple(registry, result, value, Classes) {\n    if (Array.isArray(value)) {\n        const Types = Classes[0];\n        for (let i = 0; i < Types.length; i++) {\n            try {\n                const entry = value?.[i];\n                result[i] = entry instanceof Types[i]\n                    ? entry\n                    : new Types[i](registry, entry);\n            }\n            catch (error) {\n                throw new Error(`Tuple: failed on ${i}:: ${error.message}`);\n            }\n        }\n        return [result, 0];\n    }\n    else if (isHex(value)) {\n        return decodeU8a(registry, result, u8aToU8a(value), Classes);\n    }\n    else if (!value || !result.length) {\n        const Types = Classes[0];\n        for (let i = 0; i < Types.length; i++) {\n            result[i] = new Types[i](registry);\n        }\n        return [result, 0];\n    }\n    throw new Error(`Expected array input to Tuple decoding, found ${typeof value}: ${stringify(value)}`);\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\nexport class Tuple extends AbstractArray {\n    constructor(registry, Types, value, { definition, setDefinition = noopSetDefinition } = {}) {\n        const Classes = definition || setDefinition(Array.isArray(Types)\n            ? [Types.map((t) => typeToConstructor(registry, t)), []]\n            : isFunction(Types) || isString(Types)\n                ? [[typeToConstructor(registry, Types)], []]\n                : mapToTypeMap(registry, Types));\n        super(registry, Classes[0].length);\n        _Tuple_Types.set(this, void 0);\n        this.initialU8aLength = (isU8a(value)\n            ? decodeU8a(registry, this, value, Classes)\n            : decodeTuple(registry, this, value, Classes))[1];\n        __classPrivateFieldSet(this, _Tuple_Types, Classes, \"f\");\n    }\n    static with(Types) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => definition = d;\n        return class extends Tuple {\n            constructor(registry, value) {\n                super(registry, Types, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (let i = 0; i < this.length; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description The types definition of the tuple\n     */\n    get Types() {\n        return __classPrivateFieldGet(this, _Tuple_Types, \"f\")[1].length\n            ? __classPrivateFieldGet(this, _Tuple_Types, \"f\")[1]\n            : __classPrivateFieldGet(this, _Tuple_Types, \"f\")[0].map((T) => new T(this.registry).toRawType());\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner()\n        };\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        const types = __classPrivateFieldGet(this, _Tuple_Types, \"f\")[0].map((T) => this.registry.getClassName(T) || new T(this.registry).toRawType());\n        return `(${types.join(',')})`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        // Overwrite the default toString representation of Array.\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return u8aConcatStrict(this.toU8aInner(isBare));\n    }\n}\n_Tuple_Types = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}