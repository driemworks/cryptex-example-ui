{"ast":null,"code":"var _Init_instances, _Init_atLast, _Init_healthTimer, _Init_registries, _Init_updateSub, _Init_waitingRegistries, _Init_onProviderConnect, _Init_onProviderDisconnect, _Init_onProviderError;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst l = logger('api/init');\nfunction textToString(t) {\n  return t.toString();\n}\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    _Init_instances.add(this);\n    _Init_atLast.set(this, null);\n    _Init_healthTimer.set(this, null);\n    _Init_registries.set(this, []);\n    _Init_updateSub.set(this, null);\n    _Init_waitingRegistries.set(this, {});\n    // all injected types added to the registry for overrides\n    this.registry.setKnownTypes(options);\n    // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      __classPrivateFieldSet(this, _Init_registries, __classPrivateFieldGet(options.source, _Init_registries, \"f\"), \"f\");\n    }\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n    this._rx.signer = options.signer;\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n    this._rpcCore.setResolveBlockHash(blockNumber => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', () => __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderDisconnect).call(this));\n      this._rpcCore.provider.on('error', e => __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderError).call(this, e));\n      this._rpcCore.provider.on('connected', () => __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderConnect).call(this));\n    } else if (!this._options.noInitWarn) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    }\n    // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderConnect).call(this);\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.clearCache();\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName));\n    // for bundled types, pull through the aliases defined\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n    registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions));\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n  _getDefaultRegistry() {\n    return assertReturn(__classPrivateFieldGet(this, _Init_registries, \"f\").find(_ref => {\n      let {\n        isDefault\n      } = _ref;\n      return isDefault;\n    }), 'Initialization error, cannot find the default registry');\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n  async at(blockHash, knownVersion) {\n    const u8aHash = u8aToU8a(blockHash);\n    const u8aHex = u8aToHex(u8aHash);\n    const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n    if (!__classPrivateFieldGet(this, _Init_atLast, \"f\") || __classPrivateFieldGet(this, _Init_atLast, \"f\")[0] !== u8aHex) {\n      // always create a new decoration - since we are pointing to a specific hash, this\n      // means that all queries needs to use that hash (not a previous one already existing)\n      __classPrivateFieldSet(this, _Init_atLast, [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi], \"f\");\n    }\n    return __classPrivateFieldGet(this, _Init_atLast, \"f\")[1];\n  }\n  async _createBlockRegistry(blockHash, header, version) {\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n    this._initRegistry(registry, this._runtimeChain, version, metadata);\n    // add our new registry\n    const result = {\n      counter: 0,\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      runtimeVersion: version\n    };\n    __classPrivateFieldGet(this, _Init_registries, \"f\").push(result);\n    return result;\n  }\n  _cacheBlockRegistryProgress(key, creator) {\n    // look for waiting resolves\n    let waiting = __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key];\n    if (isUndefined(waiting)) {\n      // nothing waiting, construct new\n      waiting = __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key] = new Promise((resolve, reject) => {\n        creator().then(registry => {\n          delete __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key];\n          resolve(registry);\n        }).catch(error => {\n          delete __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key];\n          reject(error);\n        });\n      });\n    }\n    return waiting;\n  }\n  _getBlockRegistryViaVersion(blockHash, version) {\n    if (version) {\n      // check for pre-existing registries. We also check specName, e.g. it\n      // could be changed like in Westmint with upgrade from shell -> westmint\n      const existingViaVersion = __classPrivateFieldGet(this, _Init_registries, \"f\").find(_ref2 => {\n        let {\n          runtimeVersion: {\n            specName,\n            specVersion\n          }\n        } = _ref2;\n        return specName.eq(version.specName) && specVersion.eq(version.specVersion);\n      });\n      if (existingViaVersion) {\n        existingViaVersion.counter++;\n        existingViaVersion.lastBlockHash = blockHash;\n        return existingViaVersion;\n      }\n    }\n    return null;\n  }\n  async _getBlockRegistryViaHash(blockHash) {\n    // ensure we have everything required\n    if (!this._genesisHash || !this._runtimeVersion) {\n      throw new Error('Cannot retrieve data on an uninitialized chain');\n    }\n    // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n    if (header.parentHash.isEmpty) {\n      throw new Error('Unable to retrieve header and parent from supplied hash');\n    }\n    // get the runtime version, either on-chain or via an known upgrade history\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      apis: firstVersion.apis,\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n    return (\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, version) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)))\n    );\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n  async getBlockRegistry(blockHash, knownVersion) {\n    return (\n      // try to find via blockHash\n      __classPrivateFieldGet(this, _Init_registries, \"f\").find(_ref3 => {\n        let {\n          lastBlockHash\n        } = _ref3;\n        return lastBlockHash && u8aEq(lastBlockHash, blockHash);\n      }) ||\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, knownVersion) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)))\n    );\n  }\n  async _loadMeta() {\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    }\n    this._unsubscribeUpdates();\n    // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n    [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n    const sections = Object.keys(source.rpc);\n    const rpcs = [];\n    for (let s = 0; s < sections.length; s++) {\n      const section = sections[s];\n      const methods = Object.keys(source.rpc[section]);\n      for (let m = 0; m < methods.length; m++) {\n        rpcs.push(`${section}_${methods[m]}`);\n      }\n    }\n    this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n  // subscribe to metadata updates, inject the types on changes\n  _subscribeUpdates() {\n    if (__classPrivateFieldGet(this, _Init_updateSub, \"f\") || !this.hasSubscriptions) {\n      return;\n    }\n    __classPrivateFieldSet(this, _Init_updateSub, this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version =>\n    // only retrieve the metadata when the on-chain version has been changed\n    this._runtimeVersion?.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n      l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n      this._runtimeMetadata = metadata;\n      this._runtimeVersion = version;\n      this._rx.runtimeVersion = version;\n      // update the default registry version\n      const thisRegistry = this._getDefaultRegistry();\n      // setup the data as per the current versions\n      thisRegistry.metadata = metadata;\n      thisRegistry.runtimeVersion = version;\n      this._initRegistry(this.registry, this._runtimeChain, version, metadata);\n      this._injectMetadata(thisRegistry, true);\n      return true;\n    })))).subscribe(), \"f\");\n  }\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]);\n    // set our chain version & genesisHash as returned\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion;\n    // retrieve metadata, either from chain  or as pass-in via options\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata()));\n    // initializes the registry & RPC\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n    this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n    this._subscribeUpdates();\n    // setup the initial registry, when we have none\n    if (!__classPrivateFieldGet(this, _Init_registries, \"f\").length) {\n      __classPrivateFieldGet(this, _Init_registries, \"f\").push({\n        counter: 0,\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        runtimeVersion\n      });\n    }\n    // get unique types & validate\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n    this._injectMetadata(this._getDefaultRegistry(), true);\n    // derive is last, since it uses the decorated rx\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n  _subscribeHealth() {\n    this._unsubscribeHealth();\n    // Only enable the health keepalive on WS, not needed on HTTP\n    __classPrivateFieldSet(this, _Init_healthTimer, this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health.raw()).catch(() => undefined);\n    }, KEEPALIVE_INTERVAL) : null, \"f\");\n  }\n  _unsubscribeHealth() {\n    if (__classPrivateFieldGet(this, _Init_healthTimer, \"f\")) {\n      clearInterval(__classPrivateFieldGet(this, _Init_healthTimer, \"f\"));\n      __classPrivateFieldSet(this, _Init_healthTimer, null, \"f\");\n    }\n  }\n  _unsubscribeUpdates() {\n    if (__classPrivateFieldGet(this, _Init_updateSub, \"f\")) {\n      __classPrivateFieldGet(this, _Init_updateSub, \"f\").unsubscribe();\n      __classPrivateFieldSet(this, _Init_updateSub, null, \"f\");\n    }\n  }\n  _unsubscribe() {\n    this._unsubscribeHealth();\n    this._unsubscribeUpdates();\n  }\n}\n_Init_atLast = new WeakMap(), _Init_healthTimer = new WeakMap(), _Init_registries = new WeakMap(), _Init_updateSub = new WeakMap(), _Init_waitingRegistries = new WeakMap(), _Init_instances = new WeakSet(), _Init_onProviderConnect = async function _Init_onProviderConnect() {\n  this._isConnected.next(true);\n  this.emit('connected');\n  try {\n    const cryptoReady = this._options.initWasm === false ? true : await cryptoWaitReady();\n    const hasMeta = await this._loadMeta();\n    this._subscribeHealth();\n    if (hasMeta && !this._isReady && cryptoReady) {\n      this._isReady = true;\n      this.emit('ready', this);\n    }\n  } catch (_error) {\n    const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n    l.error(error);\n    this.emit('error', error);\n  }\n}, _Init_onProviderDisconnect = function _Init_onProviderDisconnect() {\n  this._isConnected.next(false);\n  this._unsubscribe();\n  this.emit('disconnected');\n}, _Init_onProviderError = function _Init_onProviderError(error) {\n  this.emit('error', error);\n};","map":{"version":3,"names":["_Init_instances","_Init_atLast","_Init_healthTimer","_Init_registries","_Init_updateSub","_Init_waitingRegistries","_Init_onProviderConnect","_Init_onProviderDisconnect","_Init_onProviderError","__classPrivateFieldGet","__classPrivateFieldSet","firstValueFrom","map","of","switchMap","Metadata","TypeRegistry","getSpecAlias","getSpecExtensions","getSpecHasher","getSpecRpc","getSpecTypes","getUpgradeVersion","assertReturn","BN_ZERO","isUndefined","logger","objectSpread","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","Decorate","KEEPALIVE_INTERVAL","WITH_VERSION_SHORTCUT","l","textToString","t","toString","Init","constructor","options","type","decorateMethod","add","set","registry","setKnownTypes","source","registerTypes","types","_rpc","_decorateRpc","_rpcCore","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","blockHash","getBlockRegistry","setResolveBlockHash","blockNumber","chain","getBlockHash","hasSubscriptions","provider","on","call","e","_options","noInitWarn","warn","isConnected","_initRegistry","version","metadata","chainProps","clearCache","setChainProperties","getChainProperties","register","specName","specVersion","setHasher","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","_getDefaultRegistry","find","_ref","isDefault","at","knownVersion","u8aHash","u8aHex","_createDecorated","decoratedApi","_createBlockRegistry","header","state","getMetadata","raw","parentHash","_runtimeChain","result","counter","lastBlockHash","runtimeVersion","push","_cacheBlockRegistryProgress","key","creator","waiting","Promise","resolve","reject","then","catch","error","_getBlockRegistryViaVersion","existingViaVersion","_ref2","eq","_getBlockRegistryViaHash","_genesisHash","_runtimeVersion","Error","createType","number","getHeader","isEmpty","firstVersion","lastVersion","apis","getRuntimeVersion","toHex","_ref3","_loadMeta","_isReady","_unsubscribeUpdates","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","sections","Object","keys","rpcs","s","length","section","methods","m","_filterRpc","genesisHash","runtimeMetadata","_subscribeUpdates","subscribeRuntimeVersion","pipe","log","transactionVersion","thisRegistry","_injectMetadata","subscribe","optMetadata","rpcMethods","chainMetadata","all","system","properties","metadataKey","getUniqTypes","throwOnUnknown","asLatest","extrinsic","toNumber","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive","_subscribeHealth","_unsubscribeHealth","setInterval","health","clearInterval","unsubscribe","_unsubscribe","WeakMap","WeakSet","_isConnected","next","emit","cryptoReady","initWasm","hasMeta","_error","message"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/api/base/Init.js"],"sourcesContent":["var _Init_instances, _Init_atLast, _Init_healthTimer, _Init_registries, _Init_updateSub, _Init_waitingRegistries, _Init_onProviderConnect, _Init_onProviderDisconnect, _Init_onProviderError;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst l = logger('api/init');\nfunction textToString(t) {\n    return t.toString();\n}\nexport class Init extends Decorate {\n    constructor(options, type, decorateMethod) {\n        super(options, type, decorateMethod);\n        _Init_instances.add(this);\n        _Init_atLast.set(this, null);\n        _Init_healthTimer.set(this, null);\n        _Init_registries.set(this, []);\n        _Init_updateSub.set(this, null);\n        _Init_waitingRegistries.set(this, {});\n        // all injected types added to the registry for overrides\n        this.registry.setKnownTypes(options);\n        // We only register the types (global) if this is not a cloned instance.\n        // Do right up-front, so we get in the user types before we are actually\n        // doing anything on-chain, this ensures we have the overrides in-place\n        if (!options.source) {\n            this.registerTypes(options.types);\n        }\n        else {\n            __classPrivateFieldSet(this, _Init_registries, __classPrivateFieldGet(options.source, _Init_registries, \"f\"), \"f\");\n        }\n        this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n        this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n        if (this.supportMulti) {\n            this._queryMulti = this._decorateMulti(this._decorateMethod);\n            this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n        }\n        this._rx.signer = options.signer;\n        this._rpcCore.setRegistrySwap((blockHash) => this.getBlockRegistry(blockHash));\n        this._rpcCore.setResolveBlockHash((blockNumber) => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n        if (this.hasSubscriptions) {\n            this._rpcCore.provider.on('disconnected', () => __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderDisconnect).call(this));\n            this._rpcCore.provider.on('error', (e) => __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderError).call(this, e));\n            this._rpcCore.provider.on('connected', () => __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderConnect).call(this));\n        }\n        else if (!this._options.noInitWarn) {\n            l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n        }\n        // If the provider was instantiated earlier, and has already emitted a\n        // 'connected' event, then the `on('connected')` won't fire anymore. To\n        // cater for this case, we call manually `this._onProviderConnect`.\n        if (this._rpcCore.provider.isConnected) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            __classPrivateFieldGet(this, _Init_instances, \"m\", _Init_onProviderConnect).call(this);\n        }\n    }\n    /**\n     * @description Decorates a registry based on the runtime version\n     */\n    _initRegistry(registry, chain, version, metadata, chainProps) {\n        registry.clearCache();\n        registry.setChainProperties(chainProps || this.registry.getChainProperties());\n        registry.setKnownTypes(this._options);\n        registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n        registry.setHasher(getSpecHasher(registry, chain, version.specName));\n        // for bundled types, pull through the aliases defined\n        if (registry.knownTypes.typesBundle) {\n            registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n        }\n        registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions));\n    }\n    /**\n     * @description Returns the default versioned registry\n     */\n    _getDefaultRegistry() {\n        return assertReturn(__classPrivateFieldGet(this, _Init_registries, \"f\").find(({ isDefault }) => isDefault), 'Initialization error, cannot find the default registry');\n    }\n    /**\n     * @description Returns a decorated API instance at a specific point in time\n     */\n    async at(blockHash, knownVersion) {\n        const u8aHash = u8aToU8a(blockHash);\n        const u8aHex = u8aToHex(u8aHash);\n        const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n        if (!__classPrivateFieldGet(this, _Init_atLast, \"f\") || __classPrivateFieldGet(this, _Init_atLast, \"f\")[0] !== u8aHex) {\n            // always create a new decoration - since we are pointing to a specific hash, this\n            // means that all queries needs to use that hash (not a previous one already existing)\n            __classPrivateFieldSet(this, _Init_atLast, [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi], \"f\");\n        }\n        return __classPrivateFieldGet(this, _Init_atLast, \"f\")[1];\n    }\n    async _createBlockRegistry(blockHash, header, version) {\n        const registry = new TypeRegistry(blockHash);\n        const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n        this._initRegistry(registry, this._runtimeChain, version, metadata);\n        // add our new registry\n        const result = { counter: 0, lastBlockHash: blockHash, metadata, registry, runtimeVersion: version };\n        __classPrivateFieldGet(this, _Init_registries, \"f\").push(result);\n        return result;\n    }\n    _cacheBlockRegistryProgress(key, creator) {\n        // look for waiting resolves\n        let waiting = __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key];\n        if (isUndefined(waiting)) {\n            // nothing waiting, construct new\n            waiting = __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key] = new Promise((resolve, reject) => {\n                creator()\n                    .then((registry) => {\n                    delete __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key];\n                    resolve(registry);\n                })\n                    .catch((error) => {\n                    delete __classPrivateFieldGet(this, _Init_waitingRegistries, \"f\")[key];\n                    reject(error);\n                });\n            });\n        }\n        return waiting;\n    }\n    _getBlockRegistryViaVersion(blockHash, version) {\n        if (version) {\n            // check for pre-existing registries. We also check specName, e.g. it\n            // could be changed like in Westmint with upgrade from shell -> westmint\n            const existingViaVersion = __classPrivateFieldGet(this, _Init_registries, \"f\").find(({ runtimeVersion: { specName, specVersion } }) => specName.eq(version.specName) &&\n                specVersion.eq(version.specVersion));\n            if (existingViaVersion) {\n                existingViaVersion.counter++;\n                existingViaVersion.lastBlockHash = blockHash;\n                return existingViaVersion;\n            }\n        }\n        return null;\n    }\n    async _getBlockRegistryViaHash(blockHash) {\n        // ensure we have everything required\n        if (!this._genesisHash || !this._runtimeVersion) {\n            throw new Error('Cannot retrieve data on an uninitialized chain');\n        }\n        // We have to assume that on the RPC layer the calls used here does not call back into\n        // the registry swap, so getHeader & getRuntimeVersion should not be historic\n        const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash)\n            ? { number: BN_ZERO, parentHash: this._genesisHash }\n            : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n        if (header.parentHash.isEmpty) {\n            throw new Error('Unable to retrieve header and parent from supplied hash');\n        }\n        // get the runtime version, either on-chain or via an known upgrade history\n        const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n        const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && (firstVersion && (lastVersion ||\n            firstVersion.specVersion.eq(this._runtimeVersion.specVersion)))\n            ? { apis: firstVersion.apis, specName: this._runtimeVersion.specName, specVersion: firstVersion.specVersion }\n            : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n        return (\n        // try to find via version\n        this._getBlockRegistryViaVersion(blockHash, version) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)));\n    }\n    /**\n     * @description Sets up a registry based on the block hash defined\n     */\n    async getBlockRegistry(blockHash, knownVersion) {\n        return (\n        // try to find via blockHash\n        __classPrivateFieldGet(this, _Init_registries, \"f\").find(({ lastBlockHash }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) ||\n            // try to find via version\n            this._getBlockRegistryViaVersion(blockHash, knownVersion) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)));\n    }\n    async _loadMeta() {\n        // on re-connection to the same chain, we don't want to re-do everything from chain again\n        if (this._isReady) {\n            return true;\n        }\n        this._unsubscribeUpdates();\n        // only load from on-chain if we are not a clone (default path), alternatively\n        // just use the values from the source instance provided\n        [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady\n            ? await this._metaFromSource(this._options.source)\n            : await this._metaFromChain(this._options.metadata);\n        return this._initFromMeta(this._runtimeMetadata);\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async _metaFromSource(source) {\n        this._extrinsicType = source.extrinsicVersion;\n        this._runtimeChain = source.runtimeChain;\n        this._runtimeVersion = source.runtimeVersion;\n        // manually build a list of all available methods in this RPC, we are\n        // going to filter on it to align the cloned RPC without making a call\n        const sections = Object.keys(source.rpc);\n        const rpcs = [];\n        for (let s = 0; s < sections.length; s++) {\n            const section = sections[s];\n            const methods = Object.keys(source.rpc[section]);\n            for (let m = 0; m < methods.length; m++) {\n                rpcs.push(`${section}_${methods[m]}`);\n            }\n        }\n        this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n        return [source.genesisHash, source.runtimeMetadata];\n    }\n    // subscribe to metadata updates, inject the types on changes\n    _subscribeUpdates() {\n        if (__classPrivateFieldGet(this, _Init_updateSub, \"f\") || !this.hasSubscriptions) {\n            return;\n        }\n        __classPrivateFieldSet(this, _Init_updateSub, this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap((version) => \n        // only retrieve the metadata when the on-chain version has been changed\n        this._runtimeVersion?.specVersion.eq(version.specVersion)\n            ? of(false)\n            : this._rpcCore.state.getMetadata().pipe(map((metadata) => {\n                l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n                this._runtimeMetadata = metadata;\n                this._runtimeVersion = version;\n                this._rx.runtimeVersion = version;\n                // update the default registry version\n                const thisRegistry = this._getDefaultRegistry();\n                // setup the data as per the current versions\n                thisRegistry.metadata = metadata;\n                thisRegistry.runtimeVersion = version;\n                this._initRegistry(this.registry, this._runtimeChain, version, metadata);\n                this._injectMetadata(thisRegistry, true);\n                return true;\n            })))).subscribe(), \"f\");\n    }\n    async _metaFromChain(optMetadata) {\n        const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([\n            firstValueFrom(this._rpcCore.chain.getBlockHash(0)),\n            firstValueFrom(this._rpcCore.state.getRuntimeVersion()),\n            firstValueFrom(this._rpcCore.system.chain()),\n            firstValueFrom(this._rpcCore.system.properties()),\n            firstValueFrom(this._rpcCore.rpc.methods()),\n            optMetadata\n                ? Promise.resolve(null)\n                : firstValueFrom(this._rpcCore.state.getMetadata())\n        ]);\n        // set our chain version & genesisHash as returned\n        this._runtimeChain = chain;\n        this._runtimeVersion = runtimeVersion;\n        this._rx.runtimeVersion = runtimeVersion;\n        // retrieve metadata, either from chain  or as pass-in via options\n        const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n        const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey]\n            ? new Metadata(this.registry, optMetadata[metadataKey])\n            : await firstValueFrom(this._rpcCore.state.getMetadata()));\n        // initializes the registry & RPC\n        this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n        this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n        this._subscribeUpdates();\n        // setup the initial registry, when we have none\n        if (!__classPrivateFieldGet(this, _Init_registries, \"f\").length) {\n            __classPrivateFieldGet(this, _Init_registries, \"f\").push({ counter: 0, isDefault: true, metadata, registry: this.registry, runtimeVersion });\n        }\n        // get unique types & validate\n        metadata.getUniqTypes(this._options.throwOnUnknown || false);\n        return [genesisHash, metadata];\n    }\n    _initFromMeta(metadata) {\n        this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n        this._rx.extrinsicType = this._extrinsicType;\n        this._rx.genesisHash = this._genesisHash;\n        this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n        // inject metadata and adjust the types as detected\n        this._injectMetadata(this._getDefaultRegistry(), true);\n        // derive is last, since it uses the decorated rx\n        this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n        this._derive = this._decorateDerive(this._decorateMethod);\n        return true;\n    }\n    _subscribeHealth() {\n        this._unsubscribeHealth();\n        // Only enable the health keepalive on WS, not needed on HTTP\n        __classPrivateFieldSet(this, _Init_healthTimer, this.hasSubscriptions\n            ? setInterval(() => {\n                firstValueFrom(this._rpcCore.system.health.raw()).catch(() => undefined);\n            }, KEEPALIVE_INTERVAL)\n            : null, \"f\");\n    }\n    _unsubscribeHealth() {\n        if (__classPrivateFieldGet(this, _Init_healthTimer, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _Init_healthTimer, \"f\"));\n            __classPrivateFieldSet(this, _Init_healthTimer, null, \"f\");\n        }\n    }\n    _unsubscribeUpdates() {\n        if (__classPrivateFieldGet(this, _Init_updateSub, \"f\")) {\n            __classPrivateFieldGet(this, _Init_updateSub, \"f\").unsubscribe();\n            __classPrivateFieldSet(this, _Init_updateSub, null, \"f\");\n        }\n    }\n    _unsubscribe() {\n        this._unsubscribeHealth();\n        this._unsubscribeUpdates();\n    }\n}\n_Init_atLast = new WeakMap(), _Init_healthTimer = new WeakMap(), _Init_registries = new WeakMap(), _Init_updateSub = new WeakMap(), _Init_waitingRegistries = new WeakMap(), _Init_instances = new WeakSet(), _Init_onProviderConnect = async function _Init_onProviderConnect() {\n    this._isConnected.next(true);\n    this.emit('connected');\n    try {\n        const cryptoReady = this._options.initWasm === false\n            ? true\n            : await cryptoWaitReady();\n        const hasMeta = await this._loadMeta();\n        this._subscribeHealth();\n        if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n        }\n    }\n    catch (_error) {\n        const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n        l.error(error);\n        this.emit('error', error);\n    }\n}, _Init_onProviderDisconnect = function _Init_onProviderDisconnect() {\n    this._isConnected.next(false);\n    this._unsubscribe();\n    this.emit('disconnected');\n}, _Init_onProviderError = function _Init_onProviderError(error) {\n    this.emit('error', error);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}