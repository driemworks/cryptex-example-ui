{"ast":null,"code":"import { isFunction, objectProperties, stringify } from '@polkadot/util';\nimport { compareMap } from '../utils/index.js';\n/** @internal */\nfunction decodeJson(value) {\n  return Object.entries(value || {});\n}\n/**\n * @name Json\n * @description\n * Wraps the a JSON structure retrieve via RPC. It extends the standard JS Map with. While it\n * implements a Codec, it is limited in that it can only be used with input objects via RPC,\n * i.e. no hex decoding. Unlike a struct, this waps a JSON object with unknown keys\n * @noInheritDoc\n */\nexport class Json extends Map {\n  constructor(registry, value) {\n    const decoded = decodeJson(value);\n    super(decoded);\n    this.registry = registry;\n    objectProperties(this, decoded.map(_ref => {\n      let [k] = _ref;\n      return k;\n    }), k => this.get(k));\n  }\n  /**\n   * @description Always 0, never encodes as a Uint8Array\n   */\n  get encodedLength() {\n    return 0;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return [...this.keys()].length === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a typed value from the internal map\n   */\n  getT(key) {\n    return this.get(key);\n  }\n  /**\n   * @description Unimplemented, will throw\n   */\n  inspect() {\n    throw new Error('Unimplemented');\n  }\n  /**\n   * @description Unimplemented, will throw\n   */\n  toHex() {\n    throw new Error('Unimplemented');\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return [...this.entries()].reduce((json, _ref2) => {\n      let [key, value] = _ref2;\n      json[key] = isFunction(value.toHuman) ? value.toHuman() : value;\n      return json;\n    }, {});\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return [...this.entries()].reduce((json, _ref3) => {\n      let [key, value] = _ref3;\n      json[key] = value;\n      return json;\n    }, {});\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return [...this.entries()].reduce((json, _ref4) => {\n      let [key, value] = _ref4;\n      json[key] = isFunction(value.toPrimitive) ? value.toPrimitive() : value;\n      return json;\n    }, {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Json';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Unimplemented, will throw\n   */\n  toU8a(_isBare) {\n    throw new Error('Unimplemented');\n  }\n}","map":{"version":3,"names":["isFunction","objectProperties","stringify","compareMap","decodeJson","value","Object","entries","Json","Map","constructor","registry","decoded","map","_ref","k","get","encodedLength","hash","toU8a","isEmpty","keys","length","eq","other","getT","key","inspect","Error","toHex","toHuman","reduce","json","_ref2","toJSON","_ref3","toPrimitive","_ref4","toRawType","toString","_isBare"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/native/Json.js"],"sourcesContent":["import { isFunction, objectProperties, stringify } from '@polkadot/util';\nimport { compareMap } from '../utils/index.js';\n/** @internal */\nfunction decodeJson(value) {\n    return Object.entries(value || {});\n}\n/**\n * @name Json\n * @description\n * Wraps the a JSON structure retrieve via RPC. It extends the standard JS Map with. While it\n * implements a Codec, it is limited in that it can only be used with input objects via RPC,\n * i.e. no hex decoding. Unlike a struct, this waps a JSON object with unknown keys\n * @noInheritDoc\n */\nexport class Json extends Map {\n    constructor(registry, value) {\n        const decoded = decodeJson(value);\n        super(decoded);\n        this.registry = registry;\n        objectProperties(this, decoded.map(([k]) => k), (k) => this.get(k));\n    }\n    /**\n     * @description Always 0, never encodes as a Uint8Array\n     */\n    get encodedLength() {\n        return 0;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return [...this.keys()].length === 0;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareMap(this, other);\n    }\n    /**\n     * @description Returns a typed value from the internal map\n     */\n    getT(key) {\n        return this.get(key);\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    inspect() {\n        throw new Error('Unimplemented');\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    toHex() {\n        throw new Error('Unimplemented');\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = isFunction(value.toHuman)\n                ? value.toHuman()\n                : value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = isFunction(value.toPrimitive)\n                ? value.toPrimitive()\n                : value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Json';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    toU8a(_isBare) {\n        throw new Error('Unimplemented');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}