{"ast":null,"code":"import { compactToU8a, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { compareArray } from '../utils/compareArray.js';\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\nexport class AbstractArray extends Array {\n  /**\n   * @description This ensures that operators such as clice, filter, map, etc. return\n   * new Array instances (without this we need to apply overrides)\n   */\n  static get [Symbol.species]() {\n    return Array;\n  }\n  constructor(registry, length) {\n    super(length);\n    this.registry = registry;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    // We need to loop through all entries since they may have a variable length themselves,\n    // e.g. when a Vec or Compact is contained withing, it has a variable length based on data\n    let total = compactToU8a(this.length).length;\n    for (let i = 0; i < this.length; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareArray(this, other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner(),\n      outer: [compactToU8a(this.length)]\n    };\n  }\n  /**\n   * @internal\n   * @description Internal per-item inspection of internal values\n   */\n  inspectInner() {\n    const inner = new Array(this.length);\n    for (let i = 0; i < this.length; i++) {\n      inner[i] = this[i].inspect();\n    }\n    return inner;\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n  toArray() {\n    return Array.from(this);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended) {\n    const result = new Array(this.length);\n    for (let i = 0; i < this.length; i++) {\n      result[i] = this[i] && this[i].toHuman(isExtended);\n    }\n    return result;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const result = new Array(this.length);\n    for (let i = 0; i < this.length; i++) {\n      // We actually log inside the U8a decoding and use JSON.stringify(...), which\n      // means that the Vec may be partially populated (same applies to toHuman, same check)\n      result[i] = this[i] && this[i].toJSON();\n    }\n    return result;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    const result = new Array(this.length);\n    for (let i = 0; i < this.length; i++) {\n      result[i] = this[i] && this[i].toPrimitive();\n    }\n    return result;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    const result = new Array(this.length);\n    for (let i = 0; i < this.length; i++) {\n      result[i] = this[i].toString();\n    }\n    return `[${result.join(', ')}]`;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = this.toU8aInner();\n    return isBare ? u8aConcatStrict(encoded) : u8aConcatStrict([compactToU8a(this.length), ...encoded]);\n  }\n  /**\n   * @internal\n   * @description Internal per-item SCALE encoding of contained values\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8aInner(isBare) {\n    const encoded = new Array(this.length);\n    for (let i = 0; i < this.length; i++) {\n      encoded[i] = this[i].toU8a(isBare);\n    }\n    return encoded;\n  }\n}","map":{"version":3,"names":["compactToU8a","u8aConcatStrict","u8aToHex","compareArray","AbstractArray","Array","Symbol","species","constructor","registry","length","encodedLength","total","i","hash","toU8a","isEmpty","eq","other","inspect","inner","inspectInner","outer","toArray","from","toHex","toHuman","isExtended","result","toJSON","toPrimitive","toString","join","isBare","encoded","toU8aInner"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/abstract/Array.js"],"sourcesContent":["import { compactToU8a, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { compareArray } from '../utils/compareArray.js';\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\nexport class AbstractArray extends Array {\n    /**\n     * @description This ensures that operators such as clice, filter, map, etc. return\n     * new Array instances (without this we need to apply overrides)\n     */\n    static get [Symbol.species]() {\n        return Array;\n    }\n    constructor(registry, length) {\n        super(length);\n        this.registry = registry;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        // We need to loop through all entries since they may have a variable length themselves,\n        // e.g. when a Vec or Compact is contained withing, it has a variable length based on data\n        let total = compactToU8a(this.length).length;\n        for (let i = 0; i < this.length; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * @description The length of the value\n     */\n    get length() {\n        // only included here since we ignore inherited docs\n        return super.length;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareArray(this, other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner(),\n            outer: [compactToU8a(this.length)]\n        };\n    }\n    /**\n     * @internal\n     * @description Internal per-item inspection of internal values\n     */\n    inspectInner() {\n        const inner = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            inner[i] = this[i].inspect();\n        }\n        return inner;\n    }\n    /**\n     * @description Converts the Object to an standard JavaScript Array\n     */\n    toArray() {\n        return Array.from(this);\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended) {\n        const result = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            result[i] = this[i] && this[i].toHuman(isExtended);\n        }\n        return result;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const result = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            // We actually log inside the U8a decoding and use JSON.stringify(...), which\n            // means that the Vec may be partially populated (same applies to toHuman, same check)\n            result[i] = this[i] && this[i].toJSON();\n        }\n        return result;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        const result = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            result[i] = this[i] && this[i].toPrimitive();\n        }\n        return result;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        const result = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            result[i] = this[i].toString();\n        }\n        return `[${result.join(', ')}]`;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = this.toU8aInner();\n        return isBare\n            ? u8aConcatStrict(encoded)\n            : u8aConcatStrict([compactToU8a(this.length), ...encoded]);\n    }\n    /**\n     * @internal\n     * @description Internal per-item SCALE encoding of contained values\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8aInner(isBare) {\n        const encoded = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            encoded[i] = this[i].toU8a(isBare);\n        }\n        return encoded;\n    }\n}\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,eAAe,EAAEC,QAAQ,QAAQ,gBAAgB;AACxE,SAASC,YAAY,QAAQ,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,SAASC,KAAK,CAAC;EACrC;AACJ;AACA;AACA;EACI,YAAYC,MAAM,CAACC,OAAO,IAAI;IAC1B,OAAOF,KAAK;EAChB;EACAG,WAAWA,CAACC,QAAQ,EAAEC,MAAM,EAAE;IAC1B,KAAK,CAACA,MAAM,CAAC;IACb,IAAI,CAACD,QAAQ,GAAGA,QAAQ;EAC5B;EACA;AACJ;AACA;EACI,IAAIE,aAAaA,CAAA,EAAG;IAChB;IACA;IACA,IAAIC,KAAK,GAAGZ,YAAY,CAAC,IAAI,CAACU,MAAM,CAAC,CAACA,MAAM;IAC5C,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,MAAM,EAAEG,CAAC,EAAE,EAAE;MAClCD,KAAK,IAAI,IAAI,CAACC,CAAC,CAAC,CAACF,aAAa;IAClC;IACA,OAAOC,KAAK;EAChB;EACA;AACJ;AACA;EACI,IAAIE,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACL,QAAQ,CAACK,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE,CAAC;EAC3C;EACA;AACJ;AACA;EACI,IAAIC,OAAOA,CAAA,EAAG;IACV,OAAO,IAAI,CAACN,MAAM,KAAK,CAAC;EAC5B;EACA;AACJ;AACA;EACI,IAAIA,MAAMA,CAAA,EAAG;IACT;IACA,OAAO,KAAK,CAACA,MAAM;EACvB;EACA;AACJ;AACA;EACIO,EAAEA,CAACC,KAAK,EAAE;IACN,OAAOf,YAAY,CAAC,IAAI,EAAEe,KAAK,CAAC;EACpC;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,OAAO;MACHC,KAAK,EAAE,IAAI,CAACC,YAAY,EAAE;MAC1BC,KAAK,EAAE,CAACtB,YAAY,CAAC,IAAI,CAACU,MAAM,CAAC;IACrC,CAAC;EACL;EACA;AACJ;AACA;AACA;EACIW,YAAYA,CAAA,EAAG;IACX,MAAMD,KAAK,GAAG,IAAIf,KAAK,CAAC,IAAI,CAACK,MAAM,CAAC;IACpC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,MAAM,EAAEG,CAAC,EAAE,EAAE;MAClCO,KAAK,CAACP,CAAC,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,CAACM,OAAO,EAAE;IAChC;IACA,OAAOC,KAAK;EAChB;EACA;AACJ;AACA;EACIG,OAAOA,CAAA,EAAG;IACN,OAAOlB,KAAK,CAACmB,IAAI,CAAC,IAAI,CAAC;EAC3B;EACA;AACJ;AACA;EACIC,KAAKA,CAAA,EAAG;IACJ,OAAOvB,QAAQ,CAAC,IAAI,CAACa,KAAK,EAAE,CAAC;EACjC;EACA;AACJ;AACA;EACIW,OAAOA,CAACC,UAAU,EAAE;IAChB,MAAMC,MAAM,GAAG,IAAIvB,KAAK,CAAC,IAAI,CAACK,MAAM,CAAC;IACrC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,MAAM,EAAEG,CAAC,EAAE,EAAE;MAClCe,MAAM,CAACf,CAAC,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,IAAI,IAAI,CAACA,CAAC,CAAC,CAACa,OAAO,CAACC,UAAU,CAAC;IACtD;IACA,OAAOC,MAAM;EACjB;EACA;AACJ;AACA;EACIC,MAAMA,CAAA,EAAG;IACL,MAAMD,MAAM,GAAG,IAAIvB,KAAK,CAAC,IAAI,CAACK,MAAM,CAAC;IACrC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,MAAM,EAAEG,CAAC,EAAE,EAAE;MAClC;MACA;MACAe,MAAM,CAACf,CAAC,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,IAAI,IAAI,CAACA,CAAC,CAAC,CAACgB,MAAM,EAAE;IAC3C;IACA,OAAOD,MAAM;EACjB;EACA;AACJ;AACA;EACIE,WAAWA,CAAA,EAAG;IACV,MAAMF,MAAM,GAAG,IAAIvB,KAAK,CAAC,IAAI,CAACK,MAAM,CAAC;IACrC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,MAAM,EAAEG,CAAC,EAAE,EAAE;MAClCe,MAAM,CAACf,CAAC,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,IAAI,IAAI,CAACA,CAAC,CAAC,CAACiB,WAAW,EAAE;IAChD;IACA,OAAOF,MAAM;EACjB;EACA;AACJ;AACA;EACIG,QAAQA,CAAA,EAAG;IACP,MAAMH,MAAM,GAAG,IAAIvB,KAAK,CAAC,IAAI,CAACK,MAAM,CAAC;IACrC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,MAAM,EAAEG,CAAC,EAAE,EAAE;MAClCe,MAAM,CAACf,CAAC,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,CAACkB,QAAQ,EAAE;IAClC;IACA,OAAQ,IAAGH,MAAM,CAACI,IAAI,CAAC,IAAI,CAAE,GAAE;EACnC;EACA;AACJ;AACA;AACA;EACIjB,KAAKA,CAACkB,MAAM,EAAE;IACV,MAAMC,OAAO,GAAG,IAAI,CAACC,UAAU,EAAE;IACjC,OAAOF,MAAM,GACPhC,eAAe,CAACiC,OAAO,CAAC,GACxBjC,eAAe,CAAC,CAACD,YAAY,CAAC,IAAI,CAACU,MAAM,CAAC,EAAE,GAAGwB,OAAO,CAAC,CAAC;EAClE;EACA;AACJ;AACA;AACA;AACA;EACIC,UAAUA,CAACF,MAAM,EAAE;IACf,MAAMC,OAAO,GAAG,IAAI7B,KAAK,CAAC,IAAI,CAACK,MAAM,CAAC;IACtC,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,MAAM,EAAEG,CAAC,EAAE,EAAE;MAClCqB,OAAO,CAACrB,CAAC,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,CAACE,KAAK,CAACkB,MAAM,CAAC;IACtC;IACA,OAAOC,OAAO;EAClB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}