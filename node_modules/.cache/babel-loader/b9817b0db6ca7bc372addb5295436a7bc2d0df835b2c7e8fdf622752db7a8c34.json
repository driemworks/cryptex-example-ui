{"ast":null,"code":"import { assertUnreachable } from '@polkadot/util';\nfunction convertType(key) {\n  return (registry, _ref) => {\n    let {\n      type\n    } = _ref;\n    return registry.createType('Si1TypeDef', {\n      [key]: {\n        type: type.toNumber()\n      }\n    });\n  };\n}\nfunction convertArray(registry, _ref2) {\n  let {\n    len,\n    type\n  } = _ref2;\n  return registry.createType('Si1TypeDef', {\n    Array: {\n      len,\n      type: type.toNumber()\n    }\n  });\n}\nfunction convertBitSequence(registry, _ref3) {\n  let {\n    bitOrderType,\n    bitStoreType\n  } = _ref3;\n  return registry.createType('Si1TypeDef', {\n    BitSequence: {\n      bitOrderType: bitOrderType.toNumber(),\n      bitStoreType: bitStoreType.toNumber()\n    }\n  });\n}\nconst convertCompact = convertType('Compact');\nfunction convertComposite(registry, _ref4) {\n  let {\n    fields\n  } = _ref4;\n  return registry.createType('Si1TypeDef', {\n    Composite: {\n      fields: convertFields(registry, fields)\n    }\n  });\n}\nfunction convertFields(registry, fields) {\n  return fields.map(_ref5 => {\n    let {\n      docs,\n      name,\n      type,\n      typeName\n    } = _ref5;\n    return registry.createType('Si1Field', {\n      docs,\n      name,\n      type: type.toNumber(),\n      typeName\n    });\n  });\n}\nfunction convertPhantom(registry, path) {\n  console.warn(`Converting phantom type ${path.map(p => p.toString()).join('::')} to empty tuple`);\n  return registry.createType('Si1TypeDef', {\n    Tuple: []\n  });\n}\nfunction convertPrimitive(registry, prim) {\n  return registry.createType('Si1TypeDef', {\n    Primitive: prim.toString()\n  });\n}\nconst convertSequence = convertType('Sequence');\nfunction convertTuple(registry, types) {\n  return registry.createType('Si1TypeDef', {\n    Tuple: types.map(t => t.toNumber())\n  });\n}\nfunction convertVariant(registry, _ref6) {\n  let {\n    variants\n  } = _ref6;\n  return registry.createType('Si1TypeDef', {\n    Variant: {\n      variants: variants.map((_ref7, index) => {\n        let {\n          discriminant,\n          docs,\n          fields,\n          name\n        } = _ref7;\n        return registry.createType('Si1Variant', {\n          docs,\n          fields: convertFields(registry, fields),\n          index: discriminant.isSome ? discriminant.unwrap().toNumber() : index,\n          name\n        });\n      })\n    }\n  });\n}\nfunction convertDef(registry, _ref8) {\n  let {\n    def,\n    path\n  } = _ref8;\n  let result;\n  switch (def.type) {\n    case 'Array':\n      result = convertArray(registry, def.asArray);\n      break;\n    case 'BitSequence':\n      result = convertBitSequence(registry, def.asBitSequence);\n      break;\n    case 'Compact':\n      result = convertCompact(registry, def.asCompact);\n      break;\n    case 'Composite':\n      result = convertComposite(registry, def.asComposite);\n      break;\n    case 'Phantom':\n      result = convertPhantom(registry, path);\n      break;\n    case 'Primitive':\n      result = convertPrimitive(registry, def.asPrimitive);\n      break;\n    case 'Sequence':\n      result = convertSequence(registry, def.asSequence);\n      break;\n    case 'Tuple':\n      result = convertTuple(registry, def.asTuple);\n      break;\n    case 'Variant':\n      result = convertVariant(registry, def.asVariant);\n      break;\n    default:\n      assertUnreachable(def.type);\n  }\n  return result;\n}\nexport function toV1(registry, types) {\n  return types.map((t, index) => registry.createType('PortableType', {\n    // offsets are +1 from v0\n    id: index + 1,\n    type: {\n      def: convertDef(registry, t),\n      docs: [],\n      params: t.params.map(p => registry.createType('Si1TypeParameter', {\n        type: p.toNumber()\n      })),\n      path: t.path.map(p => p.toString())\n    }\n  }));\n}","map":{"version":3,"names":["assertUnreachable","convertType","key","registry","_ref","type","createType","toNumber","convertArray","_ref2","len","Array","convertBitSequence","_ref3","bitOrderType","bitStoreType","BitSequence","convertCompact","convertComposite","_ref4","fields","Composite","convertFields","map","_ref5","docs","name","typeName","convertPhantom","path","console","warn","p","toString","join","Tuple","convertPrimitive","prim","Primitive","convertSequence","convertTuple","types","t","convertVariant","_ref6","variants","Variant","_ref7","index","discriminant","isSome","unwrap","convertDef","_ref8","def","result","asArray","asBitSequence","asCompact","asComposite","asPrimitive","asSequence","asTuple","asVariant","toV1","id","params"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types/metadata/PortableRegistry/toV1.js"],"sourcesContent":["import { assertUnreachable } from '@polkadot/util';\nfunction convertType(key) {\n    return (registry, { type }) => registry.createType('Si1TypeDef', {\n        [key]: {\n            type: type.toNumber()\n        }\n    });\n}\nfunction convertArray(registry, { len, type }) {\n    return registry.createType('Si1TypeDef', {\n        Array: {\n            len,\n            type: type.toNumber()\n        }\n    });\n}\nfunction convertBitSequence(registry, { bitOrderType, bitStoreType }) {\n    return registry.createType('Si1TypeDef', {\n        BitSequence: {\n            bitOrderType: bitOrderType.toNumber(),\n            bitStoreType: bitStoreType.toNumber()\n        }\n    });\n}\nconst convertCompact = convertType('Compact');\nfunction convertComposite(registry, { fields }) {\n    return registry.createType('Si1TypeDef', {\n        Composite: {\n            fields: convertFields(registry, fields)\n        }\n    });\n}\nfunction convertFields(registry, fields) {\n    return fields.map(({ docs, name, type, typeName }) => registry.createType('Si1Field', {\n        docs,\n        name,\n        type: type.toNumber(),\n        typeName\n    }));\n}\nfunction convertPhantom(registry, path) {\n    console.warn(`Converting phantom type ${path.map((p) => p.toString()).join('::')} to empty tuple`);\n    return registry.createType('Si1TypeDef', {\n        Tuple: []\n    });\n}\nfunction convertPrimitive(registry, prim) {\n    return registry.createType('Si1TypeDef', {\n        Primitive: prim.toString()\n    });\n}\nconst convertSequence = convertType('Sequence');\nfunction convertTuple(registry, types) {\n    return registry.createType('Si1TypeDef', {\n        Tuple: types.map((t) => t.toNumber())\n    });\n}\nfunction convertVariant(registry, { variants }) {\n    return registry.createType('Si1TypeDef', {\n        Variant: {\n            variants: variants.map(({ discriminant, docs, fields, name }, index) => registry.createType('Si1Variant', {\n                docs,\n                fields: convertFields(registry, fields),\n                index: discriminant.isSome\n                    ? discriminant.unwrap().toNumber()\n                    : index,\n                name\n            }))\n        }\n    });\n}\nfunction convertDef(registry, { def, path }) {\n    let result;\n    switch (def.type) {\n        case 'Array':\n            result = convertArray(registry, def.asArray);\n            break;\n        case 'BitSequence':\n            result = convertBitSequence(registry, def.asBitSequence);\n            break;\n        case 'Compact':\n            result = convertCompact(registry, def.asCompact);\n            break;\n        case 'Composite':\n            result = convertComposite(registry, def.asComposite);\n            break;\n        case 'Phantom':\n            result = convertPhantom(registry, path);\n            break;\n        case 'Primitive':\n            result = convertPrimitive(registry, def.asPrimitive);\n            break;\n        case 'Sequence':\n            result = convertSequence(registry, def.asSequence);\n            break;\n        case 'Tuple':\n            result = convertTuple(registry, def.asTuple);\n            break;\n        case 'Variant':\n            result = convertVariant(registry, def.asVariant);\n            break;\n        default: assertUnreachable(def.type);\n    }\n    return result;\n}\nexport function toV1(registry, types) {\n    return types.map((t, index) => registry.createType('PortableType', {\n        // offsets are +1 from v0\n        id: index + 1,\n        type: {\n            def: convertDef(registry, t),\n            docs: [],\n            params: t.params.map((p) => registry.createType('Si1TypeParameter', {\n                type: p.toNumber()\n            })),\n            path: t.path.map((p) => p.toString())\n        }\n    }));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}