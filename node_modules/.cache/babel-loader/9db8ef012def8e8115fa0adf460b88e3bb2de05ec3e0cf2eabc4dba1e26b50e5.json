{"ast":null,"code":"var _WsProvider_instances, _WsProvider_callCache, _WsProvider_coder, _WsProvider_endpoints, _WsProvider_headers, _WsProvider_eventemitter, _WsProvider_handlers, _WsProvider_isReadyPromise, _WsProvider_stats, _WsProvider_waitingForId, _WsProvider_autoConnectMs, _WsProvider_endpointIndex, _WsProvider_endpointStats, _WsProvider_isConnected, _WsProvider_subscriptions, _WsProvider_timeoutId, _WsProvider_websocket, _WsProvider_timeout, _WsProvider_send, _WsProvider_emit, _WsProvider_onSocketClose, _WsProvider_onSocketError, _WsProvider_onSocketMessage, _WsProvider_onSocketMessageResult, _WsProvider_onSocketMessageSubscribe, _WsProvider_onSocketOpen, _WsProvider_resubscribe, _WsProvider_timeoutHandlers;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, objectSpread } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n  Object.keys(record).forEach(key => {\n    if (cb) {\n      cb(record[key]);\n    }\n    delete record[key];\n  });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n  return {\n    bytesRecv: 0,\n    bytesSent: 0,\n    cached: 0,\n    errors: 0,\n    requests: 0,\n    subscriptions: 0,\n    timeout: 0\n  };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n   * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n   * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n   */\n  constructor() {\n    var _this = this;\n    let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults.WS_URL;\n    let autoConnectMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETRY_DELAY;\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let timeout = arguments.length > 3 ? arguments[3] : undefined;\n    _WsProvider_instances.add(this);\n    _WsProvider_callCache.set(this, new LRUCache());\n    _WsProvider_coder.set(this, void 0);\n    _WsProvider_endpoints.set(this, void 0);\n    _WsProvider_headers.set(this, void 0);\n    _WsProvider_eventemitter.set(this, void 0);\n    _WsProvider_handlers.set(this, {});\n    _WsProvider_isReadyPromise.set(this, void 0);\n    _WsProvider_stats.set(this, void 0);\n    _WsProvider_waitingForId.set(this, {});\n    _WsProvider_autoConnectMs.set(this, void 0);\n    _WsProvider_endpointIndex.set(this, void 0);\n    _WsProvider_endpointStats.set(this, void 0);\n    _WsProvider_isConnected.set(this, false);\n    _WsProvider_subscriptions.set(this, {});\n    _WsProvider_timeoutId.set(this, null);\n    _WsProvider_websocket.set(this, void 0);\n    _WsProvider_timeout.set(this, void 0);\n    _WsProvider_emit.set(this, function (type) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      __classPrivateFieldGet(_this, _WsProvider_eventemitter, \"f\").emit(type, ...args);\n    });\n    _WsProvider_onSocketClose.set(this, event => {\n      const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n      if (__classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\") > 0) {\n        l.error(error.message);\n      }\n      __classPrivateFieldSet(this, _WsProvider_isConnected, false, \"f\");\n      if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onclose = null;\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onerror = null;\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onmessage = null;\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onopen = null;\n        __classPrivateFieldSet(this, _WsProvider_websocket, null, \"f\");\n      }\n      if (__classPrivateFieldGet(this, _WsProvider_timeoutId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _WsProvider_timeoutId, \"f\"));\n        __classPrivateFieldSet(this, _WsProvider_timeoutId, null, \"f\");\n      }\n      // reject all hanging requests\n      eraseRecord(__classPrivateFieldGet(this, _WsProvider_handlers, \"f\"), h => {\n        try {\n          h.callback(error, undefined);\n        } catch (err) {\n          // does not throw\n          l.error(err);\n        }\n      });\n      eraseRecord(__classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\"));\n      // Reset stats for active endpoint\n      __classPrivateFieldSet(this, _WsProvider_endpointStats, defaultEndpointStats(), \"f\");\n      __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'disconnected');\n      if (__classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\") > 0) {\n        setTimeout(() => {\n          this.connectWithRetry().catch(() => {\n            // does not throw\n          });\n        }, __classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\"));\n      }\n    });\n    _WsProvider_onSocketError.set(this, error => {\n      l.debug(() => ['socket error', error]);\n      __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'error', error);\n    });\n    _WsProvider_onSocketMessage.set(this, message => {\n      l.debug(() => ['received', message.data]);\n      __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").bytesRecv += message.data.length;\n      __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.bytesRecv += message.data.length;\n      const response = JSON.parse(message.data);\n      return isUndefined(response.method) ? __classPrivateFieldGet(this, _WsProvider_onSocketMessageResult, \"f\").call(this, response) : __classPrivateFieldGet(this, _WsProvider_onSocketMessageSubscribe, \"f\").call(this, response);\n    });\n    _WsProvider_onSocketMessageResult.set(this, response => {\n      const handler = __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[response.id];\n      if (!handler) {\n        l.debug(() => `Unable to find handler for id=${response.id}`);\n        return;\n      }\n      try {\n        const {\n          method,\n          params,\n          subscription\n        } = handler;\n        const result = __classPrivateFieldGet(this, _WsProvider_coder, \"f\").decodeResponse(response);\n        // first send the result - in case of subs, we may have an update\n        // immediately if we have some queued results already\n        handler.callback(null, result);\n        if (subscription) {\n          const subId = `${subscription.type}::${result}`;\n          __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subId] = objectSpread({}, subscription, {\n            method,\n            params\n          });\n          // if we have a result waiting for this subscription already\n          if (__classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId]) {\n            __classPrivateFieldGet(this, _WsProvider_onSocketMessageSubscribe, \"f\").call(this, __classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId]);\n          }\n        }\n      } catch (error) {\n        __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").errors++;\n        __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.errors++;\n        handler.callback(error, undefined);\n      }\n      delete __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[response.id];\n    });\n    _WsProvider_onSocketMessageSubscribe.set(this, response => {\n      const method = ALIASES[response.method] || response.method || 'invalid';\n      const subId = `${method}::${response.params.subscription}`;\n      const handler = __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subId];\n      if (!handler) {\n        // store the JSON, we could have out-of-order subid coming in\n        __classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId] = response;\n        l.debug(() => `Unable to find handler for subscription=${subId}`);\n        return;\n      }\n      // housekeeping\n      delete __classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId];\n      try {\n        const result = __classPrivateFieldGet(this, _WsProvider_coder, \"f\").decodeResponse(response);\n        handler.callback(null, result);\n      } catch (error) {\n        __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").errors++;\n        __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.errors++;\n        handler.callback(error, undefined);\n      }\n    });\n    _WsProvider_onSocketOpen.set(this, () => {\n      if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\") === null) {\n        throw new Error('WebSocket cannot be null in onOpen');\n      }\n      l.debug(() => ['connected to', this.endpoint]);\n      __classPrivateFieldSet(this, _WsProvider_isConnected, true, \"f\");\n      __classPrivateFieldGet(this, _WsProvider_resubscribe, \"f\").call(this);\n      __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'connected');\n      return true;\n    });\n    _WsProvider_resubscribe.set(this, () => {\n      const subscriptions = __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\");\n      __classPrivateFieldSet(this, _WsProvider_subscriptions, {}, \"f\");\n      Promise.all(Object.keys(subscriptions).map(async id => {\n        const {\n          callback,\n          method,\n          params,\n          type\n        } = subscriptions[id];\n        // only re-create subscriptions which are not in author (only area where\n        // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n        // are not included (and will not be re-broadcast)\n        if (type.startsWith('author_')) {\n          return;\n        }\n        try {\n          await this.subscribe(type, method, params, callback);\n        } catch (error) {\n          l.error(error);\n        }\n      })).catch(l.error);\n    });\n    _WsProvider_timeoutHandlers.set(this, () => {\n      const now = Date.now();\n      const ids = Object.keys(__classPrivateFieldGet(this, _WsProvider_handlers, \"f\"));\n      for (let i = 0; i < ids.length; i++) {\n        const handler = __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[ids[i]];\n        if (now - handler.start > __classPrivateFieldGet(this, _WsProvider_timeout, \"f\")) {\n          try {\n            handler.callback(new Error(`No response received from RPC endpoint in ${__classPrivateFieldGet(this, _WsProvider_timeout, \"f\") / 1000}s`), undefined);\n          } catch {\n            // ignore\n          }\n          __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").timeout++;\n          __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.timeout++;\n          delete __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[ids[i]];\n        }\n      }\n    });\n    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    if (endpoints.length === 0) {\n      throw new Error('WsProvider requires at least one Endpoint');\n    }\n    endpoints.forEach(endpoint => {\n      if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n        throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n      }\n    });\n    __classPrivateFieldSet(this, _WsProvider_eventemitter, new EventEmitter(), \"f\");\n    __classPrivateFieldSet(this, _WsProvider_autoConnectMs, autoConnectMs || 0, \"f\");\n    __classPrivateFieldSet(this, _WsProvider_coder, new RpcCoder(), \"f\");\n    __classPrivateFieldSet(this, _WsProvider_endpointIndex, -1, \"f\");\n    __classPrivateFieldSet(this, _WsProvider_endpoints, endpoints, \"f\");\n    __classPrivateFieldSet(this, _WsProvider_headers, headers, \"f\");\n    __classPrivateFieldSet(this, _WsProvider_websocket, null, \"f\");\n    __classPrivateFieldSet(this, _WsProvider_stats, {\n      active: {\n        requests: 0,\n        subscriptions: 0\n      },\n      total: defaultEndpointStats()\n    }, \"f\");\n    __classPrivateFieldSet(this, _WsProvider_endpointStats, defaultEndpointStats(), \"f\");\n    __classPrivateFieldSet(this, _WsProvider_timeout, timeout || DEFAULT_TIMEOUT_MS, \"f\");\n    if (autoConnectMs && autoConnectMs > 0) {\n      this.connectWithRetry().catch(() => {\n        // does not throw\n      });\n    }\n    __classPrivateFieldSet(this, _WsProvider_isReadyPromise, new Promise(resolve => {\n      __classPrivateFieldGet(this, _WsProvider_eventemitter, \"f\").once('connected', () => {\n        resolve(this);\n      });\n    }), \"f\");\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n  get hasSubscriptions() {\n    return true;\n  }\n  /**\n   * @summary `true` when this provider supports clone()\n   */\n  get isClonable() {\n    return true;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n  get isConnected() {\n    return __classPrivateFieldGet(this, _WsProvider_isConnected, \"f\");\n  }\n  /**\n   * @description Promise that resolves the first time we are connected and loaded\n   */\n  get isReady() {\n    return __classPrivateFieldGet(this, _WsProvider_isReadyPromise, \"f\");\n  }\n  get endpoint() {\n    return __classPrivateFieldGet(this, _WsProvider_endpoints, \"f\")[__classPrivateFieldGet(this, _WsProvider_endpointIndex, \"f\")];\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n  clone() {\n    return new WsProvider(__classPrivateFieldGet(this, _WsProvider_endpoints, \"f\"));\n  }\n  selectEndpointIndex(endpoints) {\n    return (__classPrivateFieldGet(this, _WsProvider_endpointIndex, \"f\") + 1) % endpoints.length;\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async connect() {\n    if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n      throw new Error('WebSocket is already connected');\n    }\n    try {\n      __classPrivateFieldSet(this, _WsProvider_endpointIndex, this.selectEndpointIndex(__classPrivateFieldGet(this, _WsProvider_endpoints, \"f\")), \"f\");\n      // the as typeof WebSocket here is Deno-specific - not available on the globalThis\n      __classPrivateFieldSet(this, _WsProvider_websocket, typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(this.endpoint)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - WS may be an instance of ws, which supports options\n      : new WebSocket(this.endpoint, undefined, {\n        headers: __classPrivateFieldGet(this, _WsProvider_headers, \"f\")\n      }), \"f\");\n      if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onclose = __classPrivateFieldGet(this, _WsProvider_onSocketClose, \"f\");\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onerror = __classPrivateFieldGet(this, _WsProvider_onSocketError, \"f\");\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onmessage = __classPrivateFieldGet(this, _WsProvider_onSocketMessage, \"f\");\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onopen = __classPrivateFieldGet(this, _WsProvider_onSocketOpen, \"f\");\n      }\n      // timeout any handlers that have not had a response\n      __classPrivateFieldSet(this, _WsProvider_timeoutId, setInterval(() => __classPrivateFieldGet(this, _WsProvider_timeoutHandlers, \"f\").call(this), TIMEOUT_INTERVAL), \"f\");\n    } catch (error) {\n      l.error(error);\n      __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Connect, never throwing an error, but rather forcing a retry\n   */\n  async connectWithRetry() {\n    if (__classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\") > 0) {\n      try {\n        await this.connect();\n      } catch {\n        setTimeout(() => {\n          this.connectWithRetry().catch(() => {\n            // does not throw\n          });\n        }, __classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\"));\n      }\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing auto-connect logic\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async disconnect() {\n    // switch off autoConnect, we are in manual mode now\n    __classPrivateFieldSet(this, _WsProvider_autoConnectMs, 0, \"f\");\n    try {\n      if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n        // 1000 - Normal closure; the connection successfully completed\n        __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").close(1000);\n      }\n    } catch (error) {\n      l.error(error);\n      __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Returns the connection stats\n   */\n  get stats() {\n    return {\n      active: {\n        requests: Object.keys(__classPrivateFieldGet(this, _WsProvider_handlers, \"f\")).length,\n        subscriptions: Object.keys(__classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")).length\n      },\n      total: __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total\n    };\n  }\n  get endpointStats() {\n    return __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\");\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   * @return unsubscribe function\n   */\n  on(type, sub) {\n    __classPrivateFieldGet(this, _WsProvider_eventemitter, \"f\").on(type, sub);\n    return () => {\n      __classPrivateFieldGet(this, _WsProvider_eventemitter, \"f\").removeListener(type, sub);\n    };\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded parameters as applicable for the method\n   * @param subscription Subscription details (internally used)\n   */\n  send(method, params, isCacheable, subscription) {\n    __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").requests++;\n    __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.requests++;\n    const [id, body] = __classPrivateFieldGet(this, _WsProvider_coder, \"f\").encodeJson(method, params);\n    let resultPromise = isCacheable ? __classPrivateFieldGet(this, _WsProvider_callCache, \"f\").get(body) : null;\n    if (!resultPromise) {\n      resultPromise = __classPrivateFieldGet(this, _WsProvider_instances, \"m\", _WsProvider_send).call(this, id, body, method, params, subscription);\n      if (isCacheable) {\n        __classPrivateFieldGet(this, _WsProvider_callCache, \"f\").set(body, resultPromise);\n      }\n    } else {\n      __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").cached++;\n      __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.cached++;\n    }\n    return resultPromise;\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n  subscribe(type, method, params, callback) {\n    __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").subscriptions++;\n    __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.subscriptions++;\n    // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n    return this.send(method, params, false, {\n      callback,\n      type\n    });\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n  async unsubscribe(type, method, id) {\n    const subscription = `${type}::${id}`;\n    // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n    if (isUndefined(__classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subscription])) {\n      l.debug(() => `Unable to find active subscription=${subscription}`);\n      return false;\n    }\n    delete __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subscription];\n    try {\n      return this.isConnected && !isNull(__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) ? this.send(method, [id]) : true;\n    } catch {\n      return false;\n    }\n  }\n}\n_WsProvider_callCache = new WeakMap(), _WsProvider_coder = new WeakMap(), _WsProvider_endpoints = new WeakMap(), _WsProvider_headers = new WeakMap(), _WsProvider_eventemitter = new WeakMap(), _WsProvider_handlers = new WeakMap(), _WsProvider_isReadyPromise = new WeakMap(), _WsProvider_stats = new WeakMap(), _WsProvider_waitingForId = new WeakMap(), _WsProvider_autoConnectMs = new WeakMap(), _WsProvider_endpointIndex = new WeakMap(), _WsProvider_endpointStats = new WeakMap(), _WsProvider_isConnected = new WeakMap(), _WsProvider_subscriptions = new WeakMap(), _WsProvider_timeoutId = new WeakMap(), _WsProvider_websocket = new WeakMap(), _WsProvider_timeout = new WeakMap(), _WsProvider_emit = new WeakMap(), _WsProvider_onSocketClose = new WeakMap(), _WsProvider_onSocketError = new WeakMap(), _WsProvider_onSocketMessage = new WeakMap(), _WsProvider_onSocketMessageResult = new WeakMap(), _WsProvider_onSocketMessageSubscribe = new WeakMap(), _WsProvider_onSocketOpen = new WeakMap(), _WsProvider_resubscribe = new WeakMap(), _WsProvider_timeoutHandlers = new WeakMap(), _WsProvider_instances = new WeakSet(), _WsProvider_send = async function _WsProvider_send(id, body, method, params, subscription) {\n  return new Promise((resolve, reject) => {\n    try {\n      if (!this.isConnected || __classPrivateFieldGet(this, _WsProvider_websocket, \"f\") === null) {\n        throw new Error('WebSocket is not connected');\n      }\n      const callback = (error, result) => {\n        error ? reject(error) : resolve(result);\n      };\n      l.debug(() => ['calling', method, body]);\n      __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[id] = {\n        callback,\n        method,\n        params,\n        start: Date.now(),\n        subscription\n      };\n      __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").bytesSent += body.length;\n      __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.bytesSent += body.length;\n      __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").send(body);\n    } catch (error) {\n      __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").errors++;\n      __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.errors++;\n      reject(error);\n    }\n  });\n};","map":{"version":3,"names":["_WsProvider_instances","_WsProvider_callCache","_WsProvider_coder","_WsProvider_endpoints","_WsProvider_headers","_WsProvider_eventemitter","_WsProvider_handlers","_WsProvider_isReadyPromise","_WsProvider_stats","_WsProvider_waitingForId","_WsProvider_autoConnectMs","_WsProvider_endpointIndex","_WsProvider_endpointStats","_WsProvider_isConnected","_WsProvider_subscriptions","_WsProvider_timeoutId","_WsProvider_websocket","_WsProvider_timeout","_WsProvider_send","_WsProvider_emit","_WsProvider_onSocketClose","_WsProvider_onSocketError","_WsProvider_onSocketMessage","_WsProvider_onSocketMessageResult","_WsProvider_onSocketMessageSubscribe","_WsProvider_onSocketOpen","_WsProvider_resubscribe","_WsProvider_timeoutHandlers","__classPrivateFieldGet","__classPrivateFieldSet","EventEmitter","isChildClass","isNull","isUndefined","logger","objectSpread","xglobal","WebSocket","RpcCoder","defaults","LRUCache","getWSErrorString","ALIASES","chain_finalisedHead","chain_subscribeFinalisedHeads","chain_unsubscribeFinalisedHeads","RETRY_DELAY","DEFAULT_TIMEOUT_MS","TIMEOUT_INTERVAL","l","eraseRecord","record","cb","Object","keys","forEach","key","defaultEndpointStats","bytesRecv","bytesSent","cached","errors","requests","subscriptions","timeout","WsProvider","constructor","_this","endpoint","arguments","length","undefined","WS_URL","autoConnectMs","headers","add","set","type","_len","args","Array","_key","emit","event","error","Error","code","reason","message","onclose","onerror","onmessage","onopen","clearInterval","h","callback","err","call","setTimeout","connectWithRetry","catch","debug","data","total","response","JSON","parse","method","handler","id","params","subscription","result","decodeResponse","subId","Promise","all","map","startsWith","subscribe","now","Date","ids","i","start","endpoints","isArray","test","active","resolve","once","hasSubscriptions","isClonable","isConnected","isReady","clone","selectEndpointIndex","connect","setInterval","disconnect","close","stats","endpointStats","on","sub","removeListener","send","isCacheable","body","encodeJson","resultPromise","get","unsubscribe","WeakMap","WeakSet","reject"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/rpc-provider/ws/index.js"],"sourcesContent":["var _WsProvider_instances, _WsProvider_callCache, _WsProvider_coder, _WsProvider_endpoints, _WsProvider_headers, _WsProvider_eventemitter, _WsProvider_handlers, _WsProvider_isReadyPromise, _WsProvider_stats, _WsProvider_waitingForId, _WsProvider_autoConnectMs, _WsProvider_endpointIndex, _WsProvider_endpointStats, _WsProvider_isConnected, _WsProvider_subscriptions, _WsProvider_timeoutId, _WsProvider_websocket, _WsProvider_timeout, _WsProvider_send, _WsProvider_emit, _WsProvider_onSocketClose, _WsProvider_onSocketError, _WsProvider_onSocketMessage, _WsProvider_onSocketMessageResult, _WsProvider_onSocketMessageSubscribe, _WsProvider_onSocketOpen, _WsProvider_resubscribe, _WsProvider_timeoutHandlers;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, objectSpread } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n    chain_finalisedHead: 'chain_finalizedHead',\n    chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n    chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n    Object.keys(record).forEach((key) => {\n        if (cb) {\n            cb(record[key]);\n        }\n        delete record[key];\n    });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n    return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n    /**\n     * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n     * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n     * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n     * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n     */\n    constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout) {\n        _WsProvider_instances.add(this);\n        _WsProvider_callCache.set(this, new LRUCache());\n        _WsProvider_coder.set(this, void 0);\n        _WsProvider_endpoints.set(this, void 0);\n        _WsProvider_headers.set(this, void 0);\n        _WsProvider_eventemitter.set(this, void 0);\n        _WsProvider_handlers.set(this, {});\n        _WsProvider_isReadyPromise.set(this, void 0);\n        _WsProvider_stats.set(this, void 0);\n        _WsProvider_waitingForId.set(this, {});\n        _WsProvider_autoConnectMs.set(this, void 0);\n        _WsProvider_endpointIndex.set(this, void 0);\n        _WsProvider_endpointStats.set(this, void 0);\n        _WsProvider_isConnected.set(this, false);\n        _WsProvider_subscriptions.set(this, {});\n        _WsProvider_timeoutId.set(this, null);\n        _WsProvider_websocket.set(this, void 0);\n        _WsProvider_timeout.set(this, void 0);\n        _WsProvider_emit.set(this, (type, ...args) => {\n            __classPrivateFieldGet(this, _WsProvider_eventemitter, \"f\").emit(type, ...args);\n        });\n        _WsProvider_onSocketClose.set(this, (event) => {\n            const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n            if (__classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\") > 0) {\n                l.error(error.message);\n            }\n            __classPrivateFieldSet(this, _WsProvider_isConnected, false, \"f\");\n            if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onclose = null;\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onerror = null;\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onmessage = null;\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onopen = null;\n                __classPrivateFieldSet(this, _WsProvider_websocket, null, \"f\");\n            }\n            if (__classPrivateFieldGet(this, _WsProvider_timeoutId, \"f\")) {\n                clearInterval(__classPrivateFieldGet(this, _WsProvider_timeoutId, \"f\"));\n                __classPrivateFieldSet(this, _WsProvider_timeoutId, null, \"f\");\n            }\n            // reject all hanging requests\n            eraseRecord(__classPrivateFieldGet(this, _WsProvider_handlers, \"f\"), (h) => {\n                try {\n                    h.callback(error, undefined);\n                }\n                catch (err) {\n                    // does not throw\n                    l.error(err);\n                }\n            });\n            eraseRecord(__classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\"));\n            // Reset stats for active endpoint\n            __classPrivateFieldSet(this, _WsProvider_endpointStats, defaultEndpointStats(), \"f\");\n            __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'disconnected');\n            if (__classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\") > 0) {\n                setTimeout(() => {\n                    this.connectWithRetry().catch(() => {\n                        // does not throw\n                    });\n                }, __classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\"));\n            }\n        });\n        _WsProvider_onSocketError.set(this, (error) => {\n            l.debug(() => ['socket error', error]);\n            __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'error', error);\n        });\n        _WsProvider_onSocketMessage.set(this, (message) => {\n            l.debug(() => ['received', message.data]);\n            __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").bytesRecv += message.data.length;\n            __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.bytesRecv += message.data.length;\n            const response = JSON.parse(message.data);\n            return isUndefined(response.method)\n                ? __classPrivateFieldGet(this, _WsProvider_onSocketMessageResult, \"f\").call(this, response)\n                : __classPrivateFieldGet(this, _WsProvider_onSocketMessageSubscribe, \"f\").call(this, response);\n        });\n        _WsProvider_onSocketMessageResult.set(this, (response) => {\n            const handler = __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[response.id];\n            if (!handler) {\n                l.debug(() => `Unable to find handler for id=${response.id}`);\n                return;\n            }\n            try {\n                const { method, params, subscription } = handler;\n                const result = __classPrivateFieldGet(this, _WsProvider_coder, \"f\").decodeResponse(response);\n                // first send the result - in case of subs, we may have an update\n                // immediately if we have some queued results already\n                handler.callback(null, result);\n                if (subscription) {\n                    const subId = `${subscription.type}::${result}`;\n                    __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subId] = objectSpread({}, subscription, {\n                        method,\n                        params\n                    });\n                    // if we have a result waiting for this subscription already\n                    if (__classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId]) {\n                        __classPrivateFieldGet(this, _WsProvider_onSocketMessageSubscribe, \"f\").call(this, __classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId]);\n                    }\n                }\n            }\n            catch (error) {\n                __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").errors++;\n                __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.errors++;\n                handler.callback(error, undefined);\n            }\n            delete __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[response.id];\n        });\n        _WsProvider_onSocketMessageSubscribe.set(this, (response) => {\n            const method = ALIASES[response.method] || response.method || 'invalid';\n            const subId = `${method}::${response.params.subscription}`;\n            const handler = __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subId];\n            if (!handler) {\n                // store the JSON, we could have out-of-order subid coming in\n                __classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId] = response;\n                l.debug(() => `Unable to find handler for subscription=${subId}`);\n                return;\n            }\n            // housekeeping\n            delete __classPrivateFieldGet(this, _WsProvider_waitingForId, \"f\")[subId];\n            try {\n                const result = __classPrivateFieldGet(this, _WsProvider_coder, \"f\").decodeResponse(response);\n                handler.callback(null, result);\n            }\n            catch (error) {\n                __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").errors++;\n                __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.errors++;\n                handler.callback(error, undefined);\n            }\n        });\n        _WsProvider_onSocketOpen.set(this, () => {\n            if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\") === null) {\n                throw new Error('WebSocket cannot be null in onOpen');\n            }\n            l.debug(() => ['connected to', this.endpoint]);\n            __classPrivateFieldSet(this, _WsProvider_isConnected, true, \"f\");\n            __classPrivateFieldGet(this, _WsProvider_resubscribe, \"f\").call(this);\n            __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'connected');\n            return true;\n        });\n        _WsProvider_resubscribe.set(this, () => {\n            const subscriptions = __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\");\n            __classPrivateFieldSet(this, _WsProvider_subscriptions, {}, \"f\");\n            Promise.all(Object.keys(subscriptions).map(async (id) => {\n                const { callback, method, params, type } = subscriptions[id];\n                // only re-create subscriptions which are not in author (only area where\n                // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n                // are not included (and will not be re-broadcast)\n                if (type.startsWith('author_')) {\n                    return;\n                }\n                try {\n                    await this.subscribe(type, method, params, callback);\n                }\n                catch (error) {\n                    l.error(error);\n                }\n            })).catch(l.error);\n        });\n        _WsProvider_timeoutHandlers.set(this, () => {\n            const now = Date.now();\n            const ids = Object.keys(__classPrivateFieldGet(this, _WsProvider_handlers, \"f\"));\n            for (let i = 0; i < ids.length; i++) {\n                const handler = __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[ids[i]];\n                if ((now - handler.start) > __classPrivateFieldGet(this, _WsProvider_timeout, \"f\")) {\n                    try {\n                        handler.callback(new Error(`No response received from RPC endpoint in ${__classPrivateFieldGet(this, _WsProvider_timeout, \"f\") / 1000}s`), undefined);\n                    }\n                    catch {\n                        // ignore\n                    }\n                    __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").timeout++;\n                    __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.timeout++;\n                    delete __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[ids[i]];\n                }\n            }\n        });\n        const endpoints = Array.isArray(endpoint)\n            ? endpoint\n            : [endpoint];\n        if (endpoints.length === 0) {\n            throw new Error('WsProvider requires at least one Endpoint');\n        }\n        endpoints.forEach((endpoint) => {\n            if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n                throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n            }\n        });\n        __classPrivateFieldSet(this, _WsProvider_eventemitter, new EventEmitter(), \"f\");\n        __classPrivateFieldSet(this, _WsProvider_autoConnectMs, autoConnectMs || 0, \"f\");\n        __classPrivateFieldSet(this, _WsProvider_coder, new RpcCoder(), \"f\");\n        __classPrivateFieldSet(this, _WsProvider_endpointIndex, -1, \"f\");\n        __classPrivateFieldSet(this, _WsProvider_endpoints, endpoints, \"f\");\n        __classPrivateFieldSet(this, _WsProvider_headers, headers, \"f\");\n        __classPrivateFieldSet(this, _WsProvider_websocket, null, \"f\");\n        __classPrivateFieldSet(this, _WsProvider_stats, {\n            active: { requests: 0, subscriptions: 0 },\n            total: defaultEndpointStats()\n        }, \"f\");\n        __classPrivateFieldSet(this, _WsProvider_endpointStats, defaultEndpointStats(), \"f\");\n        __classPrivateFieldSet(this, _WsProvider_timeout, timeout || DEFAULT_TIMEOUT_MS, \"f\");\n        if (autoConnectMs && autoConnectMs > 0) {\n            this.connectWithRetry().catch(() => {\n                // does not throw\n            });\n        }\n        __classPrivateFieldSet(this, _WsProvider_isReadyPromise, new Promise((resolve) => {\n            __classPrivateFieldGet(this, _WsProvider_eventemitter, \"f\").once('connected', () => {\n                resolve(this);\n            });\n        }), \"f\");\n    }\n    /**\n     * @summary `true` when this provider supports subscriptions\n     */\n    get hasSubscriptions() {\n        return true;\n    }\n    /**\n     * @summary `true` when this provider supports clone()\n     */\n    get isClonable() {\n        return true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n    get isConnected() {\n        return __classPrivateFieldGet(this, _WsProvider_isConnected, \"f\");\n    }\n    /**\n     * @description Promise that resolves the first time we are connected and loaded\n     */\n    get isReady() {\n        return __classPrivateFieldGet(this, _WsProvider_isReadyPromise, \"f\");\n    }\n    get endpoint() {\n        return __classPrivateFieldGet(this, _WsProvider_endpoints, \"f\")[__classPrivateFieldGet(this, _WsProvider_endpointIndex, \"f\")];\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n    clone() {\n        return new WsProvider(__classPrivateFieldGet(this, _WsProvider_endpoints, \"f\"));\n    }\n    selectEndpointIndex(endpoints) {\n        return (__classPrivateFieldGet(this, _WsProvider_endpointIndex, \"f\") + 1) % endpoints.length;\n    }\n    /**\n     * @summary Manually connect\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n     * connect manually using this method.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async connect() {\n        if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n            throw new Error('WebSocket is already connected');\n        }\n        try {\n            __classPrivateFieldSet(this, _WsProvider_endpointIndex, this.selectEndpointIndex(__classPrivateFieldGet(this, _WsProvider_endpoints, \"f\")), \"f\");\n            // the as typeof WebSocket here is Deno-specific - not available on the globalThis\n            __classPrivateFieldSet(this, _WsProvider_websocket, typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket)\n                ? new WebSocket(this.endpoint)\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - WS may be an instance of ws, which supports options\n                : new WebSocket(this.endpoint, undefined, {\n                    headers: __classPrivateFieldGet(this, _WsProvider_headers, \"f\")\n                }), \"f\");\n            if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onclose = __classPrivateFieldGet(this, _WsProvider_onSocketClose, \"f\");\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onerror = __classPrivateFieldGet(this, _WsProvider_onSocketError, \"f\");\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onmessage = __classPrivateFieldGet(this, _WsProvider_onSocketMessage, \"f\");\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").onopen = __classPrivateFieldGet(this, _WsProvider_onSocketOpen, \"f\");\n            }\n            // timeout any handlers that have not had a response\n            __classPrivateFieldSet(this, _WsProvider_timeoutId, setInterval(() => __classPrivateFieldGet(this, _WsProvider_timeoutHandlers, \"f\").call(this), TIMEOUT_INTERVAL), \"f\");\n        }\n        catch (error) {\n            l.error(error);\n            __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Connect, never throwing an error, but rather forcing a retry\n     */\n    async connectWithRetry() {\n        if (__classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\") > 0) {\n            try {\n                await this.connect();\n            }\n            catch {\n                setTimeout(() => {\n                    this.connectWithRetry().catch(() => {\n                        // does not throw\n                    });\n                }, __classPrivateFieldGet(this, _WsProvider_autoConnectMs, \"f\"));\n            }\n        }\n    }\n    /**\n     * @description Manually disconnect from the connection, clearing auto-connect logic\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async disconnect() {\n        // switch off autoConnect, we are in manual mode now\n        __classPrivateFieldSet(this, _WsProvider_autoConnectMs, 0, \"f\");\n        try {\n            if (__classPrivateFieldGet(this, _WsProvider_websocket, \"f\")) {\n                // 1000 - Normal closure; the connection successfully completed\n                __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").close(1000);\n            }\n        }\n        catch (error) {\n            l.error(error);\n            __classPrivateFieldGet(this, _WsProvider_emit, \"f\").call(this, 'error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Returns the connection stats\n     */\n    get stats() {\n        return {\n            active: {\n                requests: Object.keys(__classPrivateFieldGet(this, _WsProvider_handlers, \"f\")).length,\n                subscriptions: Object.keys(__classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")).length\n            },\n            total: __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total\n        };\n    }\n    get endpointStats() {\n        return __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\");\n    }\n    /**\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\n     * @param  {ProviderInterfaceEmitted} type Event\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\n     * @return unsubscribe function\n     */\n    on(type, sub) {\n        __classPrivateFieldGet(this, _WsProvider_eventemitter, \"f\").on(type, sub);\n        return () => {\n            __classPrivateFieldGet(this, _WsProvider_eventemitter, \"f\").removeListener(type, sub);\n        };\n    }\n    /**\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n     * @param method The RPC methods to execute\n     * @param params Encoded parameters as applicable for the method\n     * @param subscription Subscription details (internally used)\n     */\n    send(method, params, isCacheable, subscription) {\n        __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").requests++;\n        __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.requests++;\n        const [id, body] = __classPrivateFieldGet(this, _WsProvider_coder, \"f\").encodeJson(method, params);\n        let resultPromise = isCacheable\n            ? __classPrivateFieldGet(this, _WsProvider_callCache, \"f\").get(body)\n            : null;\n        if (!resultPromise) {\n            resultPromise = __classPrivateFieldGet(this, _WsProvider_instances, \"m\", _WsProvider_send).call(this, id, body, method, params, subscription);\n            if (isCacheable) {\n                __classPrivateFieldGet(this, _WsProvider_callCache, \"f\").set(body, resultPromise);\n            }\n        }\n        else {\n            __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").cached++;\n            __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.cached++;\n        }\n        return resultPromise;\n    }\n    /**\n     * @name subscribe\n     * @summary Allows subscribing to a specific event.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\n     * const rpc = new Rpc(provider);\n     *\n     * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n     *   console.log(values)\n     * }).then((subscriptionId) => {\n     *   console.log('balance changes subscription id: ', subscriptionId)\n     * })\n     * ```\n     */\n    subscribe(type, method, params, callback) {\n        __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").subscriptions++;\n        __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.subscriptions++;\n        // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n        return this.send(method, params, false, { callback, type });\n    }\n    /**\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n     */\n    async unsubscribe(type, method, id) {\n        const subscription = `${type}::${id}`;\n        // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n        // the assigned id now does not match what the API user originally received. It has\n        // a slight complication in solving - since we cannot rely on the send id, but rather\n        // need to find the actual subscription id to map it\n        if (isUndefined(__classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subscription])) {\n            l.debug(() => `Unable to find active subscription=${subscription}`);\n            return false;\n        }\n        delete __classPrivateFieldGet(this, _WsProvider_subscriptions, \"f\")[subscription];\n        try {\n            return this.isConnected && !isNull(__classPrivateFieldGet(this, _WsProvider_websocket, \"f\"))\n                ? this.send(method, [id])\n                : true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n_WsProvider_callCache = new WeakMap(), _WsProvider_coder = new WeakMap(), _WsProvider_endpoints = new WeakMap(), _WsProvider_headers = new WeakMap(), _WsProvider_eventemitter = new WeakMap(), _WsProvider_handlers = new WeakMap(), _WsProvider_isReadyPromise = new WeakMap(), _WsProvider_stats = new WeakMap(), _WsProvider_waitingForId = new WeakMap(), _WsProvider_autoConnectMs = new WeakMap(), _WsProvider_endpointIndex = new WeakMap(), _WsProvider_endpointStats = new WeakMap(), _WsProvider_isConnected = new WeakMap(), _WsProvider_subscriptions = new WeakMap(), _WsProvider_timeoutId = new WeakMap(), _WsProvider_websocket = new WeakMap(), _WsProvider_timeout = new WeakMap(), _WsProvider_emit = new WeakMap(), _WsProvider_onSocketClose = new WeakMap(), _WsProvider_onSocketError = new WeakMap(), _WsProvider_onSocketMessage = new WeakMap(), _WsProvider_onSocketMessageResult = new WeakMap(), _WsProvider_onSocketMessageSubscribe = new WeakMap(), _WsProvider_onSocketOpen = new WeakMap(), _WsProvider_resubscribe = new WeakMap(), _WsProvider_timeoutHandlers = new WeakMap(), _WsProvider_instances = new WeakSet(), _WsProvider_send = async function _WsProvider_send(id, body, method, params, subscription) {\n    return new Promise((resolve, reject) => {\n        try {\n            if (!this.isConnected || __classPrivateFieldGet(this, _WsProvider_websocket, \"f\") === null) {\n                throw new Error('WebSocket is not connected');\n            }\n            const callback = (error, result) => {\n                error\n                    ? reject(error)\n                    : resolve(result);\n            };\n            l.debug(() => ['calling', method, body]);\n            __classPrivateFieldGet(this, _WsProvider_handlers, \"f\")[id] = {\n                callback,\n                method,\n                params,\n                start: Date.now(),\n                subscription\n            };\n            __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").bytesSent += body.length;\n            __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.bytesSent += body.length;\n            __classPrivateFieldGet(this, _WsProvider_websocket, \"f\").send(body);\n        }\n        catch (error) {\n            __classPrivateFieldGet(this, _WsProvider_endpointStats, \"f\").errors++;\n            __classPrivateFieldGet(this, _WsProvider_stats, \"f\").total.errors++;\n            reject(error);\n        }\n    });\n};\n"],"mappings":"AAAA,IAAIA,qBAAqB,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,wBAAwB,EAAEC,oBAAoB,EAAEC,0BAA0B,EAAEC,iBAAiB,EAAEC,wBAAwB,EAAEC,yBAAyB,EAAEC,yBAAyB,EAAEC,yBAAyB,EAAEC,uBAAuB,EAAEC,yBAAyB,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAEC,yBAAyB,EAAEC,yBAAyB,EAAEC,2BAA2B,EAAEC,iCAAiC,EAAEC,oCAAoC,EAAEC,wBAAwB,EAAEC,uBAAuB,EAAEC,2BAA2B;AAChsB,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,OAAO;AACtE,SAASC,YAAY,QAAQ,eAAe;AAC5C,SAASC,YAAY,EAAEC,MAAM,EAAEC,WAAW,EAAEC,MAAM,EAAEC,YAAY,QAAQ,gBAAgB;AACxF,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,QAAQ,QAAQ,mBAAmB;AAC5C,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,SAASC,QAAQ,QAAQ,WAAW;AACpC,SAASC,gBAAgB,QAAQ,aAAa;AAC9C,MAAMC,OAAO,GAAG;EACZC,mBAAmB,EAAE,qBAAqB;EAC1CC,6BAA6B,EAAE,+BAA+B;EAC9DC,+BAA+B,EAAE;AACrC,CAAC;AACD,MAAMC,WAAW,GAAG,IAAI;AACxB,MAAMC,kBAAkB,GAAG,EAAE,GAAG,IAAI;AACpC,MAAMC,gBAAgB,GAAG,IAAI;AAC7B,MAAMC,CAAC,GAAGf,MAAM,CAAC,QAAQ,CAAC;AAC1B;AACA,SAASgB,WAAWA,CAACC,MAAM,EAAEC,EAAE,EAAE;EAC7BC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,CAACI,OAAO,CAAEC,GAAG,IAAK;IACjC,IAAIJ,EAAE,EAAE;MACJA,EAAE,CAACD,MAAM,CAACK,GAAG,CAAC,CAAC;IACnB;IACA,OAAOL,MAAM,CAACK,GAAG,CAAC;EACtB,CAAC,CAAC;AACN;AACA;AACA,SAASC,oBAAoBA,CAAA,EAAG;EAC5B,OAAO;IAAEC,SAAS,EAAE,CAAC;IAAEC,SAAS,EAAE,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEC,QAAQ,EAAE,CAAC;IAAEC,aAAa,EAAE,CAAC;IAAEC,OAAO,EAAE;EAAE,CAAC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,CAAC;EACpB;AACJ;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAAA,EAAiF;IAAA,IAAAC,KAAA;IAAA,IAAhFC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG9B,QAAQ,CAACiC,MAAM;IAAA,IAAEC,aAAa,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGvB,WAAW;IAAA,IAAE4B,OAAO,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAAA,IAAEL,OAAO,GAAAK,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IACtFvE,qBAAqB,CAAC2E,GAAG,CAAC,IAAI,CAAC;IAC/B1E,qBAAqB,CAAC2E,GAAG,CAAC,IAAI,EAAE,IAAIpC,QAAQ,EAAE,CAAC;IAC/CtC,iBAAiB,CAAC0E,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACnCzE,qBAAqB,CAACyE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACvCxE,mBAAmB,CAACwE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACrCvE,wBAAwB,CAACuE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC1CtE,oBAAoB,CAACsE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IAClCrE,0BAA0B,CAACqE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC5CpE,iBAAiB,CAACoE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACnCnE,wBAAwB,CAACmE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACtClE,yBAAyB,CAACkE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3CjE,yBAAyB,CAACiE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3ChE,yBAAyB,CAACgE,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC3C/D,uBAAuB,CAAC+D,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IACxC9D,yBAAyB,CAAC8D,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACvC7D,qBAAqB,CAAC6D,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACrC5D,qBAAqB,CAAC4D,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACvC3D,mBAAmB,CAAC2D,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACrCzD,gBAAgB,CAACyD,GAAG,CAAC,IAAI,EAAE,UAACC,IAAI,EAAc;MAAA,SAAAC,IAAA,GAAAT,SAAA,CAAAC,MAAA,EAATS,IAAI,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;QAAJF,IAAI,CAAAE,IAAA,QAAAZ,SAAA,CAAAY,IAAA;MAAA;MACrCrD,sBAAsB,CAACuC,KAAI,EAAE9D,wBAAwB,EAAE,GAAG,CAAC,CAAC6E,IAAI,CAACL,IAAI,EAAE,GAAGE,IAAI,CAAC;IACnF,CAAC,CAAC;IACF3D,yBAAyB,CAACwD,GAAG,CAAC,IAAI,EAAGO,KAAK,IAAK;MAC3C,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAAE,qBAAoB,IAAI,CAACjB,QAAS,KAAIe,KAAK,CAACG,IAAK,MAAKH,KAAK,CAACI,MAAM,IAAI9C,gBAAgB,CAAC0C,KAAK,CAACG,IAAI,CAAE,EAAC,CAAC;MAC9H,IAAI1D,sBAAsB,CAAC,IAAI,EAAElB,yBAAyB,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE;QAClEuC,CAAC,CAACmC,KAAK,CAACA,KAAK,CAACI,OAAO,CAAC;MAC1B;MACA3D,sBAAsB,CAAC,IAAI,EAAEhB,uBAAuB,EAAE,KAAK,EAAE,GAAG,CAAC;MACjE,IAAIe,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,EAAE;QAC1DY,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAACyE,OAAO,GAAG,IAAI;QACvE7D,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC0E,OAAO,GAAG,IAAI;QACvE9D,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC2E,SAAS,GAAG,IAAI;QACzE/D,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC4E,MAAM,GAAG,IAAI;QACtE/D,sBAAsB,CAAC,IAAI,EAAEb,qBAAqB,EAAE,IAAI,EAAE,GAAG,CAAC;MAClE;MACA,IAAIY,sBAAsB,CAAC,IAAI,EAAEb,qBAAqB,EAAE,GAAG,CAAC,EAAE;QAC1D8E,aAAa,CAACjE,sBAAsB,CAAC,IAAI,EAAEb,qBAAqB,EAAE,GAAG,CAAC,CAAC;QACvEc,sBAAsB,CAAC,IAAI,EAAEd,qBAAqB,EAAE,IAAI,EAAE,GAAG,CAAC;MAClE;MACA;MACAmC,WAAW,CAACtB,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,EAAGwF,CAAC,IAAK;QACxE,IAAI;UACAA,CAAC,CAACC,QAAQ,CAACX,KAAK,EAAEb,SAAS,CAAC;QAChC,CAAC,CACD,OAAOyB,GAAG,EAAE;UACR;UACA/C,CAAC,CAACmC,KAAK,CAACY,GAAG,CAAC;QAChB;MACJ,CAAC,CAAC;MACF9C,WAAW,CAACtB,sBAAsB,CAAC,IAAI,EAAEnB,wBAAwB,EAAE,GAAG,CAAC,CAAC;MACxE;MACAoB,sBAAsB,CAAC,IAAI,EAAEjB,yBAAyB,EAAE6C,oBAAoB,EAAE,EAAE,GAAG,CAAC;MACpF7B,sBAAsB,CAAC,IAAI,EAAET,gBAAgB,EAAE,GAAG,CAAC,CAAC8E,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC;MAC9E,IAAIrE,sBAAsB,CAAC,IAAI,EAAElB,yBAAyB,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE;QAClEwF,UAAU,CAAC,MAAM;UACb,IAAI,CAACC,gBAAgB,EAAE,CAACC,KAAK,CAAC,MAAM;YAChC;UAAA,CACH,CAAC;QACN,CAAC,EAAExE,sBAAsB,CAAC,IAAI,EAAElB,yBAAyB,EAAE,GAAG,CAAC,CAAC;MACpE;IACJ,CAAC,CAAC;IACFW,yBAAyB,CAACuD,GAAG,CAAC,IAAI,EAAGQ,KAAK,IAAK;MAC3CnC,CAAC,CAACoD,KAAK,CAAC,MAAM,CAAC,cAAc,EAAEjB,KAAK,CAAC,CAAC;MACtCxD,sBAAsB,CAAC,IAAI,EAAET,gBAAgB,EAAE,GAAG,CAAC,CAAC8E,IAAI,CAAC,IAAI,EAAE,OAAO,EAAEb,KAAK,CAAC;IAClF,CAAC,CAAC;IACF9D,2BAA2B,CAACsD,GAAG,CAAC,IAAI,EAAGY,OAAO,IAAK;MAC/CvC,CAAC,CAACoD,KAAK,CAAC,MAAM,CAAC,UAAU,EAAEb,OAAO,CAACc,IAAI,CAAC,CAAC;MACzC1E,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAAC8C,SAAS,IAAI8B,OAAO,CAACc,IAAI,CAAChC,MAAM;MAC7F1C,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAAC7C,SAAS,IAAI8B,OAAO,CAACc,IAAI,CAAChC,MAAM;MAC3F,MAAMkC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAAClB,OAAO,CAACc,IAAI,CAAC;MACzC,OAAOrE,WAAW,CAACuE,QAAQ,CAACG,MAAM,CAAC,GAC7B/E,sBAAsB,CAAC,IAAI,EAAEL,iCAAiC,EAAE,GAAG,CAAC,CAAC0E,IAAI,CAAC,IAAI,EAAEO,QAAQ,CAAC,GACzF5E,sBAAsB,CAAC,IAAI,EAAEJ,oCAAoC,EAAE,GAAG,CAAC,CAACyE,IAAI,CAAC,IAAI,EAAEO,QAAQ,CAAC;IACtG,CAAC,CAAC;IACFjF,iCAAiC,CAACqD,GAAG,CAAC,IAAI,EAAG4B,QAAQ,IAAK;MACtD,MAAMI,OAAO,GAAGhF,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,CAACkG,QAAQ,CAACK,EAAE,CAAC;MACpF,IAAI,CAACD,OAAO,EAAE;QACV3D,CAAC,CAACoD,KAAK,CAAC,MAAO,iCAAgCG,QAAQ,CAACK,EAAG,EAAC,CAAC;QAC7D;MACJ;MACA,IAAI;QACA,MAAM;UAAEF,MAAM;UAAEG,MAAM;UAAEC;QAAa,CAAC,GAAGH,OAAO;QAChD,MAAMI,MAAM,GAAGpF,sBAAsB,CAAC,IAAI,EAAE1B,iBAAiB,EAAE,GAAG,CAAC,CAAC+G,cAAc,CAACT,QAAQ,CAAC;QAC5F;QACA;QACAI,OAAO,CAACb,QAAQ,CAAC,IAAI,EAAEiB,MAAM,CAAC;QAC9B,IAAID,YAAY,EAAE;UACd,MAAMG,KAAK,GAAI,GAAEH,YAAY,CAAClC,IAAK,KAAImC,MAAO,EAAC;UAC/CpF,sBAAsB,CAAC,IAAI,EAAEd,yBAAyB,EAAE,GAAG,CAAC,CAACoG,KAAK,CAAC,GAAG/E,YAAY,CAAC,CAAC,CAAC,EAAE4E,YAAY,EAAE;YACjGJ,MAAM;YACNG;UACJ,CAAC,CAAC;UACF;UACA,IAAIlF,sBAAsB,CAAC,IAAI,EAAEnB,wBAAwB,EAAE,GAAG,CAAC,CAACyG,KAAK,CAAC,EAAE;YACpEtF,sBAAsB,CAAC,IAAI,EAAEJ,oCAAoC,EAAE,GAAG,CAAC,CAACyE,IAAI,CAAC,IAAI,EAAErE,sBAAsB,CAAC,IAAI,EAAEnB,wBAAwB,EAAE,GAAG,CAAC,CAACyG,KAAK,CAAC,CAAC;UAC1J;QACJ;MACJ,CAAC,CACD,OAAO9B,KAAK,EAAE;QACVxD,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAACiD,MAAM,EAAE;QACrEjC,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAAC1C,MAAM,EAAE;QACnE+C,OAAO,CAACb,QAAQ,CAACX,KAAK,EAAEb,SAAS,CAAC;MACtC;MACA,OAAO3C,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,CAACkG,QAAQ,CAACK,EAAE,CAAC;IAC/E,CAAC,CAAC;IACFrF,oCAAoC,CAACoD,GAAG,CAAC,IAAI,EAAG4B,QAAQ,IAAK;MACzD,MAAMG,MAAM,GAAGjE,OAAO,CAAC8D,QAAQ,CAACG,MAAM,CAAC,IAAIH,QAAQ,CAACG,MAAM,IAAI,SAAS;MACvE,MAAMO,KAAK,GAAI,GAAEP,MAAO,KAAIH,QAAQ,CAACM,MAAM,CAACC,YAAa,EAAC;MAC1D,MAAMH,OAAO,GAAGhF,sBAAsB,CAAC,IAAI,EAAEd,yBAAyB,EAAE,GAAG,CAAC,CAACoG,KAAK,CAAC;MACnF,IAAI,CAACN,OAAO,EAAE;QACV;QACAhF,sBAAsB,CAAC,IAAI,EAAEnB,wBAAwB,EAAE,GAAG,CAAC,CAACyG,KAAK,CAAC,GAAGV,QAAQ;QAC7EvD,CAAC,CAACoD,KAAK,CAAC,MAAO,2CAA0Ca,KAAM,EAAC,CAAC;QACjE;MACJ;MACA;MACA,OAAOtF,sBAAsB,CAAC,IAAI,EAAEnB,wBAAwB,EAAE,GAAG,CAAC,CAACyG,KAAK,CAAC;MACzE,IAAI;QACA,MAAMF,MAAM,GAAGpF,sBAAsB,CAAC,IAAI,EAAE1B,iBAAiB,EAAE,GAAG,CAAC,CAAC+G,cAAc,CAACT,QAAQ,CAAC;QAC5FI,OAAO,CAACb,QAAQ,CAAC,IAAI,EAAEiB,MAAM,CAAC;MAClC,CAAC,CACD,OAAO5B,KAAK,EAAE;QACVxD,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAACiD,MAAM,EAAE;QACrEjC,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAAC1C,MAAM,EAAE;QACnE+C,OAAO,CAACb,QAAQ,CAACX,KAAK,EAAEb,SAAS,CAAC;MACtC;IACJ,CAAC,CAAC;IACF9C,wBAAwB,CAACmD,GAAG,CAAC,IAAI,EAAE,MAAM;MACrC,IAAIhD,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,KAAK,IAAI,EAAE;QACnE,MAAM,IAAIqE,KAAK,CAAC,oCAAoC,CAAC;MACzD;MACApC,CAAC,CAACoD,KAAK,CAAC,MAAM,CAAC,cAAc,EAAE,IAAI,CAACjC,QAAQ,CAAC,CAAC;MAC9CvC,sBAAsB,CAAC,IAAI,EAAEhB,uBAAuB,EAAE,IAAI,EAAE,GAAG,CAAC;MAChEe,sBAAsB,CAAC,IAAI,EAAEF,uBAAuB,EAAE,GAAG,CAAC,CAACuE,IAAI,CAAC,IAAI,CAAC;MACrErE,sBAAsB,CAAC,IAAI,EAAET,gBAAgB,EAAE,GAAG,CAAC,CAAC8E,IAAI,CAAC,IAAI,EAAE,WAAW,CAAC;MAC3E,OAAO,IAAI;IACf,CAAC,CAAC;IACFvE,uBAAuB,CAACkD,GAAG,CAAC,IAAI,EAAE,MAAM;MACpC,MAAMb,aAAa,GAAGnC,sBAAsB,CAAC,IAAI,EAAEd,yBAAyB,EAAE,GAAG,CAAC;MAClFe,sBAAsB,CAAC,IAAI,EAAEf,yBAAyB,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC;MAChEqG,OAAO,CAACC,GAAG,CAAC/D,MAAM,CAACC,IAAI,CAACS,aAAa,CAAC,CAACsD,GAAG,CAAC,MAAOR,EAAE,IAAK;QACrD,MAAM;UAAEd,QAAQ;UAAEY,MAAM;UAAEG,MAAM;UAAEjC;QAAK,CAAC,GAAGd,aAAa,CAAC8C,EAAE,CAAC;QAC5D;QACA;QACA;QACA,IAAIhC,IAAI,CAACyC,UAAU,CAAC,SAAS,CAAC,EAAE;UAC5B;QACJ;QACA,IAAI;UACA,MAAM,IAAI,CAACC,SAAS,CAAC1C,IAAI,EAAE8B,MAAM,EAAEG,MAAM,EAAEf,QAAQ,CAAC;QACxD,CAAC,CACD,OAAOX,KAAK,EAAE;UACVnC,CAAC,CAACmC,KAAK,CAACA,KAAK,CAAC;QAClB;MACJ,CAAC,CAAC,CAAC,CAACgB,KAAK,CAACnD,CAAC,CAACmC,KAAK,CAAC;IACtB,CAAC,CAAC;IACFzD,2BAA2B,CAACiD,GAAG,CAAC,IAAI,EAAE,MAAM;MACxC,MAAM4C,GAAG,GAAGC,IAAI,CAACD,GAAG,EAAE;MACtB,MAAME,GAAG,GAAGrE,MAAM,CAACC,IAAI,CAAC1B,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,CAAC;MAChF,KAAK,IAAIqH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,CAACpD,MAAM,EAAEqD,CAAC,EAAE,EAAE;QACjC,MAAMf,OAAO,GAAGhF,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,CAACoH,GAAG,CAACC,CAAC,CAAC,CAAC;QAC/E,IAAKH,GAAG,GAAGZ,OAAO,CAACgB,KAAK,GAAIhG,sBAAsB,CAAC,IAAI,EAAEX,mBAAmB,EAAE,GAAG,CAAC,EAAE;UAChF,IAAI;YACA2F,OAAO,CAACb,QAAQ,CAAC,IAAIV,KAAK,CAAE,6CAA4CzD,sBAAsB,CAAC,IAAI,EAAEX,mBAAmB,EAAE,GAAG,CAAC,GAAG,IAAK,GAAE,CAAC,EAAEsD,SAAS,CAAC;UACzJ,CAAC,CACD,MAAM;YACF;UAAA;UAEJ3C,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAACoD,OAAO,EAAE;UACtEpC,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAACvC,OAAO,EAAE;UACpE,OAAOpC,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,CAACoH,GAAG,CAACC,CAAC,CAAC,CAAC;QAC1E;MACJ;IACJ,CAAC,CAAC;IACF,MAAME,SAAS,GAAG7C,KAAK,CAAC8C,OAAO,CAAC1D,QAAQ,CAAC,GACnCA,QAAQ,GACR,CAACA,QAAQ,CAAC;IAChB,IAAIyD,SAAS,CAACvD,MAAM,KAAK,CAAC,EAAE;MACxB,MAAM,IAAIe,KAAK,CAAC,2CAA2C,CAAC;IAChE;IACAwC,SAAS,CAACtE,OAAO,CAAEa,QAAQ,IAAK;MAC5B,IAAI,CAAC,gBAAgB,CAAC2D,IAAI,CAAC3D,QAAQ,CAAC,EAAE;QAClC,MAAM,IAAIiB,KAAK,CAAE,iDAAgDjB,QAAS,GAAE,CAAC;MACjF;IACJ,CAAC,CAAC;IACFvC,sBAAsB,CAAC,IAAI,EAAExB,wBAAwB,EAAE,IAAIyB,YAAY,EAAE,EAAE,GAAG,CAAC;IAC/ED,sBAAsB,CAAC,IAAI,EAAEnB,yBAAyB,EAAE+D,aAAa,IAAI,CAAC,EAAE,GAAG,CAAC;IAChF5C,sBAAsB,CAAC,IAAI,EAAE3B,iBAAiB,EAAE,IAAIoC,QAAQ,EAAE,EAAE,GAAG,CAAC;IACpET,sBAAsB,CAAC,IAAI,EAAElB,yBAAyB,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC;IAChEkB,sBAAsB,CAAC,IAAI,EAAE1B,qBAAqB,EAAE0H,SAAS,EAAE,GAAG,CAAC;IACnEhG,sBAAsB,CAAC,IAAI,EAAEzB,mBAAmB,EAAEsE,OAAO,EAAE,GAAG,CAAC;IAC/D7C,sBAAsB,CAAC,IAAI,EAAEb,qBAAqB,EAAE,IAAI,EAAE,GAAG,CAAC;IAC9Da,sBAAsB,CAAC,IAAI,EAAErB,iBAAiB,EAAE;MAC5CwH,MAAM,EAAE;QAAElE,QAAQ,EAAE,CAAC;QAAEC,aAAa,EAAE;MAAE,CAAC;MACzCwC,KAAK,EAAE9C,oBAAoB;IAC/B,CAAC,EAAE,GAAG,CAAC;IACP5B,sBAAsB,CAAC,IAAI,EAAEjB,yBAAyB,EAAE6C,oBAAoB,EAAE,EAAE,GAAG,CAAC;IACpF5B,sBAAsB,CAAC,IAAI,EAAEZ,mBAAmB,EAAE+C,OAAO,IAAIjB,kBAAkB,EAAE,GAAG,CAAC;IACrF,IAAI0B,aAAa,IAAIA,aAAa,GAAG,CAAC,EAAE;MACpC,IAAI,CAAC0B,gBAAgB,EAAE,CAACC,KAAK,CAAC,MAAM;QAChC;MAAA,CACH,CAAC;IACN;IACAvE,sBAAsB,CAAC,IAAI,EAAEtB,0BAA0B,EAAE,IAAI4G,OAAO,CAAEc,OAAO,IAAK;MAC9ErG,sBAAsB,CAAC,IAAI,EAAEvB,wBAAwB,EAAE,GAAG,CAAC,CAAC6H,IAAI,CAAC,WAAW,EAAE,MAAM;QAChFD,OAAO,CAAC,IAAI,CAAC;MACjB,CAAC,CAAC;IACN,CAAC,CAAC,EAAE,GAAG,CAAC;EACZ;EACA;AACJ;AACA;EACI,IAAIE,gBAAgBA,CAAA,EAAG;IACnB,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACI,IAAIC,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI,IAAIC,WAAWA,CAAA,EAAG;IACd,OAAOzG,sBAAsB,CAAC,IAAI,EAAEf,uBAAuB,EAAE,GAAG,CAAC;EACrE;EACA;AACJ;AACA;EACI,IAAIyH,OAAOA,CAAA,EAAG;IACV,OAAO1G,sBAAsB,CAAC,IAAI,EAAErB,0BAA0B,EAAE,GAAG,CAAC;EACxE;EACA,IAAI6D,QAAQA,CAAA,EAAG;IACX,OAAOxC,sBAAsB,CAAC,IAAI,EAAEzB,qBAAqB,EAAE,GAAG,CAAC,CAACyB,sBAAsB,CAAC,IAAI,EAAEjB,yBAAyB,EAAE,GAAG,CAAC,CAAC;EACjI;EACA;AACJ;AACA;EACI4H,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAItE,UAAU,CAACrC,sBAAsB,CAAC,IAAI,EAAEzB,qBAAqB,EAAE,GAAG,CAAC,CAAC;EACnF;EACAqI,mBAAmBA,CAACX,SAAS,EAAE;IAC3B,OAAO,CAACjG,sBAAsB,CAAC,IAAI,EAAEjB,yBAAyB,EAAE,GAAG,CAAC,GAAG,CAAC,IAAIkH,SAAS,CAACvD,MAAM;EAChG;EACA;AACJ;AACA;AACA;AACA;EACI;EACA,MAAMmE,OAAOA,CAAA,EAAG;IACZ,IAAI7G,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,EAAE;MAC1D,MAAM,IAAIqE,KAAK,CAAC,gCAAgC,CAAC;IACrD;IACA,IAAI;MACAxD,sBAAsB,CAAC,IAAI,EAAElB,yBAAyB,EAAE,IAAI,CAAC6H,mBAAmB,CAAC5G,sBAAsB,CAAC,IAAI,EAAEzB,qBAAqB,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;MAChJ;MACA0B,sBAAsB,CAAC,IAAI,EAAEb,qBAAqB,EAAE,OAAOoB,OAAO,CAACC,SAAS,KAAK,WAAW,IAAIN,YAAY,CAACK,OAAO,CAACC,SAAS,EAAEA,SAAS,CAAC,GACpI,IAAIA,SAAS,CAAC,IAAI,CAAC+B,QAAQ;MAC7B;MACA;MAAA,EACE,IAAI/B,SAAS,CAAC,IAAI,CAAC+B,QAAQ,EAAEG,SAAS,EAAE;QACtCG,OAAO,EAAE9C,sBAAsB,CAAC,IAAI,EAAExB,mBAAmB,EAAE,GAAG;MAClE,CAAC,CAAC,EAAE,GAAG,CAAC;MACZ,IAAIwB,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,EAAE;QAC1DY,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAACyE,OAAO,GAAG7D,sBAAsB,CAAC,IAAI,EAAER,yBAAyB,EAAE,GAAG,CAAC;QAC/HQ,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC0E,OAAO,GAAG9D,sBAAsB,CAAC,IAAI,EAAEP,yBAAyB,EAAE,GAAG,CAAC;QAC/HO,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC2E,SAAS,GAAG/D,sBAAsB,CAAC,IAAI,EAAEN,2BAA2B,EAAE,GAAG,CAAC;QACnIM,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC4E,MAAM,GAAGhE,sBAAsB,CAAC,IAAI,EAAEH,wBAAwB,EAAE,GAAG,CAAC;MACjI;MACA;MACAI,sBAAsB,CAAC,IAAI,EAAEd,qBAAqB,EAAE2H,WAAW,CAAC,MAAM9G,sBAAsB,CAAC,IAAI,EAAED,2BAA2B,EAAE,GAAG,CAAC,CAACsE,IAAI,CAAC,IAAI,CAAC,EAAEjD,gBAAgB,CAAC,EAAE,GAAG,CAAC;IAC5K,CAAC,CACD,OAAOoC,KAAK,EAAE;MACVnC,CAAC,CAACmC,KAAK,CAACA,KAAK,CAAC;MACdxD,sBAAsB,CAAC,IAAI,EAAET,gBAAgB,EAAE,GAAG,CAAC,CAAC8E,IAAI,CAAC,IAAI,EAAE,OAAO,EAAEb,KAAK,CAAC;MAC9E,MAAMA,KAAK;IACf;EACJ;EACA;AACJ;AACA;EACI,MAAMe,gBAAgBA,CAAA,EAAG;IACrB,IAAIvE,sBAAsB,CAAC,IAAI,EAAElB,yBAAyB,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE;MAClE,IAAI;QACA,MAAM,IAAI,CAAC+H,OAAO,EAAE;MACxB,CAAC,CACD,MAAM;QACFvC,UAAU,CAAC,MAAM;UACb,IAAI,CAACC,gBAAgB,EAAE,CAACC,KAAK,CAAC,MAAM;YAChC;UAAA,CACH,CAAC;QACN,CAAC,EAAExE,sBAAsB,CAAC,IAAI,EAAElB,yBAAyB,EAAE,GAAG,CAAC,CAAC;MACpE;IACJ;EACJ;EACA;AACJ;AACA;EACI;EACA,MAAMiI,UAAUA,CAAA,EAAG;IACf;IACA9G,sBAAsB,CAAC,IAAI,EAAEnB,yBAAyB,EAAE,CAAC,EAAE,GAAG,CAAC;IAC/D,IAAI;MACA,IAAIkB,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,EAAE;QAC1D;QACAY,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC4H,KAAK,CAAC,IAAI,CAAC;MACxE;IACJ,CAAC,CACD,OAAOxD,KAAK,EAAE;MACVnC,CAAC,CAACmC,KAAK,CAACA,KAAK,CAAC;MACdxD,sBAAsB,CAAC,IAAI,EAAET,gBAAgB,EAAE,GAAG,CAAC,CAAC8E,IAAI,CAAC,IAAI,EAAE,OAAO,EAAEb,KAAK,CAAC;MAC9E,MAAMA,KAAK;IACf;EACJ;EACA;AACJ;AACA;EACI,IAAIyD,KAAKA,CAAA,EAAG;IACR,OAAO;MACHb,MAAM,EAAE;QACJlE,QAAQ,EAAET,MAAM,CAACC,IAAI,CAAC1B,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,CAAC,CAACgE,MAAM;QACrFP,aAAa,EAAEV,MAAM,CAACC,IAAI,CAAC1B,sBAAsB,CAAC,IAAI,EAAEd,yBAAyB,EAAE,GAAG,CAAC,CAAC,CAACwD;MAC7F,CAAC;MACDiC,KAAK,EAAE3E,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F;IAChE,CAAC;EACL;EACA,IAAIuC,aAAaA,CAAA,EAAG;IAChB,OAAOlH,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC;EACvE;EACA;AACJ;AACA;AACA;AACA;AACA;EACImI,EAAEA,CAAClE,IAAI,EAAEmE,GAAG,EAAE;IACVpH,sBAAsB,CAAC,IAAI,EAAEvB,wBAAwB,EAAE,GAAG,CAAC,CAAC0I,EAAE,CAAClE,IAAI,EAAEmE,GAAG,CAAC;IACzE,OAAO,MAAM;MACTpH,sBAAsB,CAAC,IAAI,EAAEvB,wBAAwB,EAAE,GAAG,CAAC,CAAC4I,cAAc,CAACpE,IAAI,EAAEmE,GAAG,CAAC;IACzF,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,IAAIA,CAACvC,MAAM,EAAEG,MAAM,EAAEqC,WAAW,EAAEpC,YAAY,EAAE;IAC5CnF,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAACkD,QAAQ,EAAE;IACvElC,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAACzC,QAAQ,EAAE;IACrE,MAAM,CAAC+C,EAAE,EAAEuC,IAAI,CAAC,GAAGxH,sBAAsB,CAAC,IAAI,EAAE1B,iBAAiB,EAAE,GAAG,CAAC,CAACmJ,UAAU,CAAC1C,MAAM,EAAEG,MAAM,CAAC;IAClG,IAAIwC,aAAa,GAAGH,WAAW,GACzBvH,sBAAsB,CAAC,IAAI,EAAE3B,qBAAqB,EAAE,GAAG,CAAC,CAACsJ,GAAG,CAACH,IAAI,CAAC,GAClE,IAAI;IACV,IAAI,CAACE,aAAa,EAAE;MAChBA,aAAa,GAAG1H,sBAAsB,CAAC,IAAI,EAAE5B,qBAAqB,EAAE,GAAG,EAAEkB,gBAAgB,CAAC,CAAC+E,IAAI,CAAC,IAAI,EAAEY,EAAE,EAAEuC,IAAI,EAAEzC,MAAM,EAAEG,MAAM,EAAEC,YAAY,CAAC;MAC7I,IAAIoC,WAAW,EAAE;QACbvH,sBAAsB,CAAC,IAAI,EAAE3B,qBAAqB,EAAE,GAAG,CAAC,CAAC2E,GAAG,CAACwE,IAAI,EAAEE,aAAa,CAAC;MACrF;IACJ,CAAC,MACI;MACD1H,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAACgD,MAAM,EAAE;MACrEhC,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAAC3C,MAAM,EAAE;IACvE;IACA,OAAO0F,aAAa;EACxB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI/B,SAASA,CAAC1C,IAAI,EAAE8B,MAAM,EAAEG,MAAM,EAAEf,QAAQ,EAAE;IACtCnE,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAACmD,aAAa,EAAE;IAC5EnC,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAACxC,aAAa,EAAE;IAC1E;IACA,OAAO,IAAI,CAACmF,IAAI,CAACvC,MAAM,EAAEG,MAAM,EAAE,KAAK,EAAE;MAAEf,QAAQ;MAAElB;IAAK,CAAC,CAAC;EAC/D;EACA;AACJ;AACA;EACI,MAAM2E,WAAWA,CAAC3E,IAAI,EAAE8B,MAAM,EAAEE,EAAE,EAAE;IAChC,MAAME,YAAY,GAAI,GAAElC,IAAK,KAAIgC,EAAG,EAAC;IACrC;IACA;IACA;IACA;IACA,IAAI5E,WAAW,CAACL,sBAAsB,CAAC,IAAI,EAAEd,yBAAyB,EAAE,GAAG,CAAC,CAACiG,YAAY,CAAC,CAAC,EAAE;MACzF9D,CAAC,CAACoD,KAAK,CAAC,MAAO,sCAAqCU,YAAa,EAAC,CAAC;MACnE,OAAO,KAAK;IAChB;IACA,OAAOnF,sBAAsB,CAAC,IAAI,EAAEd,yBAAyB,EAAE,GAAG,CAAC,CAACiG,YAAY,CAAC;IACjF,IAAI;MACA,OAAO,IAAI,CAACsB,WAAW,IAAI,CAACrG,MAAM,CAACJ,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAAC,GACtF,IAAI,CAACkI,IAAI,CAACvC,MAAM,EAAE,CAACE,EAAE,CAAC,CAAC,GACvB,IAAI;IACd,CAAC,CACD,MAAM;MACF,OAAO,KAAK;IAChB;EACJ;AACJ;AACA5G,qBAAqB,GAAG,IAAIwJ,OAAO,EAAE,EAAEvJ,iBAAiB,GAAG,IAAIuJ,OAAO,EAAE,EAAEtJ,qBAAqB,GAAG,IAAIsJ,OAAO,EAAE,EAAErJ,mBAAmB,GAAG,IAAIqJ,OAAO,EAAE,EAAEpJ,wBAAwB,GAAG,IAAIoJ,OAAO,EAAE,EAAEnJ,oBAAoB,GAAG,IAAImJ,OAAO,EAAE,EAAElJ,0BAA0B,GAAG,IAAIkJ,OAAO,EAAE,EAAEjJ,iBAAiB,GAAG,IAAIiJ,OAAO,EAAE,EAAEhJ,wBAAwB,GAAG,IAAIgJ,OAAO,EAAE,EAAE/I,yBAAyB,GAAG,IAAI+I,OAAO,EAAE,EAAE9I,yBAAyB,GAAG,IAAI8I,OAAO,EAAE,EAAE7I,yBAAyB,GAAG,IAAI6I,OAAO,EAAE,EAAE5I,uBAAuB,GAAG,IAAI4I,OAAO,EAAE,EAAE3I,yBAAyB,GAAG,IAAI2I,OAAO,EAAE,EAAE1I,qBAAqB,GAAG,IAAI0I,OAAO,EAAE,EAAEzI,qBAAqB,GAAG,IAAIyI,OAAO,EAAE,EAAExI,mBAAmB,GAAG,IAAIwI,OAAO,EAAE,EAAEtI,gBAAgB,GAAG,IAAIsI,OAAO,EAAE,EAAErI,yBAAyB,GAAG,IAAIqI,OAAO,EAAE,EAAEpI,yBAAyB,GAAG,IAAIoI,OAAO,EAAE,EAAEnI,2BAA2B,GAAG,IAAImI,OAAO,EAAE,EAAElI,iCAAiC,GAAG,IAAIkI,OAAO,EAAE,EAAEjI,oCAAoC,GAAG,IAAIiI,OAAO,EAAE,EAAEhI,wBAAwB,GAAG,IAAIgI,OAAO,EAAE,EAAE/H,uBAAuB,GAAG,IAAI+H,OAAO,EAAE,EAAE9H,2BAA2B,GAAG,IAAI8H,OAAO,EAAE,EAAEzJ,qBAAqB,GAAG,IAAI0J,OAAO,EAAE,EAAExI,gBAAgB,GAAG,eAAeA,gBAAgBA,CAAC2F,EAAE,EAAEuC,IAAI,EAAEzC,MAAM,EAAEG,MAAM,EAAEC,YAAY,EAAE;EACnrC,OAAO,IAAII,OAAO,CAAC,CAACc,OAAO,EAAE0B,MAAM,KAAK;IACpC,IAAI;MACA,IAAI,CAAC,IAAI,CAACtB,WAAW,IAAIzG,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,KAAK,IAAI,EAAE;QACxF,MAAM,IAAIqE,KAAK,CAAC,4BAA4B,CAAC;MACjD;MACA,MAAMU,QAAQ,GAAGA,CAACX,KAAK,EAAE4B,MAAM,KAAK;QAChC5B,KAAK,GACCuE,MAAM,CAACvE,KAAK,CAAC,GACb6C,OAAO,CAACjB,MAAM,CAAC;MACzB,CAAC;MACD/D,CAAC,CAACoD,KAAK,CAAC,MAAM,CAAC,SAAS,EAAEM,MAAM,EAAEyC,IAAI,CAAC,CAAC;MACxCxH,sBAAsB,CAAC,IAAI,EAAEtB,oBAAoB,EAAE,GAAG,CAAC,CAACuG,EAAE,CAAC,GAAG;QAC1Dd,QAAQ;QACRY,MAAM;QACNG,MAAM;QACNc,KAAK,EAAEH,IAAI,CAACD,GAAG,EAAE;QACjBT;MACJ,CAAC;MACDnF,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAAC+C,SAAS,IAAIyF,IAAI,CAAC9E,MAAM;MACrF1C,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAAC5C,SAAS,IAAIyF,IAAI,CAAC9E,MAAM;MACnF1C,sBAAsB,CAAC,IAAI,EAAEZ,qBAAqB,EAAE,GAAG,CAAC,CAACkI,IAAI,CAACE,IAAI,CAAC;IACvE,CAAC,CACD,OAAOhE,KAAK,EAAE;MACVxD,sBAAsB,CAAC,IAAI,EAAEhB,yBAAyB,EAAE,GAAG,CAAC,CAACiD,MAAM,EAAE;MACrEjC,sBAAsB,CAAC,IAAI,EAAEpB,iBAAiB,EAAE,GAAG,CAAC,CAAC+F,KAAK,CAAC1C,MAAM,EAAE;MACnE8F,MAAM,CAACvE,KAAK,CAAC;IACjB;EACJ,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}