{"ast":null,"code":"var _BitVec_decodedLength, _BitVec_isMsb;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8aLim, compactToU8a, isString, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\n/** @internal */\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return [0, new Uint8Array()];\n  }\n  // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n  const [offset, length] = compactFromU8aLim(value);\n  const total = offset + Math.ceil(length / 8);\n  if (total > value.length) {\n    throw new Error(`BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  }\n  return [length, value.subarray(offset, total)];\n}\n/** @internal */\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    const u8a = u8aToU8a(value);\n    return [u8a.length / 8, u8a];\n  }\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\nexport class BitVec extends Raw {\n  // In lieu of having the Msb/Lsb identifiers passed through, we default to assuming\n  // we are dealing with Lsb, which is the default (as of writing) BitVec format used\n  // in the Polkadot code (this only affects the toHuman displays)\n  constructor(registry, value) {\n    let isMsb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const [decodedLength, u8a] = decodeBitVec(value);\n    super(registry, u8a);\n    _BitVec_decodedLength.set(this, void 0);\n    _BitVec_isMsb.set(this, void 0);\n    __classPrivateFieldSet(this, _BitVec_decodedLength, decodedLength, \"f\");\n    __classPrivateFieldSet(this, _BitVec_isMsb, isMsb, \"f\");\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.length + compactToU8a(__classPrivateFieldGet(this, _BitVec_decodedLength, \"f\")).length;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [compactToU8a(__classPrivateFieldGet(this, _BitVec_decodedLength, \"f\")), super.toU8a()]\n    };\n  }\n  /**\n   * @description Creates a boolean array of the bit values\n   */\n  toBoolArray() {\n    const map = [...this.toU8a(true)].map(v => [!!(v & 128), !!(v & 64), !!(v & 32), !!(v & 16), !!(v & 8), !!(v & 4), !!(v & 2), !!(v & 1)]);\n    const result = new Array(8 * map.length);\n    for (let i = 0; i < map.length; i++) {\n      const off = i * 8;\n      const v = map[i];\n      for (let j = 0; j < 8; j++) {\n        result[off + j] = __classPrivateFieldGet(this, _BitVec_isMsb, \"f\") ? v[j] : v[7 - j];\n      }\n    }\n    return result;\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return `0b${[...this.toU8a(true)].map(d => `00000000${d.toString(2)}`.slice(-8)).map(s => __classPrivateFieldGet(this, _BitVec_isMsb, \"f\") ? s : s.split('').reverse().join('')).join('_')}`;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'BitVec';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const bitVec = super.toU8a(isBare);\n    return isBare ? bitVec : u8aConcatStrict([compactToU8a(__classPrivateFieldGet(this, _BitVec_decodedLength, \"f\")), bitVec]);\n  }\n}\n_BitVec_decodedLength = new WeakMap(), _BitVec_isMsb = new WeakMap();","map":{"version":3,"names":["_BitVec_decodedLength","_BitVec_isMsb","__classPrivateFieldGet","__classPrivateFieldSet","compactFromU8aLim","compactToU8a","isString","u8aConcatStrict","u8aToU8a","Raw","decodeBitVecU8a","value","length","Uint8Array","offset","total","Math","ceil","Error","subarray","decodeBitVec","Array","isArray","u8a","BitVec","constructor","registry","isMsb","arguments","undefined","decodedLength","set","encodedLength","inspect","outer","toU8a","toBoolArray","map","v","result","i","off","j","toHuman","d","toString","slice","s","split","reverse","join","toRawType","isBare","bitVec","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/extended/BitVec.js"],"sourcesContent":["var _BitVec_decodedLength, _BitVec_isMsb;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8aLim, compactToU8a, isString, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\n/** @internal */\nfunction decodeBitVecU8a(value) {\n    if (!value || !value.length) {\n        return [0, new Uint8Array()];\n    }\n    // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + Math.ceil(length / 8);\n    if (total > value.length) {\n        throw new Error(`BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [length, value.subarray(offset, total)];\n}\n/** @internal */\nfunction decodeBitVec(value) {\n    if (Array.isArray(value) || isString(value)) {\n        const u8a = u8aToU8a(value);\n        return [u8a.length / 8, u8a];\n    }\n    return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\nexport class BitVec extends Raw {\n    // In lieu of having the Msb/Lsb identifiers passed through, we default to assuming\n    // we are dealing with Lsb, which is the default (as of writing) BitVec format used\n    // in the Polkadot code (this only affects the toHuman displays)\n    constructor(registry, value, isMsb = false) {\n        const [decodedLength, u8a] = decodeBitVec(value);\n        super(registry, u8a);\n        _BitVec_decodedLength.set(this, void 0);\n        _BitVec_isMsb.set(this, void 0);\n        __classPrivateFieldSet(this, _BitVec_decodedLength, decodedLength, \"f\");\n        __classPrivateFieldSet(this, _BitVec_isMsb, isMsb, \"f\");\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.length + compactToU8a(__classPrivateFieldGet(this, _BitVec_decodedLength, \"f\")).length;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [compactToU8a(__classPrivateFieldGet(this, _BitVec_decodedLength, \"f\")), super.toU8a()]\n        };\n    }\n    /**\n     * @description Creates a boolean array of the bit values\n     */\n    toBoolArray() {\n        const map = [...this.toU8a(true)].map((v) => [\n            !!(v & 128),\n            !!(v & 64),\n            !!(v & 32),\n            !!(v & 16),\n            !!(v & 8),\n            !!(v & 4),\n            !!(v & 2),\n            !!(v & 1)\n        ]);\n        const result = new Array(8 * map.length);\n        for (let i = 0; i < map.length; i++) {\n            const off = i * 8;\n            const v = map[i];\n            for (let j = 0; j < 8; j++) {\n                result[off + j] = __classPrivateFieldGet(this, _BitVec_isMsb, \"f\")\n                    ? v[j]\n                    : v[7 - j];\n            }\n        }\n        return result;\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return `0b${[...this.toU8a(true)]\n            .map((d) => `00000000${d.toString(2)}`.slice(-8))\n            .map((s) => __classPrivateFieldGet(this, _BitVec_isMsb, \"f\") ? s : s.split('').reverse().join(''))\n            .join('_')}`;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'BitVec';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const bitVec = super.toU8a(isBare);\n        return isBare\n            ? bitVec\n            : u8aConcatStrict([compactToU8a(__classPrivateFieldGet(this, _BitVec_decodedLength, \"f\")), bitVec]);\n    }\n}\n_BitVec_decodedLength = new WeakMap(), _BitVec_isMsb = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}