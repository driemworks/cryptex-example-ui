{"ast":null,"code":"import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode(_ref, validate) {\n  let {\n    coder,\n    ipfs\n  } = _ref;\n  return (value, ipfsCompat) => {\n    validate(value, ipfsCompat);\n    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);\n  };\n}\n/** @internal */\nexport function createEncode(_ref2) {\n  let {\n    coder,\n    ipfs\n  } = _ref2;\n  return (value, ipfsCompat) => {\n    const out = coder.encode(u8aToU8a(value));\n    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;\n  };\n}\n/** @internal */\nexport function createIs(validate) {\n  return (value, ipfsCompat) => {\n    try {\n      return validate(value, ipfsCompat);\n    } catch {\n      return false;\n    }\n  };\n}\n/** @internal */\nexport function createValidate(_ref3) {\n  let {\n    chars,\n    ipfs,\n    type\n  } = _ref3;\n  return (value, ipfsCompat) => {\n    if (typeof value !== 'string') {\n      throw new Error(`Expected ${type} string input`);\n    } else if (ipfs && ipfsCompat && value[0] !== ipfs) {\n      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n    }\n    for (let i = ipfsCompat ? 1 : 0; i < value.length; i++) {\n      if (!(chars.includes(value[i]) || value[i] === '=' && (i === value.length - 1 || !chars.includes(value[i + 1])))) {\n        throw new Error(`Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n      }\n    }\n    return true;\n  };\n}","map":{"version":3,"names":["u8aToU8a","createDecode","_ref","validate","coder","ipfs","value","ipfsCompat","decode","substring","createEncode","_ref2","out","encode","createIs","createValidate","_ref3","chars","type","Error","i","length","includes","charCodeAt","toString"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/util-crypto/base32/helpers.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode({ coder, ipfs }, validate) {\n    return (value, ipfsCompat) => {\n        validate(value, ipfsCompat);\n        return coder.decode(ipfs && ipfsCompat\n            ? value.substring(1)\n            : value);\n    };\n}\n/** @internal */\nexport function createEncode({ coder, ipfs }) {\n    return (value, ipfsCompat) => {\n        const out = coder.encode(u8aToU8a(value));\n        return ipfs && ipfsCompat\n            ? `${ipfs}${out}`\n            : out;\n    };\n}\n/** @internal */\nexport function createIs(validate) {\n    return (value, ipfsCompat) => {\n        try {\n            return validate(value, ipfsCompat);\n        }\n        catch {\n            return false;\n        }\n    };\n}\n/** @internal */\nexport function createValidate({ chars, ipfs, type }) {\n    return (value, ipfsCompat) => {\n        if (typeof value !== 'string') {\n            throw new Error(`Expected ${type} string input`);\n        }\n        else if (ipfs && ipfsCompat && value[0] !== ipfs) {\n            throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n        }\n        for (let i = (ipfsCompat ? 1 : 0); i < value.length; i++) {\n            if (!(chars.includes(value[i]) || (value[i] === '=' && ((i === value.length - 1) ||\n                !chars.includes(value[i + 1]))))) {\n                throw new Error(`Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n            }\n        }\n        return true;\n    };\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,gBAAgB;AACzC;AACA,OAAO,SAASC,YAAYA,CAAAC,IAAA,EAAkBC,QAAQ,EAAE;EAAA,IAA3B;IAAEC,KAAK;IAAEC;EAAK,CAAC,GAAAH,IAAA;EACxC,OAAO,CAACI,KAAK,EAAEC,UAAU,KAAK;IAC1BJ,QAAQ,CAACG,KAAK,EAAEC,UAAU,CAAC;IAC3B,OAAOH,KAAK,CAACI,MAAM,CAACH,IAAI,IAAIE,UAAU,GAChCD,KAAK,CAACG,SAAS,CAAC,CAAC,CAAC,GAClBH,KAAK,CAAC;EAChB,CAAC;AACL;AACA;AACA,OAAO,SAASI,YAAYA,CAAAC,KAAA,EAAkB;EAAA,IAAjB;IAAEP,KAAK;IAAEC;EAAK,CAAC,GAAAM,KAAA;EACxC,OAAO,CAACL,KAAK,EAAEC,UAAU,KAAK;IAC1B,MAAMK,GAAG,GAAGR,KAAK,CAACS,MAAM,CAACb,QAAQ,CAACM,KAAK,CAAC,CAAC;IACzC,OAAOD,IAAI,IAAIE,UAAU,GAClB,GAAEF,IAAK,GAAEO,GAAI,EAAC,GACfA,GAAG;EACb,CAAC;AACL;AACA;AACA,OAAO,SAASE,QAAQA,CAACX,QAAQ,EAAE;EAC/B,OAAO,CAACG,KAAK,EAAEC,UAAU,KAAK;IAC1B,IAAI;MACA,OAAOJ,QAAQ,CAACG,KAAK,EAAEC,UAAU,CAAC;IACtC,CAAC,CACD,MAAM;MACF,OAAO,KAAK;IAChB;EACJ,CAAC;AACL;AACA;AACA,OAAO,SAASQ,cAAcA,CAAAC,KAAA,EAAwB;EAAA,IAAvB;IAAEC,KAAK;IAAEZ,IAAI;IAAEa;EAAK,CAAC,GAAAF,KAAA;EAChD,OAAO,CAACV,KAAK,EAAEC,UAAU,KAAK;IAC1B,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;MAC3B,MAAM,IAAIa,KAAK,CAAE,YAAWD,IAAK,eAAc,CAAC;IACpD,CAAC,MACI,IAAIb,IAAI,IAAIE,UAAU,IAAID,KAAK,CAAC,CAAC,CAAC,KAAKD,IAAI,EAAE;MAC9C,MAAM,IAAIc,KAAK,CAAE,4BAA2BD,IAAK,mBAAkBb,IAAK,GAAE,CAAC;IAC/E;IACA,KAAK,IAAIe,CAAC,GAAIb,UAAU,GAAG,CAAC,GAAG,CAAE,EAAEa,CAAC,GAAGd,KAAK,CAACe,MAAM,EAAED,CAAC,EAAE,EAAE;MACtD,IAAI,EAAEH,KAAK,CAACK,QAAQ,CAAChB,KAAK,CAACc,CAAC,CAAC,CAAC,IAAKd,KAAK,CAACc,CAAC,CAAC,KAAK,GAAG,KAAMA,CAAC,KAAKd,KAAK,CAACe,MAAM,GAAG,CAAC,IAC3E,CAACJ,KAAK,CAACK,QAAQ,CAAChB,KAAK,CAACc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAE,CAAC,EAAE;QAClC,MAAM,IAAID,KAAK,CAAE,WAAUD,IAAK,eAAcZ,KAAK,CAACc,CAAC,CAAE,QAAOd,KAAK,CAACiB,UAAU,CAACH,CAAC,CAAC,CAACI,QAAQ,CAAC,EAAE,CAAE,cAAaJ,CAAE,EAAC,CAAC;MACpH;IACJ;IACA,OAAO,IAAI;EACf,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}