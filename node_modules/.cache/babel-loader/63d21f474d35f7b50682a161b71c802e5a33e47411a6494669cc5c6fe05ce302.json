{"ast":null,"code":"var _RpcCore_instanceId, _RpcCore_registryDefault, _RpcCore_getBlockRegistry, _RpcCore_getBlockHash, _RpcCore_storageCache;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { hexToU8a, isFunction, isNull, isUndefined, lazyMethod, logger, memoize, objectSpread, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from './util/index.js';\nexport { packageInfo } from './packageInfo.js';\nexport * from './util/index.js';\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n};\n/** @internal */\nfunction logErrorMessage(method, _ref, error) {\n  let {\n    noErrorLog,\n    params,\n    type\n  } = _ref;\n  if (noErrorLog) {\n    return;\n  }\n  const inputs = params.map(_ref2 => {\n    let {\n      isOptional,\n      name,\n      type\n    } = _ref2;\n    return `${name}${isOptional ? '?' : ''}: ${type}`;\n  }).join(', ');\n  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);\n}\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\nexport class RpcCore {\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  constructor(instanceId, registry, provider) {\n    let userRpc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _RpcCore_instanceId.set(this, void 0);\n    _RpcCore_registryDefault.set(this, void 0);\n    _RpcCore_getBlockRegistry.set(this, void 0);\n    _RpcCore_getBlockHash.set(this, void 0);\n    _RpcCore_storageCache.set(this, new Map());\n    this.mapping = new Map();\n    this.sections = [];\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    if (!provider || !isFunction(provider.send)) {\n      throw new Error('Expected Provider to API create');\n    }\n    __classPrivateFieldSet(this, _RpcCore_instanceId, instanceId, \"f\");\n    __classPrivateFieldSet(this, _RpcCore_registryDefault, registry, \"f\");\n    this.provider = provider;\n    const sectionNames = Object.keys(rpcDefinitions);\n    // these are the base keys (i.e. part of jsonrpc)\n    this.sections.push(...sectionNames);\n    // decorate all interfaces, defined and user on this instance\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n  setRegistrySwap(registrySwap) {\n    __classPrivateFieldSet(this, _RpcCore_getBlockRegistry, memoize(registrySwap, {\n      getInstanceId: () => __classPrivateFieldGet(this, _RpcCore_instanceId, \"f\")\n    }), \"f\");\n  }\n  /**\n   * @description Sets a function to resolve block hash from block number\n   */\n  setResolveBlockHash(resolveBlockHash) {\n    __classPrivateFieldSet(this, _RpcCore_getBlockHash, memoize(resolveBlockHash, {\n      getInstanceId: () => __classPrivateFieldGet(this, _RpcCore_instanceId, \"f\")\n    }), \"f\");\n  }\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(k => !this.sections.includes(k)));\n    for (let s = 0; s < this.sections.length; s++) {\n      const section = this.sections[s];\n      const defs = objectSpread({}, rpcDefinitions[section], userRpc[section]);\n      const methods = Object.keys(defs);\n      for (let m = 0; m < methods.length; m++) {\n        const method = methods[m];\n        const def = defs[method];\n        const jsonrpc = def.endpoint || `${section}_${method}`;\n        if (!this.mapping.has(jsonrpc)) {\n          const isSubscription = !!def.pubsub;\n          if (!this[section]) {\n            this[section] = {};\n          }\n          this.mapping.set(jsonrpc, objectSpread({}, def, {\n            isSubscription,\n            jsonrpc,\n            method,\n            section\n          }));\n          lazyMethod(this[section], method, () => isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def));\n        }\n      }\n    }\n  }\n  _memomize(creator, def) {\n    const memoOpts = {\n      getInstanceId: () => __classPrivateFieldGet(this, _RpcCore_instanceId, \"f\")\n    };\n    const memoized = memoize(creator(true), memoOpts);\n    memoized.raw = memoize(creator(false), memoOpts);\n    memoized.meta = def;\n    return memoized;\n  }\n  _formatResult(isScale, registry, blockHash, method, def, params, result) {\n    return isScale ? this._formatOutput(registry, blockHash, method, def, params, result) : result;\n  }\n  _createMethodSend(section, method, def) {\n    const rpcName = def.endpoint || `${section}_${method}`;\n    const hashIndex = def.params.findIndex(_ref3 => {\n      let {\n        isHistoric\n      } = _ref3;\n      return isHistoric;\n    });\n    let memoized = null;\n    // execute the RPC call, doing a registry swap for historic as applicable\n    const callWithRegistry = async (isScale, values) => {\n      const blockId = hashIndex === -1 ? null : values[hashIndex];\n      const blockHash = blockId && def.params[hashIndex].type === 'BlockNumber' ? await __classPrivateFieldGet(this, _RpcCore_getBlockHash, \"f\")?.call(this, blockId) : blockId;\n      const {\n        registry\n      } = isScale && blockHash && __classPrivateFieldGet(this, _RpcCore_getBlockRegistry, \"f\") ? await __classPrivateFieldGet(this, _RpcCore_getBlockRegistry, \"f\").call(this, u8aToU8a(blockHash)) : {\n        registry: __classPrivateFieldGet(this, _RpcCore_registryDefault, \"f\")\n      };\n      const params = this._formatInputs(registry, null, def, values);\n      // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied\n      const result = await this.provider.send(rpcName, params.map(p => p.toJSON()), !!blockHash);\n      return this._formatResult(isScale, registry, blockHash, method, def, params, result);\n    };\n    const creator = isScale => function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n      const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];\n      return new Observable(observer => {\n        callWithRegistry(isScale, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          // delete old results from cache\n          if (isScale) {\n            memoized?.unmemoize(...values);\n          } else {\n            memoized?.raw.unmemoize(...values);\n          }\n        };\n      }).pipe(\n      // eslint-disable-next-line deprecation/deprecation\n      publishReplay(1),\n      // create a Replay(1)\n      isDelayed ? refCountDelay() // Unsubscribe after delay\n      // eslint-disable-next-line deprecation/deprecation\n      : refCount());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  // create a subscriptor, it subscribes once and resolves with the id as subscribe\n  _createSubscriber(_ref4, errorHandler) {\n    let {\n      paramsJson,\n      subName,\n      subType,\n      update\n    } = _ref4;\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n  _createMethodSubscribe(section, method, def) {\n    var _this = this;\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n    let memoized = null;\n    const creator = isScale => function () {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n      return new Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n        const registry = __classPrivateFieldGet(_this, _RpcCore_registryDefault, \"f\");\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n        try {\n          const params = _this._formatInputs(registry, null, def, values);\n          const paramsJson = params.map(p => p.toJSON());\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n            try {\n              observer.next(_this._formatResult(isScale, registry, null, method, def, params, result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n          subscriptionPromise = _this._createSubscriber({\n            paramsJson,\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        }\n        // Teardown logic\n        return () => {\n          // Delete from cache, so old results don't hang around\n          if (isScale) {\n            memoized?.unmemoize(...values);\n          } else {\n            memoized?.raw.unmemoize(...values);\n          }\n          // Unsubscribe from provider\n          subscriptionPromise.then(subscriptionId => isNull(subscriptionId) ? Promise.resolve(false) : _this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe(drr());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  _formatInputs(registry, blockHash, def, inputs) {\n    const reqArgCount = def.params.filter(_ref5 => {\n      let {\n        isOptional\n      } = _ref5;\n      return !isOptional;\n    }).length;\n    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;\n    if (inputs.length < reqArgCount || inputs.length > def.params.length) {\n      throw new Error(`Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);\n    }\n    return inputs.map((input, index) => registry.createTypeUnsafe(def.params[index].type, [input], {\n      blockHash\n    }));\n  }\n  _formatOutput(registry, blockHash, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n      return this._formatStorageData(registry, blockHash, key, result);\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const mapped = result.map(_ref6 => {\n        let {\n          block,\n          changes\n        } = _ref6;\n        return [registry.createType('Hash', block), this._formatStorageSet(registry, block, params[0], changes)];\n      });\n      // we only query at a specific block, not a range - flatten\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n    return registry.createTypeUnsafe(rpc.type, [result], {\n      blockHash\n    });\n  }\n  _formatStorageData(registry, blockHash, key, value) {\n    const isEmpty = isNull(value);\n    // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n    const input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);\n    return this._newType(registry, blockHash, key, input, isEmpty);\n  }\n  _formatStorageSet(registry, blockHash, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const withCache = keys.length !== 1;\n    // multiple return values (via state.storage subscription), decode the values\n    // one at a time, all based on the query types. Three values can be returned -\n    //   - Codec - There is a valid value, non-empty\n    //   - null - The storage key is empty\n    return keys.reduce((results, key, index) => {\n      results.push(this._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));\n      return results;\n    }, []);\n  }\n  _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {\n    const hexKey = key.toHex();\n    const found = changes.find(_ref7 => {\n      let [key] = _ref7;\n      return key === hexKey;\n    });\n    const isNotFound = isUndefined(found);\n    // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n    if (isNotFound && withCache) {\n      const cached = __classPrivateFieldGet(this, _RpcCore_storageCache, \"f\").get(hexKey);\n      if (cached) {\n        return cached;\n      }\n    }\n    const value = isNotFound ? null : found[1];\n    const isEmpty = isNull(value);\n    const input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value);\n    const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n    // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n    __classPrivateFieldGet(this, _RpcCore_storageCache, \"f\").set(hexKey, codec);\n    return codec;\n  }\n  _newType(registry, blockHash, key, input, isEmpty) {\n    let entryIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const entryNum = entryIndex === -1 ? '' : ` entry ${entryIndex}:`;\n    try {\n      return registry.createTypeUnsafe(type, [isEmpty ? meta.fallback\n      // For old-style Linkage, we add an empty linkage at the end\n      ? type.includes('Linkage<') ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2)) : hexToU8a(meta.fallback.toHex()) : undefined : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], {\n        blockHash,\n        isPedantic: true\n      }) : input], {\n        blockHash,\n        isFallback: isEmpty && !!meta.fallback,\n        isOptional: meta.modifier.isOptional,\n        isPedantic: !meta.modifier.isOptional\n      });\n    } catch (error) {\n      throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);\n    }\n  }\n}\n_RpcCore_instanceId = new WeakMap(), _RpcCore_registryDefault = new WeakMap(), _RpcCore_getBlockRegistry = new WeakMap(), _RpcCore_getBlockHash = new WeakMap(), _RpcCore_storageCache = new WeakMap();","map":{"version":3,"names":["_RpcCore_instanceId","_RpcCore_registryDefault","_RpcCore_getBlockRegistry","_RpcCore_getBlockHash","_RpcCore_storageCache","__classPrivateFieldGet","__classPrivateFieldSet","Observable","publishReplay","refCount","rpcDefinitions","hexToU8a","isFunction","isNull","isUndefined","lazyMethod","logger","memoize","objectSpread","u8aConcat","u8aToU8a","drr","refCountDelay","packageInfo","l","EMPTY_META","fallback","undefined","modifier","isOptional","type","asMap","linked","isTrue","isMap","logErrorMessage","method","_ref","error","noErrorLog","params","inputs","map","_ref2","name","join","message","isTreatAsHex","key","includes","toHex","RpcCore","constructor","instanceId","registry","provider","userRpc","arguments","length","set","Map","mapping","sections","send","Error","sectionNames","Object","keys","push","addUserInterfaces","isConnected","connect","disconnect","setRegistrySwap","registrySwap","getInstanceId","setResolveBlockHash","resolveBlockHash","filter","k","s","section","defs","methods","m","def","jsonrpc","endpoint","has","isSubscription","pubsub","_createMethodSubscribe","_createMethodSend","_memomize","creator","memoOpts","memoized","raw","meta","_formatResult","isScale","blockHash","result","_formatOutput","rpcName","hashIndex","findIndex","_ref3","isHistoric","callWithRegistry","values","blockId","call","_formatInputs","p","toJSON","_len","Array","_key","isDelayed","observer","then","value","next","complete","catch","unmemoize","pipe","_createSubscriber","_ref4","errorHandler","paramsJson","subName","subType","update","Promise","resolve","reject","subscribe","_this","updateType","subMethod","unsubMethod","unsubName","_len2","_key2","subscriptionPromise","subscriptionId","unsubscribe","reqArgCount","_ref5","optText","input","index","createTypeUnsafe","rpc","_formatStorageData","_formatStorageSet","block","changes","createType","mapped","_ref6","isEmpty","_newType","withCache","reduce","results","_formatStorageSetEntry","entryIndex","hexKey","found","find","_ref7","isNotFound","cached","get","codec","outputType","entryNum","Uint8Array","isPedantic","isFallback","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/rpc-core/bundle.js"],"sourcesContent":["var _RpcCore_instanceId, _RpcCore_registryDefault, _RpcCore_getBlockRegistry, _RpcCore_getBlockHash, _RpcCore_storageCache;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { hexToU8a, isFunction, isNull, isUndefined, lazyMethod, logger, memoize, objectSpread, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from './util/index.js';\nexport { packageInfo } from './packageInfo.js';\nexport * from './util/index.js';\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n    fallback: undefined,\n    modifier: { isOptional: true },\n    type: {\n        asMap: { linked: { isTrue: false } },\n        isMap: false\n    }\n};\n/** @internal */\nfunction logErrorMessage(method, { noErrorLog, params, type }, error) {\n    if (noErrorLog) {\n        return;\n    }\n    const inputs = params.map(({ isOptional, name, type }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');\n    l.error(`${method}(${inputs}): ${type}:: ${error.message}`);\n}\nfunction isTreatAsHex(key) {\n    // :code is problematic - it does not have the length attached, which is\n    // unlike all other storage entries where it is indeed properly encoded\n    return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\nexport class RpcCore {\n    /**\n     * @constructor\n     * Default constructor for the Api Object\n     * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n     */\n    constructor(instanceId, registry, provider, userRpc = {}) {\n        _RpcCore_instanceId.set(this, void 0);\n        _RpcCore_registryDefault.set(this, void 0);\n        _RpcCore_getBlockRegistry.set(this, void 0);\n        _RpcCore_getBlockHash.set(this, void 0);\n        _RpcCore_storageCache.set(this, new Map());\n        this.mapping = new Map();\n        this.sections = [];\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        if (!provider || !isFunction(provider.send)) {\n            throw new Error('Expected Provider to API create');\n        }\n        __classPrivateFieldSet(this, _RpcCore_instanceId, instanceId, \"f\");\n        __classPrivateFieldSet(this, _RpcCore_registryDefault, registry, \"f\");\n        this.provider = provider;\n        const sectionNames = Object.keys(rpcDefinitions);\n        // these are the base keys (i.e. part of jsonrpc)\n        this.sections.push(...sectionNames);\n        // decorate all interfaces, defined and user on this instance\n        this.addUserInterfaces(userRpc);\n    }\n    /**\n     * @description Returns the connected status of a provider\n     */\n    get isConnected() {\n        return this.provider.isConnected;\n    }\n    /**\n     * @description Manually connect from the attached provider\n     */\n    connect() {\n        return this.provider.connect();\n    }\n    /**\n     * @description Manually disconnect from the attached provider\n     */\n    disconnect() {\n        return this.provider.disconnect();\n    }\n    /**\n     * @description Sets a registry swap (typically from Api)\n     */\n    setRegistrySwap(registrySwap) {\n        __classPrivateFieldSet(this, _RpcCore_getBlockRegistry, memoize(registrySwap, {\n            getInstanceId: () => __classPrivateFieldGet(this, _RpcCore_instanceId, \"f\")\n        }), \"f\");\n    }\n    /**\n     * @description Sets a function to resolve block hash from block number\n     */\n    setResolveBlockHash(resolveBlockHash) {\n        __classPrivateFieldSet(this, _RpcCore_getBlockHash, memoize(resolveBlockHash, {\n            getInstanceId: () => __classPrivateFieldGet(this, _RpcCore_instanceId, \"f\")\n        }), \"f\");\n    }\n    addUserInterfaces(userRpc) {\n        // add any extra user-defined sections\n        this.sections.push(...Object.keys(userRpc).filter((k) => !this.sections.includes(k)));\n        for (let s = 0; s < this.sections.length; s++) {\n            const section = this.sections[s];\n            const defs = objectSpread({}, rpcDefinitions[section], userRpc[section]);\n            const methods = Object.keys(defs);\n            for (let m = 0; m < methods.length; m++) {\n                const method = methods[m];\n                const def = defs[method];\n                const jsonrpc = def.endpoint || `${section}_${method}`;\n                if (!this.mapping.has(jsonrpc)) {\n                    const isSubscription = !!def.pubsub;\n                    if (!this[section]) {\n                        this[section] = {};\n                    }\n                    this.mapping.set(jsonrpc, objectSpread({}, def, { isSubscription, jsonrpc, method, section }));\n                    lazyMethod(this[section], method, () => isSubscription\n                        ? this._createMethodSubscribe(section, method, def)\n                        : this._createMethodSend(section, method, def));\n                }\n            }\n        }\n    }\n    _memomize(creator, def) {\n        const memoOpts = { getInstanceId: () => __classPrivateFieldGet(this, _RpcCore_instanceId, \"f\") };\n        const memoized = memoize(creator(true), memoOpts);\n        memoized.raw = memoize(creator(false), memoOpts);\n        memoized.meta = def;\n        return memoized;\n    }\n    _formatResult(isScale, registry, blockHash, method, def, params, result) {\n        return isScale\n            ? this._formatOutput(registry, blockHash, method, def, params, result)\n            : result;\n    }\n    _createMethodSend(section, method, def) {\n        const rpcName = def.endpoint || `${section}_${method}`;\n        const hashIndex = def.params.findIndex(({ isHistoric }) => isHistoric);\n        let memoized = null;\n        // execute the RPC call, doing a registry swap for historic as applicable\n        const callWithRegistry = async (isScale, values) => {\n            const blockId = hashIndex === -1\n                ? null\n                : values[hashIndex];\n            const blockHash = blockId && def.params[hashIndex].type === 'BlockNumber'\n                ? await __classPrivateFieldGet(this, _RpcCore_getBlockHash, \"f\")?.call(this, blockId)\n                : blockId;\n            const { registry } = isScale && blockHash && __classPrivateFieldGet(this, _RpcCore_getBlockRegistry, \"f\")\n                ? await __classPrivateFieldGet(this, _RpcCore_getBlockRegistry, \"f\").call(this, u8aToU8a(blockHash))\n                : { registry: __classPrivateFieldGet(this, _RpcCore_registryDefault, \"f\") };\n            const params = this._formatInputs(registry, null, def, values);\n            // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied\n            const result = await this.provider.send(rpcName, params.map((p) => p.toJSON()), !!blockHash);\n            return this._formatResult(isScale, registry, blockHash, method, def, params, result);\n        };\n        const creator = (isScale) => (...values) => {\n            const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];\n            return new Observable((observer) => {\n                callWithRegistry(isScale, values)\n                    .then((value) => {\n                    observer.next(value);\n                    observer.complete();\n                })\n                    .catch((error) => {\n                    logErrorMessage(method, def, error);\n                    observer.error(error);\n                    observer.complete();\n                });\n                return () => {\n                    // delete old results from cache\n                    if (isScale) {\n                        memoized?.unmemoize(...values);\n                    }\n                    else {\n                        memoized?.raw.unmemoize(...values);\n                    }\n                };\n            }).pipe(\n            // eslint-disable-next-line deprecation/deprecation\n            publishReplay(1), // create a Replay(1)\n            isDelayed\n                ? refCountDelay() // Unsubscribe after delay\n                // eslint-disable-next-line deprecation/deprecation\n                : refCount());\n        };\n        memoized = this._memomize(creator, def);\n        return memoized;\n    }\n    // create a subscriptor, it subscribes once and resolves with the id as subscribe\n    _createSubscriber({ paramsJson, subName, subType, update }, errorHandler) {\n        return new Promise((resolve, reject) => {\n            this.provider\n                .subscribe(subType, subName, paramsJson, update)\n                .then(resolve)\n                .catch((error) => {\n                errorHandler(error);\n                reject(error);\n            });\n        });\n    }\n    _createMethodSubscribe(section, method, def) {\n        const [updateType, subMethod, unsubMethod] = def.pubsub;\n        const subName = `${section}_${subMethod}`;\n        const unsubName = `${section}_${unsubMethod}`;\n        const subType = `${section}_${updateType}`;\n        let memoized = null;\n        const creator = (isScale) => (...values) => {\n            return new Observable((observer) => {\n                // Have at least an empty promise, as used in the unsubscribe\n                let subscriptionPromise = Promise.resolve(null);\n                const registry = __classPrivateFieldGet(this, _RpcCore_registryDefault, \"f\");\n                const errorHandler = (error) => {\n                    logErrorMessage(method, def, error);\n                    observer.error(error);\n                };\n                try {\n                    const params = this._formatInputs(registry, null, def, values);\n                    const paramsJson = params.map((p) => p.toJSON());\n                    const update = (error, result) => {\n                        if (error) {\n                            logErrorMessage(method, def, error);\n                            return;\n                        }\n                        try {\n                            observer.next(this._formatResult(isScale, registry, null, method, def, params, result));\n                        }\n                        catch (error) {\n                            observer.error(error);\n                        }\n                    };\n                    subscriptionPromise = this._createSubscriber({ paramsJson, subName, subType, update }, errorHandler);\n                }\n                catch (error) {\n                    errorHandler(error);\n                }\n                // Teardown logic\n                return () => {\n                    // Delete from cache, so old results don't hang around\n                    if (isScale) {\n                        memoized?.unmemoize(...values);\n                    }\n                    else {\n                        memoized?.raw.unmemoize(...values);\n                    }\n                    // Unsubscribe from provider\n                    subscriptionPromise\n                        .then((subscriptionId) => isNull(subscriptionId)\n                        ? Promise.resolve(false)\n                        : this.provider.unsubscribe(subType, unsubName, subscriptionId))\n                        .catch((error) => logErrorMessage(method, def, error));\n                };\n            }).pipe(drr());\n        };\n        memoized = this._memomize(creator, def);\n        return memoized;\n    }\n    _formatInputs(registry, blockHash, def, inputs) {\n        const reqArgCount = def.params.filter(({ isOptional }) => !isOptional).length;\n        const optText = reqArgCount === def.params.length\n            ? ''\n            : ` (${def.params.length - reqArgCount} optional)`;\n        if (inputs.length < reqArgCount || inputs.length > def.params.length) {\n            throw new Error(`Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);\n        }\n        return inputs.map((input, index) => registry.createTypeUnsafe(def.params[index].type, [input], { blockHash }));\n    }\n    _formatOutput(registry, blockHash, method, rpc, params, result) {\n        if (rpc.type === 'StorageData') {\n            const key = params[0];\n            return this._formatStorageData(registry, blockHash, key, result);\n        }\n        else if (rpc.type === 'StorageChangeSet') {\n            const keys = params[0];\n            return keys\n                ? this._formatStorageSet(registry, result.block, keys, result.changes)\n                : registry.createType('StorageChangeSet', result);\n        }\n        else if (rpc.type === 'Vec<StorageChangeSet>') {\n            const mapped = result.map(({ block, changes }) => [\n                registry.createType('Hash', block),\n                this._formatStorageSet(registry, block, params[0], changes)\n            ]);\n            // we only query at a specific block, not a range - flatten\n            return method === 'queryStorageAt'\n                ? mapped[0][1]\n                : mapped;\n        }\n        return registry.createTypeUnsafe(rpc.type, [result], { blockHash });\n    }\n    _formatStorageData(registry, blockHash, key, value) {\n        const isEmpty = isNull(value);\n        // we convert to Uint8Array since it maps to the raw encoding, all\n        // data will be correctly encoded (incl. numbers, excl. :code)\n        const input = isEmpty\n            ? null\n            : isTreatAsHex(key)\n                ? value\n                : u8aToU8a(value);\n        return this._newType(registry, blockHash, key, input, isEmpty);\n    }\n    _formatStorageSet(registry, blockHash, keys, changes) {\n        // For StorageChangeSet, the changes has the [key, value] mappings\n        const withCache = keys.length !== 1;\n        // multiple return values (via state.storage subscription), decode the values\n        // one at a time, all based on the query types. Three values can be returned -\n        //   - Codec - There is a valid value, non-empty\n        //   - null - The storage key is empty\n        return keys.reduce((results, key, index) => {\n            results.push(this._formatStorageSetEntry(registry, blockHash, key, changes, withCache, index));\n            return results;\n        }, []);\n    }\n    _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {\n        const hexKey = key.toHex();\n        const found = changes.find(([key]) => key === hexKey);\n        const isNotFound = isUndefined(found);\n        // if we don't find the value, this is our fallback\n        //   - in the case of an array of values, fill the hole from the cache\n        //   - if a single result value, don't fill - it is not an update hole\n        //   - fallback to an empty option in all cases\n        if (isNotFound && withCache) {\n            const cached = __classPrivateFieldGet(this, _RpcCore_storageCache, \"f\").get(hexKey);\n            if (cached) {\n                return cached;\n            }\n        }\n        const value = isNotFound\n            ? null\n            : found[1];\n        const isEmpty = isNull(value);\n        const input = isEmpty || isTreatAsHex(key)\n            ? value\n            : u8aToU8a(value);\n        const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n        // store the retrieved result - the only issue with this cache is that there is no\n        // clearing of it, so very long running processes (not just a couple of hours, longer)\n        // will increase memory beyond what is allowed.\n        __classPrivateFieldGet(this, _RpcCore_storageCache, \"f\").set(hexKey, codec);\n        return codec;\n    }\n    _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {\n        // single return value (via state.getStorage), decode the value based on the\n        // outputType that we have specified. Fallback to Raw on nothing\n        const type = key.outputType || 'Raw';\n        const meta = key.meta || EMPTY_META;\n        const entryNum = entryIndex === -1\n            ? ''\n            : ` entry ${entryIndex}:`;\n        try {\n            return registry.createTypeUnsafe(type, [\n                isEmpty\n                    ? meta.fallback\n                        // For old-style Linkage, we add an empty linkage at the end\n                        ? type.includes('Linkage<')\n                            ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2))\n                            : hexToU8a(meta.fallback.toHex())\n                        : undefined\n                    : meta.modifier.isOptional\n                        ? registry.createTypeUnsafe(type, [input], { blockHash, isPedantic: true })\n                        : input\n            ], { blockHash, isFallback: isEmpty && !!meta.fallback, isOptional: meta.modifier.isOptional, isPedantic: !meta.modifier.isOptional });\n        }\n        catch (error) {\n            throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);\n        }\n    }\n}\n_RpcCore_instanceId = new WeakMap(), _RpcCore_registryDefault = new WeakMap(), _RpcCore_getBlockRegistry = new WeakMap(), _RpcCore_getBlockHash = new WeakMap(), _RpcCore_storageCache = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}