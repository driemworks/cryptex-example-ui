{"ast":null,"code":"var _Compact_Type, _Compact_raw;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8a, compactFromU8aLim, compactToU8a, isU8a } from '@polkadot/util';\nimport { typeToConstructor } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n  return d;\n}\nfunction decodeCompact(registry, Type, value) {\n  if (isU8a(value)) {\n    const [decodedLength, bn] = (value[0] & 0b11) < 0b11 ? compactFromU8aLim(value) : compactFromU8a(value);\n    return [new Type(registry, bn), decodedLength];\n  } else if (value instanceof Compact) {\n    const raw = value.unwrap();\n    return raw instanceof Type ? [raw, 0] : [new Type(registry, raw), 0];\n  } else if (value instanceof Type) {\n    return [value, 0];\n  }\n  return [new Type(registry, value), 0];\n}\n/**\n * @name Compact\n * @description\n * A compact length-encoding codec wrapper. It performs the same function as Length, however\n * differs in that it uses a variable number of bytes to do the actual encoding. This is mostly\n * used by other types to add length-prefixed encoding, or in the case of wrapped types, taking\n * a number and making the compact representation thereof\n */\nexport class Compact {\n  constructor(registry, Type) {\n    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let {\n      definition,\n      setDefinition = noopSetDefinition\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _Compact_Type.set(this, void 0);\n    _Compact_raw.set(this, void 0);\n    this.registry = registry;\n    __classPrivateFieldSet(this, _Compact_Type, definition || setDefinition(typeToConstructor(registry, Type)), \"f\");\n    const [raw, decodedLength] = decodeCompact(registry, __classPrivateFieldGet(this, _Compact_Type, \"f\"), value);\n    this.initialU8aLength = decodedLength;\n    __classPrivateFieldSet(this, _Compact_raw, raw, \"f\");\n  }\n  static with(Type) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Compact {\n      constructor(registry, value) {\n        super(registry, Type, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").isEmpty;\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n  bitLength() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").bitLength();\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").eq(other instanceof Compact ? __classPrivateFieldGet(other, _Compact_raw, \"f\") : other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [this.toU8a()]\n    };\n  }\n  /**\n   * @description Returns a BigInt representation of the number\n   */\n  toBigInt() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toBigInt();\n  }\n  /**\n   * @description Returns the BN representation of the number\n   */\n  toBn() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toBn();\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n  toHex(isLe) {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toHex(isLe);\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended) {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toHuman(isExtended);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toJSON();\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n  toNumber() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toNumber();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toPrimitive();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `Compact<${this.registry.getClassName(__classPrivateFieldGet(this, _Compact_Type, \"f\")) || __classPrivateFieldGet(this, _Compact_raw, \"f\").toRawType()}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\").toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a(_isBare) {\n    return compactToU8a(__classPrivateFieldGet(this, _Compact_raw, \"f\").toBn());\n  }\n  /**\n   * @description Returns the embedded [[UInt]] or [[Moment]] value\n   */\n  unwrap() {\n    return __classPrivateFieldGet(this, _Compact_raw, \"f\");\n  }\n}\n_Compact_Type = new WeakMap(), _Compact_raw = new WeakMap();","map":{"version":3,"names":["_Compact_Type","_Compact_raw","__classPrivateFieldGet","__classPrivateFieldSet","compactFromU8a","compactFromU8aLim","compactToU8a","isU8a","typeToConstructor","noopSetDefinition","d","decodeCompact","registry","Type","value","decodedLength","bn","Compact","raw","unwrap","constructor","arguments","length","undefined","definition","setDefinition","set","initialU8aLength","with","encodedLength","toU8a","hash","isEmpty","bitLength","eq","other","inspect","outer","toBigInt","toBn","toHex","isLe","toHuman","isExtended","toJSON","toNumber","toPrimitive","toRawType","getClassName","toString","_isBare","WeakMap"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/types-codec/base/Compact.js"],"sourcesContent":["var _Compact_Type, _Compact_raw;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"tslib\";\nimport { compactFromU8a, compactFromU8aLim, compactToU8a, isU8a } from '@polkadot/util';\nimport { typeToConstructor } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n    return d;\n}\nfunction decodeCompact(registry, Type, value) {\n    if (isU8a(value)) {\n        const [decodedLength, bn] = (value[0] & 0b11) < 0b11\n            ? compactFromU8aLim(value)\n            : compactFromU8a(value);\n        return [new Type(registry, bn), decodedLength];\n    }\n    else if (value instanceof Compact) {\n        const raw = value.unwrap();\n        return raw instanceof Type\n            ? [raw, 0]\n            : [new Type(registry, raw), 0];\n    }\n    else if (value instanceof Type) {\n        return [value, 0];\n    }\n    return [new Type(registry, value), 0];\n}\n/**\n * @name Compact\n * @description\n * A compact length-encoding codec wrapper. It performs the same function as Length, however\n * differs in that it uses a variable number of bytes to do the actual encoding. This is mostly\n * used by other types to add length-prefixed encoding, or in the case of wrapped types, taking\n * a number and making the compact representation thereof\n */\nexport class Compact {\n    constructor(registry, Type, value = 0, { definition, setDefinition = noopSetDefinition } = {}) {\n        _Compact_Type.set(this, void 0);\n        _Compact_raw.set(this, void 0);\n        this.registry = registry;\n        __classPrivateFieldSet(this, _Compact_Type, definition || setDefinition(typeToConstructor(registry, Type)), \"f\");\n        const [raw, decodedLength] = decodeCompact(registry, __classPrivateFieldGet(this, _Compact_Type, \"f\"), value);\n        this.initialU8aLength = decodedLength;\n        __classPrivateFieldSet(this, _Compact_raw, raw, \"f\");\n    }\n    static with(Type) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends Compact {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").isEmpty;\n    }\n    /**\n     * @description Returns the number of bits in the value\n     */\n    bitLength() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").bitLength();\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").eq(other instanceof Compact\n            ? __classPrivateFieldGet(other, _Compact_raw, \"f\")\n            : other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a BigInt representation of the number\n     */\n    toBigInt() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toBigInt();\n    }\n    /**\n     * @description Returns the BN representation of the number\n     */\n    toBn() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toBn();\n    }\n    /**\n     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n     */\n    toHex(isLe) {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toHex(isLe);\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended) {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toHuman(isExtended);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toJSON();\n    }\n    /**\n     * @description Returns the number representation for the value\n     */\n    toNumber() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toNumber();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toPrimitive();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `Compact<${this.registry.getClassName(__classPrivateFieldGet(this, _Compact_Type, \"f\")) || __classPrivateFieldGet(this, _Compact_raw, \"f\").toRawType()}>`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\").toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return compactToU8a(__classPrivateFieldGet(this, _Compact_raw, \"f\").toBn());\n    }\n    /**\n     * @description Returns the embedded [[UInt]] or [[Moment]] value\n     */\n    unwrap() {\n        return __classPrivateFieldGet(this, _Compact_raw, \"f\");\n    }\n}\n_Compact_Type = new WeakMap(), _Compact_raw = new WeakMap();\n"],"mappings":"AAAA,IAAIA,aAAa,EAAEC,YAAY;AAC/B,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,OAAO;AACtE,SAASC,cAAc,EAAEC,iBAAiB,EAAEC,YAAY,EAAEC,KAAK,QAAQ,gBAAgB;AACvF,SAASC,iBAAiB,QAAQ,mBAAmB;AACrD,SAASC,iBAAiBA,CAACC,CAAC,EAAE;EAC1B,OAAOA,CAAC;AACZ;AACA,SAASC,aAAaA,CAACC,QAAQ,EAAEC,IAAI,EAAEC,KAAK,EAAE;EAC1C,IAAIP,KAAK,CAACO,KAAK,CAAC,EAAE;IACd,MAAM,CAACC,aAAa,EAAEC,EAAE,CAAC,GAAG,CAACF,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,IAAI,GAC9CT,iBAAiB,CAACS,KAAK,CAAC,GACxBV,cAAc,CAACU,KAAK,CAAC;IAC3B,OAAO,CAAC,IAAID,IAAI,CAACD,QAAQ,EAAEI,EAAE,CAAC,EAAED,aAAa,CAAC;EAClD,CAAC,MACI,IAAID,KAAK,YAAYG,OAAO,EAAE;IAC/B,MAAMC,GAAG,GAAGJ,KAAK,CAACK,MAAM,EAAE;IAC1B,OAAOD,GAAG,YAAYL,IAAI,GACpB,CAACK,GAAG,EAAE,CAAC,CAAC,GACR,CAAC,IAAIL,IAAI,CAACD,QAAQ,EAAEM,GAAG,CAAC,EAAE,CAAC,CAAC;EACtC,CAAC,MACI,IAAIJ,KAAK,YAAYD,IAAI,EAAE;IAC5B,OAAO,CAACC,KAAK,EAAE,CAAC,CAAC;EACrB;EACA,OAAO,CAAC,IAAID,IAAI,CAACD,QAAQ,EAAEE,KAAK,CAAC,EAAE,CAAC,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,OAAO,CAAC;EACjBG,WAAWA,CAACR,QAAQ,EAAEC,IAAI,EAAqE;IAAA,IAAnEC,KAAK,GAAAO,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,IAAE;MAAEG,UAAU;MAAEC,aAAa,GAAGhB;IAAkB,CAAC,GAAAY,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACzFrB,aAAa,CAAC0B,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC/BzB,YAAY,CAACyB,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC9B,IAAI,CAACd,QAAQ,GAAGA,QAAQ;IACxBT,sBAAsB,CAAC,IAAI,EAAEH,aAAa,EAAEwB,UAAU,IAAIC,aAAa,CAACjB,iBAAiB,CAACI,QAAQ,EAAEC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC;IAChH,MAAM,CAACK,GAAG,EAAEH,aAAa,CAAC,GAAGJ,aAAa,CAACC,QAAQ,EAAEV,sBAAsB,CAAC,IAAI,EAAEF,aAAa,EAAE,GAAG,CAAC,EAAEc,KAAK,CAAC;IAC7G,IAAI,CAACa,gBAAgB,GAAGZ,aAAa;IACrCZ,sBAAsB,CAAC,IAAI,EAAEF,YAAY,EAAEiB,GAAG,EAAE,GAAG,CAAC;EACxD;EACA,OAAOU,IAAIA,CAACf,IAAI,EAAE;IACd,IAAIW,UAAU;IACd;IACA,MAAMC,aAAa,GAAIf,CAAC,IAAMc,UAAU,GAAGd,CAAE;IAC7C,OAAO,cAAcO,OAAO,CAAC;MACzBG,WAAWA,CAACR,QAAQ,EAAEE,KAAK,EAAE;QACzB,KAAK,CAACF,QAAQ,EAAEC,IAAI,EAAEC,KAAK,EAAE;UAAEU,UAAU;UAAEC;QAAc,CAAC,CAAC;MAC/D;IACJ,CAAC;EACL;EACA;AACJ;AACA;EACI,IAAII,aAAaA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACC,KAAK,EAAE,CAACR,MAAM;EAC9B;EACA;AACJ;AACA;EACI,IAAIS,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACnB,QAAQ,CAACmB,IAAI,CAAC,IAAI,CAACD,KAAK,EAAE,CAAC;EAC3C;EACA;AACJ;AACA;EACI,IAAIE,OAAOA,CAAA,EAAG;IACV,OAAO9B,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAAC+B,OAAO;EAClE;EACA;AACJ;AACA;EACIC,SAASA,CAAA,EAAG;IACR,OAAO/B,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACgC,SAAS,EAAE;EACtE;EACA;AACJ;AACA;EACIC,EAAEA,CAACC,KAAK,EAAE;IACN,OAAOjC,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACiC,EAAE,CAACC,KAAK,YAAYlB,OAAO,GAC5Ef,sBAAsB,CAACiC,KAAK,EAAElC,YAAY,EAAE,GAAG,CAAC,GAChDkC,KAAK,CAAC;EAChB;EACA;AACJ;AACA;EACIC,OAAOA,CAAA,EAAG;IACN,OAAO;MACHC,KAAK,EAAE,CAAC,IAAI,CAACP,KAAK,EAAE;IACxB,CAAC;EACL;EACA;AACJ;AACA;EACIQ,QAAQA,CAAA,EAAG;IACP,OAAOpC,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACqC,QAAQ,EAAE;EACrE;EACA;AACJ;AACA;EACIC,IAAIA,CAAA,EAAG;IACH,OAAOrC,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACsC,IAAI,EAAE;EACjE;EACA;AACJ;AACA;EACIC,KAAKA,CAACC,IAAI,EAAE;IACR,OAAOvC,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACuC,KAAK,CAACC,IAAI,CAAC;EACtE;EACA;AACJ;AACA;EACIC,OAAOA,CAACC,UAAU,EAAE;IAChB,OAAOzC,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACyC,OAAO,CAACC,UAAU,CAAC;EAC9E;EACA;AACJ;AACA;EACIC,MAAMA,CAAA,EAAG;IACL,OAAO1C,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAAC2C,MAAM,EAAE;EACnE;EACA;AACJ;AACA;EACIC,QAAQA,CAAA,EAAG;IACP,OAAO3C,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAAC4C,QAAQ,EAAE;EACrE;EACA;AACJ;AACA;EACIC,WAAWA,CAAA,EAAG;IACV,OAAO5C,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAAC6C,WAAW,EAAE;EACxE;EACA;AACJ;AACA;EACIC,SAASA,CAAA,EAAG;IACR,OAAQ,WAAU,IAAI,CAACnC,QAAQ,CAACoC,YAAY,CAAC9C,sBAAsB,CAAC,IAAI,EAAEF,aAAa,EAAE,GAAG,CAAC,CAAC,IAAIE,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAAC8C,SAAS,EAAG,GAAE;EACpK;EACA;AACJ;AACA;EACIE,QAAQA,CAAA,EAAG;IACP,OAAO/C,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACgD,QAAQ,EAAE;EACrE;EACA;AACJ;AACA;EACInB,KAAKA,CAACoB,OAAO,EAAE;IACX,OAAO5C,YAAY,CAACJ,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC,CAACsC,IAAI,EAAE,CAAC;EAC/E;EACA;AACJ;AACA;EACIpB,MAAMA,CAAA,EAAG;IACL,OAAOjB,sBAAsB,CAAC,IAAI,EAAED,YAAY,EAAE,GAAG,CAAC;EAC1D;AACJ;AACAD,aAAa,GAAG,IAAImD,OAAO,EAAE,EAAElD,YAAY,GAAG,IAAIkD,OAAO,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}