{"ast":null,"code":"import { BN } from '../bn/bn.js';\n/**\n * @name u8aToBn\n * @summary Creates a BN from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.\n * @param value The value to convert\n * @param options Options to pass while converting\n * @param options.isLe Convert using Little Endian (default)\n * @param options.isNegative Convert using two's complement\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToBn } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\nexport function u8aToBn(value) {\n  let {\n    isLe = true,\n    isNegative = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const count = value.length;\n  // shortcut for <= u48 values - in this case the manual conversion\n  // here seems to be more efficient than passing the full array\n  if (count <= 6) {\n    if (isNegative) {\n      let result = 0;\n      if (isLe) {\n        // Most common case i{8, 16, 32} default LE SCALE-encoded\n        // For <= 32, we also optimize the xor to a single op\n        // (see the comments around unrolling in the next section)\n        switch (count) {\n          case 0:\n            return new BN(0);\n          case 1:\n            result = value[0] ^ 255;\n            break;\n          case 2:\n            result = value[0] + (value[1] << 8) ^ 65535;\n            break;\n          case 3:\n            result = value[0] + (value[1] << 8) + (value[2] << 16) ^ 16777215;\n            break;\n          case 4:\n            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n            // 32-bit, in the case where the top-most bit is set this yields a negative value\n            result = value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295;\n            break;\n          case 5:\n            result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] ^ 0xff) * 4294967296;\n            break;\n          default:\n            // 6\n            result = (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216 ^ 4294967295) + (value[4] + (value[5] << 8) ^ 65535) * 4294967296;\n            break;\n        }\n      } else {\n        for (let i = 0; i < count; i++) {\n          result = result * 256 + (value[i] ^ 0xff);\n        }\n      }\n      return count ? new BN(result * -1 - 1) : new BN(0);\n    } else if (isLe) {\n      // Most common case - u{8, 16, 32} default LE SCALE-encoded\n      //\n      // There are some slight benefits in unrolling this specific loop,\n      // however it comes with diminishing returns since here the actual\n      // `new BN` does seem to take up the bulk of the time\n      switch (count) {\n        case 0:\n          return new BN(0);\n        case 1:\n          return new BN(value[0]);\n        case 2:\n          return new BN(value[0] + (value[1] << 8));\n        case 3:\n          return new BN(value[0] + (value[1] << 8) + (value[2] << 16));\n        case 4:\n          // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n          // 32-bit, in the case where the top-most bit is set this yields a negative value\n          return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 16777216);\n        case 5:\n          return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 16777216);\n        default:\n          // 6\n          return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);\n      }\n    } else {\n      let result = 0;\n      for (let i = 0; i < count; i++) {\n        result = result * 256 + value[i];\n      }\n      return new BN(result);\n    }\n  }\n  return isNegative ? new BN(value, isLe ? 'le' : 'be').fromTwos(value.length * 8) : new BN(value, isLe ? 'le' : 'be');\n}","map":{"version":3,"names":["BN","u8aToBn","value","isLe","isNegative","arguments","length","undefined","count","result","i","fromTwos"],"sources":["/home/driemworks/cryptex/ui/node_modules/@polkadot/util/u8a/toBn.js"],"sourcesContent":["import { BN } from '../bn/bn.js';\n/**\n * @name u8aToBn\n * @summary Creates a BN from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.\n * @param value The value to convert\n * @param options Options to pass while converting\n * @param options.isLe Convert using Little Endian (default)\n * @param options.isNegative Convert using two's complement\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToBn } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\nexport function u8aToBn(value, { isLe = true, isNegative = false } = {}) {\n    const count = value.length;\n    // shortcut for <= u48 values - in this case the manual conversion\n    // here seems to be more efficient than passing the full array\n    if (count <= 6) {\n        if (isNegative) {\n            let result = 0;\n            if (isLe) {\n                // Most common case i{8, 16, 32} default LE SCALE-encoded\n                // For <= 32, we also optimize the xor to a single op\n                // (see the comments around unrolling in the next section)\n                switch (count) {\n                    case 0:\n                        return new BN(0);\n                    case 1:\n                        result = value[0] ^ 255;\n                        break;\n                    case 2:\n                        result = (value[0] + (value[1] << 8)) ^ 65535;\n                        break;\n                    case 3:\n                        result = (value[0] + (value[1] << 8) + (value[2] << 16)) ^ 16777215;\n                        break;\n                    case 4:\n                        // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n                        // 32-bit, in the case where the top-most bit is set this yields a negative value\n                        result = (value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295;\n                        break;\n                    case 5:\n                        result = ((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + ((value[4] ^ 0xff) * 4294967296);\n                        break;\n                    default: // 6\n                        result = ((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + (((value[4] + (value[5] << 8)) ^ 65535) * 4294967296);\n                        break;\n                }\n            }\n            else {\n                for (let i = 0; i < count; i++) {\n                    result = (result * 256) + (value[i] ^ 0xff);\n                }\n            }\n            return count\n                ? new BN((result * -1) - 1)\n                : new BN(0);\n        }\n        else if (isLe) {\n            // Most common case - u{8, 16, 32} default LE SCALE-encoded\n            //\n            // There are some slight benefits in unrolling this specific loop,\n            // however it comes with diminishing returns since here the actual\n            // `new BN` does seem to take up the bulk of the time\n            switch (count) {\n                case 0:\n                    return new BN(0);\n                case 1:\n                    return new BN(value[0]);\n                case 2:\n                    return new BN(value[0] + (value[1] << 8));\n                case 3:\n                    return new BN(value[0] + (value[1] << 8) + (value[2] << 16));\n                case 4:\n                    // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n                    // 32-bit, in the case where the top-most bit is set this yields a negative value\n                    return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216));\n                case 5:\n                    return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8)) * 16777216));\n                default: // 6\n                    return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216));\n            }\n        }\n        else {\n            let result = 0;\n            for (let i = 0; i < count; i++) {\n                result = (result * 256) + value[i];\n            }\n            return new BN(result);\n        }\n    }\n    return isNegative\n        ? new BN(value, isLe ? 'le' : 'be').fromTwos(value.length * 8)\n        : new BN(value, isLe ? 'le' : 'be');\n}\n"],"mappings":"AAAA,SAASA,EAAE,QAAQ,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAOA,CAACC,KAAK,EAA4C;EAAA,IAA1C;IAAEC,IAAI,GAAG,IAAI;IAAEC,UAAU,GAAG;EAAM,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACnE,MAAMG,KAAK,GAAGN,KAAK,CAACI,MAAM;EAC1B;EACA;EACA,IAAIE,KAAK,IAAI,CAAC,EAAE;IACZ,IAAIJ,UAAU,EAAE;MACZ,IAAIK,MAAM,GAAG,CAAC;MACd,IAAIN,IAAI,EAAE;QACN;QACA;QACA;QACA,QAAQK,KAAK;UACT,KAAK,CAAC;YACF,OAAO,IAAIR,EAAE,CAAC,CAAC,CAAC;UACpB,KAAK,CAAC;YACFS,MAAM,GAAGP,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;YACvB;UACJ,KAAK,CAAC;YACFO,MAAM,GAAIP,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAI,KAAK;YAC7C;UACJ,KAAK,CAAC;YACFO,MAAM,GAAIP,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAI,QAAQ;YACnE;UACJ,KAAK,CAAC;YACF;YACA;YACAO,MAAM,GAAIP,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAIA,KAAK,CAAC,CAAC,CAAC,GAAG,QAAS,GAAI,UAAU;YAC7F;UACJ,KAAK,CAAC;YACFO,MAAM,GAAG,CAAEP,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAIA,KAAK,CAAC,CAAC,CAAC,GAAG,QAAS,GAAI,UAAU,IAAK,CAACA,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,UAAW;YAClI;UACJ;YAAS;YACLO,MAAM,GAAG,CAAEP,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAIA,KAAK,CAAC,CAAC,CAAC,GAAG,QAAS,GAAI,UAAU,IAAK,CAAEA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAI,KAAK,IAAI,UAAW;YACvJ;QAAM;MAElB,CAAC,MACI;QACD,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;UAC5BD,MAAM,GAAIA,MAAM,GAAG,GAAG,IAAKP,KAAK,CAACQ,CAAC,CAAC,GAAG,IAAI,CAAC;QAC/C;MACJ;MACA,OAAOF,KAAK,GACN,IAAIR,EAAE,CAAES,MAAM,GAAG,CAAC,CAAC,GAAI,CAAC,CAAC,GACzB,IAAIT,EAAE,CAAC,CAAC,CAAC;IACnB,CAAC,MACI,IAAIG,IAAI,EAAE;MACX;MACA;MACA;MACA;MACA;MACA,QAAQK,KAAK;QACT,KAAK,CAAC;UACF,OAAO,IAAIR,EAAE,CAAC,CAAC,CAAC;QACpB,KAAK,CAAC;UACF,OAAO,IAAIA,EAAE,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3B,KAAK,CAAC;UACF,OAAO,IAAIF,EAAE,CAACE,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QAC7C,KAAK,CAAC;UACF,OAAO,IAAIF,EAAE,CAACE,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;QAChE,KAAK,CAAC;UACF;UACA;UACA,OAAO,IAAIF,EAAE,CAACE,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAIA,KAAK,CAAC,CAAC,CAAC,GAAG,QAAS,CAAC;QACxF,KAAK,CAAC;UACF,OAAO,IAAIF,EAAE,CAACE,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAI,CAACA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,QAAS,CAAC;QAC5G;UAAS;UACL,OAAO,IAAIF,EAAE,CAACE,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAI,CAACA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,QAAS,CAAC;MAAC;IAExI,CAAC,MACI;MACD,IAAIO,MAAM,GAAG,CAAC;MACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;QAC5BD,MAAM,GAAIA,MAAM,GAAG,GAAG,GAAIP,KAAK,CAACQ,CAAC,CAAC;MACtC;MACA,OAAO,IAAIV,EAAE,CAACS,MAAM,CAAC;IACzB;EACJ;EACA,OAAOL,UAAU,GACX,IAAIJ,EAAE,CAACE,KAAK,EAAEC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,CAACQ,QAAQ,CAACT,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,GAC5D,IAAIN,EAAE,CAACE,KAAK,EAAEC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC;AAC3C"},"metadata":{},"sourceType":"module","externalDependencies":[]}